{
    "sourceFile": "EquivAndRefine.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1699615889368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1699615889368,
            "name": "Commit-0",
            "content": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Psatz.\nRequire Import Coq.Strings.String.\nRequire Import Coq.Classes.Morphisms.\nRequire Import Coq.Classes.Morphisms_Prop.\nRequire Import Coq.Classes.RelationClasses.\nRequire Import Coq.Logic.Classical_Pred_Type.\nRequire Import Coq.Logic.Classical_Prop.\nRequire Import SetsClass.SetsClass. Import SetsNotation.\nRequire Import compcert.lib.Integers.\nRequire Import PL.SyntaxInCoq.\nRequire Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\nRequire Import PL.PracticalDenotations. Import KTFix Sets_CL.\nImport Lang_While DntSem_While1 DntSem_While2.\nImport EDenote CDenote.\nLocal Open Scope string.\nLocal Open Scope Z.\nLocal Open Scope sets.\n\n(** * 定义与例子 *)\n\nDefinition EVar': string -> expr := EVar.\nCoercion EConst: Z >-> expr.\nCoercion EVar: var_name >-> expr.\nCoercion EVar': string >-> expr.\nNotation \"[[ e ]]\" := e\n  (at level 0, e custom expr_entry at level 99).\nNotation \"( x )\" := x\n  (in custom expr_entry, x custom expr_entry at level 99).\nNotation \"x\" := x\n  (in custom expr_entry at level 0, x constr at level 0).\nNotation \"f x\" := (f x)\n  (in custom expr_entry at level 1, only parsing,\n   f custom expr_entry,\n   x custom expr_entry at level 0).\nNotation \"x + y\" := (EBinop OPlus x y)\n  (in custom expr_entry at level 12, left associativity).\nNotation \"x - y\" := (EBinop OMinus x y)\n  (in custom expr_entry at level 12, left associativity).\nNotation \"x * y\" := (EBinop OMul x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x / y\" := (EBinop ODiv x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x % y\" := (EBinop OMod x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x <= y\" := (EBinop OLe x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x < y\" := (EBinop OLt x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x >= y\" := (EBinop OGe x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x > y\" := (EBinop OGt x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x == y\" := (EBinop OEq x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x != y\" := (EBinop ONe x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x && y\" := (EBinop OAnd x y)\n  (in custom expr_entry at level 14, left associativity).\nNotation \"x || y\" := (EBinop OOr x y)\n  (in custom expr_entry at level 15, left associativity).\nNotation \"! x\" := (EUnop ONot x)\n  (in custom expr_entry at level 10).\nNotation \"- x\" := (EUnop ONeg x)\n  (in custom expr_entry at level 10).\nNotation \"c1 ; c2\" := (CSeq c1 c2)\n  (in custom expr_entry at level 20, right associativity).\nNotation \"'skip'\" := (CSkip)\n  (in custom expr_entry at level 10).\nNotation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n  (in custom expr_entry at level 19,\n   e custom expr_entry at level 5,\n   c1 custom expr_entry at level 99,\n   c2 custom expr_entry at level 99,\n   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\nNotation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n  (in custom expr_entry at level 19,\n   e custom expr_entry at level 5,\n   c1 custom expr_entry at level 99).\n\nNotation \"⟦ e ⟧\" := (eval_expr e)\n  (at level 0, only printing, e custom expr_entry at level 99).\nNotation \"⟦ c ⟧\" := (eval_com c)\n  (at level 0, only printing, c custom expr_entry at level 99).\n\nLtac any_eval x :=\n  match goal with\n  | |- EDenote => exact (eval_expr x)\n  | |- CDenote => exact (eval_com x)\n  | _ => match type of x with\n         | expr => exact (eval_expr x)\n         | com => exact (eval_com x)\n         end\n  end.\n\nNotation \"⟦ x ⟧\" := (ltac:(any_eval x))\n  (at level 0, only parsing, x custom expr_entry at level 99).\n\nNotation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n  (no associativity, at level 61): sets_scope.\n\n(** 表达式语义等价 *)\n\nRecord eequiv (e1 e2: expr): Prop := {\n  nrm_eequiv:\n    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n  err_eequiv:\n    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n}.\n\n(** 表达式精化关系 *)\n\nRecord erefine (e1 e2: expr): Prop := {\n  nrm_erefine:\n    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n  err_erefine:\n    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n}.\n\n(** 程序语句语义等价 *)\n\nRecord cequiv (c1 c2: com): Prop := {\n  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n}.\n\n(** 程序语句精化关系 *)\n\nRecord crefine (c1 c2: com): Prop := {\n  nrm_crefine:\n    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n  err_crefine:\n    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n  inf_crefine:\n    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n}.\n\nNotation \"e1 '~=~' e2\" := (eequiv e1 e2)\n  (at level 69, only printing, no associativity).\nNotation \"e1 '<<=' e2\" := (erefine e1 e2)\n  (at level 69, only printing, no associativity).\nNotation \"c1 '~=~' c2\" := (cequiv c1 c2)\n  (at level 69, only printing, no associativity).\nNotation \"c1 '<<=' c2\" := (crefine c1 c2)\n  (at level 69, only printing, no associativity).\n\nLtac any_equiv x y :=\n  match type of x with\n  | expr => exact (eequiv x y)\n  | com => exact (cequiv x y)\n  | _ => match type of y with\n         | expr => exact (eequiv x y)\n         | com => exact (cequiv x y)\n         end\n  end.\n\nLtac any_refine x y :=\n  match type of x with\n  | expr => exact (erefine x y)\n  | com => exact (crefine x y)\n  | _ => match type of y with\n         | expr => exact (erefine x y)\n         | com => exact (crefine x y)\n         end\n  end.\n\nNotation \"x '~=~' y\" := (ltac:(any_equiv x y))\n  (at level 69, only parsing, no associativity).\nNotation \"x '<<=' y\" := (ltac:(any_refine x y))\n  (at level 69, only parsing, no associativity).\n\nNotation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n  (at level 1).\nNotation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n  (at level 1).\nNotation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n  (at level 1).\nNotation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n  (at level 1).\nNotation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n  (at level 1).\nNotation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n  (at level 1).\nNotation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n  (at level 1).\nNotation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n  (at level 1).\nNotation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n  (at level 1).\nNotation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n  (at level 1).\n\n(** 精化的例子 *)\n\nLemma const_plus_const_refine: forall n m: Z,\n  EConst (n + m) <<= [[n + m]].\n(** 证明见Coq代码。*)\nProof.\n  intros.\n  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n          n < Int64.min_signed \\/\n          n > Int64.max_signed) as Hn by lia.\n  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n          m < Int64.min_signed \\/\n          m > Int64.max_signed) as Hm by lia.\n  split.\n  + sets_unfold; intros s i ?.\n    simpl in H.\n    destruct H.\n    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n    - unfold arith_sem1_nrm, arith_compute1_nrm.\n      exists (Int64.repr n), (Int64.repr m).\n      pose proof Int64.signed_repr _ H1.\n      pose proof Int64.signed_repr _ H2.\n      rewrite H3, H4.\n      tauto.\n    - tauto.\n    - tauto.\n  + sets_unfold; intros s ?.\n    simpl in H.\n    simpl; sets_unfold.\n    unfold arith_sem1_err, arith_compute1_err.\n    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n    - exists (Int64.repr n), (Int64.repr m).\n      pose proof Int64.signed_repr _ H0.\n      pose proof Int64.signed_repr _ H1.\n      rewrite H2, H3.\n      tauto.\n    - tauto.\n    - tauto.\nQed.\n\n(** 语义等价的例子：顺序执行有结合律 *)\n\nTheorem CSeq_assoc: forall (c1 c2 c3: com),\n  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\nProof.\n  intros.\n  split.\n  + simpl.\n    rewrite Rels_concat_assoc.\n    reflexivity.\n  + simpl.\n    rewrite Rels_concat_union_distr_l.\n    rewrite Sets_union_assoc.\n    rewrite Rels_concat_assoc.\n    reflexivity.\n  + simpl.\n    rewrite Rels_concat_union_distr_l.\n    rewrite Sets_union_assoc.\n    rewrite Rels_concat_assoc.\n    reflexivity.\nQed.\n\n\nTheorem CIf_CSeq: forall e c1 c2 c3,\n  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n  [[ if e then { c1; c3 } else { c2; c3 } ]].\nProof.\n  intros.\n  split.\n  + simpl.\n    rewrite <- ! Rels_concat_assoc.\n    apply Rels_concat_union_distr_r.\n  + simpl.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite <- ! Rels_concat_assoc.\n    sets_unfold; intros s; tauto.\n  + simpl.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite <- ! Rels_concat_assoc.\n    sets_unfold; intros s; tauto.\nQed.\n\n\n\n\n(** * 语义等价与精化的性质 *)\n\n\n(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n\n\n    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n    将稍后再解释_[Instance]_关键字的特殊作用。*)\n\nInstance eequiv_refl: Reflexive eequiv.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + reflexivity.\n  + reflexivity.\nQed.\n\nInstance eequiv_sym: Symmetric eequiv.\nProof.\n  unfold Symmetric; intros.\n  split.\n  + rewrite H.(nrm_eequiv).\n    reflexivity.\n  + rewrite H.(err_eequiv).\n    reflexivity.\nQed.\n\nInstance eequiv_trans: Transitive eequiv.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n    reflexivity.\n  + rewrite H.(err_eequiv), H0.(err_eequiv).\n    reflexivity.\nQed.\n\nInstance eequiv_equiv: Equivalence eequiv.\nProof.\n  split.\n  + apply eequiv_refl.\n  + apply eequiv_sym.\n  + apply eequiv_trans.\nQed.\n\n(** 下面还可以证明精化关系也具有自反性和传递性。*)\n\nInstance erefine_refl: Reflexive erefine.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + apply Sets_included_union1.\n  + reflexivity.\nQed.\n\nInstance erefine_trans: Transitive erefine.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_erefine).\n    rewrite H0.(nrm_erefine).\n    rewrite H0.(err_erefine).\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite H.(err_erefine).\n    rewrite H0.(err_erefine).\n    reflexivity.\nQed.\n\n(** 并且精化关系在语义等价变换下不变。*)\n\nInstance erefine_well_defined:\n  Proper (eequiv ==> eequiv ==> iff) erefine.\nProof.\n  unfold Proper, respectful; intros.\n  split; intros.\n  + split.\n    - rewrite <- H.(nrm_eequiv).\n      rewrite <- H0.(nrm_eequiv).\n      rewrite <- H0.(err_eequiv).\n      apply H1.(nrm_erefine).\n    - rewrite <- H.(err_eequiv).\n      rewrite <- H0.(err_eequiv).\n      apply H1.(err_erefine).\n  + split.\n    - rewrite H.(nrm_eequiv).\n      rewrite H0.(nrm_eequiv).\n      rewrite H0.(err_eequiv).\n      apply H1.(nrm_erefine).\n    - rewrite H.(err_eequiv).\n      rewrite H0.(err_eequiv).\n      apply H1.(err_erefine).\nQed.\n\n(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n    性。*)\n\nInstance cequiv_refl: Reflexive cequiv.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + reflexivity.\n  + reflexivity.\n  + reflexivity.\nQed.\n\nInstance cequiv_sym: Symmetric cequiv.\nProof.\n  unfold Symmetric; intros.\n  split.\n  + rewrite H.(nrm_cequiv).\n    reflexivity.\n  + rewrite H.(err_cequiv).\n    reflexivity.\n  + rewrite H.(inf_cequiv).\n    reflexivity.\nQed.\n\nInstance cequiv_trans: Transitive cequiv.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n    reflexivity.\n  + rewrite H.(err_cequiv), H0.(err_cequiv).\n    reflexivity.\n  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n    reflexivity.\nQed.\n\nInstance cequiv_equiv: Equivalence cequiv.\nProof.\n  split.\n  + apply cequiv_refl.\n  + apply cequiv_sym.\n  + apply cequiv_trans.\nQed.\n\nInstance crefine_refl: Reflexive crefine.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + apply Sets_included_union1.\n  + reflexivity.\n  + apply Sets_included_union1.\nQed.\n\nInstance crefine_trans: Transitive crefine.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_crefine).\n    rewrite H0.(nrm_crefine).\n    rewrite H0.(err_crefine).\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite H.(err_crefine).\n    rewrite H0.(err_crefine).\n    reflexivity.\n  + rewrite H.(inf_crefine).\n    rewrite H0.(inf_crefine).\n    rewrite H0.(err_crefine).\n    sets_unfold; intros s; tauto.\nQed.\n\nInstance crefine_well_defined:\n  Proper (cequiv ==> cequiv ==> iff) crefine.\nProof.\n  unfold Proper, respectful; intros.\n  split; intros.\n  + split.\n    - rewrite <- H.(nrm_cequiv).\n      rewrite <- H0.(nrm_cequiv).\n      rewrite <- H0.(err_cequiv).\n      apply H1.(nrm_crefine).\n    - rewrite <- H.(err_cequiv).\n      rewrite <- H0.(err_cequiv).\n      apply H1.(err_crefine).\n    - rewrite <- H.(inf_cequiv).\n      rewrite <- H0.(inf_cequiv).\n      rewrite <- H0.(err_cequiv).\n      apply H1.(inf_crefine).\n  + split.\n    - rewrite H.(nrm_cequiv).\n      rewrite H0.(nrm_cequiv).\n      rewrite H0.(err_cequiv).\n      apply H1.(nrm_crefine).\n    - rewrite H.(err_cequiv).\n      rewrite H0.(err_cequiv).\n      apply H1.(err_crefine).\n    - rewrite H.(inf_cequiv).\n      rewrite H0.(inf_cequiv).\n      rewrite H0.(err_cequiv).\n      apply H1.(inf_crefine).\nQed.\n\n\n\n(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n\nLemma add_congr: forall (e11 e12 e21 e22: expr),\n    e11 ~=~ e12 ->\n    e21 ~=~ e22 ->\n    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\nProof.\n  intros.\n  split.\n  + simpl. admit.\n  + simpl.\nAbort.\n\n(** Normal 对应相同 *)\nLemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s i.\n  unfold arith_sem1_nrm.\n  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\n\n(** Error 对应相同 *)\nLemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s.\n  unfold arith_sem1_err.\n  apply or_iff_morphism.\n  + apply or_iff_morphism.\n    - apply H.(err_eequiv).\n    - apply H0.(err_eequiv).\n  + apply ex_iff_morphism; intros i1.\n    apply ex_iff_morphism; intros i2.\n    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n    reflexivity.\nQed.\n\nLemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold arith_sem1_nrm, arith_sem1_err.\n  intros [i1 [i2 [? [? ?] ] ] ].\n  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n  apply H0.(nrm_erefine) in H2.\n  sets_unfold in H1.\n  sets_unfold in H2.\n  destruct H1; [| tauto].\n  destruct H2; [| tauto].\n  left. (** 只剩下最后一种求值都成功的情况 *)\n  exists i1, i2.\n  tauto.\nQed.\n\n(**证明精化后出错变少*)\nLemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold arith_sem1_err.\n  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n  + apply H.(err_erefine) in H1.\n    tauto.\n  + apply H0.(err_erefine) in H1.\n    tauto.\n  + apply H.(nrm_erefine) in H1.\n    apply H0.(nrm_erefine) in H2.\n    sets_unfold in H1.\n    sets_unfold in H2.\n    destruct H1; [| tauto].\n    destruct H2; [| tauto].\n    right. (** 选择最右边的那一种 *)\n    exists i1, i2.\n    tauto.\nQed.\n\n(** 很多其它情况的证明是类似的。*)\n\nLemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s i.\n  unfold arith_sem2_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  unfold arith_sem2_err.\n  apply or_iff_morphism.\n  + apply or_iff_morphism.\n    - apply H.(err_eequiv).\n    - apply H0.(err_eequiv).\n  + apply ex_iff_morphism; intros i1.\n    apply ex_iff_morphism; intros i2.\n    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n    reflexivity.\nQed.\n\nLemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold arith_sem2_nrm, arith_sem2_err.\n  intros [i1 [i2 [? [? ?] ] ] ].\n  apply H.(nrm_erefine) in H1.\n  apply H0.(nrm_erefine) in H2.\n  sets_unfold in H1.\n  sets_unfold in H2.\n  destruct H1; [| tauto].\n  destruct H2; [| tauto].\n  left.\n  exists i1, i2.\n  tauto.\nQed.\n\nLemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold arith_sem2_err.\n  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n  + apply H.(err_erefine) in H1.\n    tauto.\n  + apply H0.(err_erefine) in H1.\n    tauto.\n  + apply H.(nrm_erefine) in H1.\n    apply H0.(nrm_erefine) in H2.\n    sets_unfold in H1.\n    sets_unfold in H2.\n    destruct H1; [| tauto].\n    destruct H2; [| tauto].\n    right.\n    exists i1, i2.\n    tauto.\nQed.\n\nLemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s i.\n  unfold cmp_sem_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  apply or_iff_morphism.\n  + apply H.(err_eequiv).\n  + apply H0.(err_eequiv).\nQed.\n\n(** comparison 本身不会出错 *)\nLemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold cmp_sem_nrm.\n  intros [i1 [i2 [? [? ?] ] ] ].\n  apply H.(nrm_erefine) in H1.\n  apply H0.(nrm_erefine) in H2.\n  sets_unfold in H1.\n  sets_unfold in H2.\n  destruct H1; [| tauto].\n  destruct H2; [| tauto].\n  left.\n  exists i1, i2.\n  tauto.\nQed.\n\nLemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  intros [? | ?].\n  + apply H.(err_erefine) in H1.\n    tauto.\n  + apply H0.(err_erefine) in H1.\n    tauto.\nQed.\n\n(** 短路求值，求值成功的情况  *)\nLemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s i.\n  unfold and_sem_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** 左半边*)\n  apply or_iff_morphism; [reflexivity |].\n  apply and_iff_morphism; [reflexivity |].\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  unfold and_sem_err.\n  apply or_iff_morphism; [apply H.(err_eequiv) |].\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n  reflexivity.\nQed.\n\nLemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold and_sem_nrm, and_sem_err.\n  intros [i1 ?].\n  destruct H1.\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  destruct H2; [left; exists i1; tauto |].\n  destruct H2 as [? [i2 [? ?] ] ].\n  apply H0.(nrm_erefine) in H3.\n  sets_unfold in H3.\n  destruct H3; [| right; right; exists i1; tauto].\n  left; exists i1.\n  split; [tauto |].\n  right.\n  split; [tauto |].\n  exists i2; tauto.\nQed.\n\nLemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold and_sem_err.\n  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n  destruct H1 as [i1 [? [? ?] ] ].\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  right; exists i1.\n  apply H0.(err_erefine) in H3.\n  tauto.\nQed.\n\nLemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s i.\n  unfold or_sem_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply or_iff_morphism; [reflexivity |].\n  apply and_iff_morphism; [reflexivity |].\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  unfold or_sem_err.\n  apply or_iff_morphism; [apply H.(err_eequiv) |].\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n  reflexivity.\nQed.\n\nLemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold or_sem_nrm, or_sem_err.\n  intros [i1 ?].\n  destruct H1.\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  destruct H2; [left; exists i1; tauto |].\n  destruct H2 as [? [i2 [? ?] ] ].\n  apply H0.(nrm_erefine) in H3.\n  sets_unfold in H3.\n  destruct H3; [| right; right; exists i1; tauto].\n  left; exists i1.\n  split; [tauto |].\n  right.\n  split; [tauto |].\n  exists i2; tauto.\nQed.\n\nLemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold or_sem_err.\n  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n  destruct H1 as [i1 [? [? ?] ] ].\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  right; exists i1.\n  apply H0.(err_erefine) in H3.\n  tauto.\nQed.\n\n(** 下面把二元运算的情况汇总起来。*)\n(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n\nInstance EBinop_congr: forall op,\n  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  (** 布尔二元运算的情况 *)\n  + split.\n    - apply or_sem_nrm_congr; tauto.\n    - apply or_sem_err_congr; tauto.\n  + split.\n    - apply and_sem_nrm_congr; tauto.\n    - apply and_sem_err_congr; tauto.\n  (** 大小比较的情况 *)\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  (** 加减乘运算的情况 *)\n  + split.\n    - apply arith_sem1_nrm_congr; tauto.\n    - apply arith_sem1_err_congr; tauto.\n  + split.\n    - apply arith_sem1_nrm_congr; tauto.\n    - apply arith_sem1_err_congr; tauto.\n  + split.\n    - apply arith_sem1_nrm_congr; tauto.\n    - apply arith_sem1_err_congr; tauto.\n  (** 除法与取余的情况 *)\n  + split.\n    - apply arith_sem2_nrm_congr; tauto.\n    - apply arith_sem2_err_congr; tauto.\n  + split.\n    - apply arith_sem2_nrm_congr; tauto.\n    - apply arith_sem2_err_congr; tauto.\nQed.\n\n(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\nInstance EBinop_mono: forall op,\n  Proper (erefine ==> erefine ==> erefine) (EBinop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  (** 布尔二元运算的情况 *)\n  + split.\n    - simpl.\n      apply (or_sem_nrm_mono x y x0 y0); tauto.\n    - apply or_sem_err_mono; tauto.\n  + split.\n    - apply and_sem_nrm_mono; tauto.\n    - apply and_sem_err_mono; tauto.\n  (** 大小比较的情况 *)\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  (** 加减乘运算的情况 *)\n  + split.\n    - apply arith_sem1_nrm_mono; tauto.\n    - apply arith_sem1_err_mono; tauto.\n  + split.\n    - apply arith_sem1_nrm_mono; tauto.\n    - apply arith_sem1_err_mono; tauto.\n  + split.\n    - apply arith_sem1_nrm_mono; tauto.\n    - apply arith_sem1_err_mono; tauto.\n  (** 除法与取余的情况 *)\n  + split.\n    - apply arith_sem2_nrm_mono; tauto.\n    - apply arith_sem2_err_mono; tauto.\n  + split.\n    - apply arith_sem2_nrm_mono; tauto.\n    - apply arith_sem2_err_mono; tauto.\nQed.\n\n(** 一元运算的情况是类似的。*)\n\nLemma not_sem_nrm_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n  not_sem_nrm ⟦ e2 ⟧.(nrm).\nProof.\n  unfold not_sem_nrm.\n  sets_unfold.\n  intros ? ? ? s i.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma not_sem_err_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\nProof.\n  intros.\n  apply H.(err_eequiv).\nQed.\n\nLemma not_sem_nrm_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\nProof.\n  unfold not_sem_nrm.\n  sets_unfold.\n  intros ? ? ? s i.\n  intros [i1 [? ?] ].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  left; exists i1.\n  tauto.\nQed.\n\nLemma not_sem_err_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\nProof.\n  intros.\n  apply H.(err_erefine).\nQed.\n\nLemma neg_sem_nrm_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n  neg_sem_nrm ⟦ e2 ⟧.(nrm).\nProof.\n  unfold neg_sem_nrm.\n  sets_unfold.\n  intros ? ? ? s i.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma neg_sem_err_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\nProof.\n  intros.\n  unfold neg_sem_err; sets_unfold.\n  intros s.\n  apply or_iff_morphism; [apply H.(err_eequiv) |].\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma neg_sem_nrm_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\nProof.\n  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n  intros ? ? ? s i.\n  intros [i1 [? ?] ].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  left; exists i1.\n  tauto.\nQed.\n\nLemma neg_sem_err_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\nProof.\n  unfold neg_sem_err; sets_unfold.\n  intros ? ? ? s ?.\n  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n  destruct H0 as [i1 [? ?] ].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  right; exists i1.\n  tauto.\nQed.\n\nInstance EUnop_congr: forall op, (** 一元运算符保持等价关系*)\n  Proper (eequiv ==> eequiv) (EUnop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  + split.\n    - apply not_sem_nrm_congr; tauto.\n    - simpl. apply not_sem_err_congr; tauto.\n  + split.\n    - apply neg_sem_nrm_congr; tauto.\n    - apply neg_sem_err_congr; tauto.\nQed.\n\nInstance EUnop_mono: forall op, (** 一元运算符保持精化关系*)\n  Proper (erefine ==> erefine) (EUnop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  + split.\n    - simpl. apply not_sem_nrm_mono; tauto.\n    - simpl. apply not_sem_err_mono; tauto.\n  + split.\n    - apply neg_sem_nrm_mono; tauto.\n    - apply neg_sem_err_mono; tauto.\nQed.\n\n(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n    性是比较显然的。*)\n\nInstance CSeq_congr:\n  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\nProof.\n  unfold Proper, respectful.\n  intros c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite H.(nrm_cequiv).\n    rewrite H0.(nrm_cequiv).\n    reflexivity.\n  + rewrite H.(nrm_cequiv).\n    rewrite H.(err_cequiv).\n    rewrite H0.(err_cequiv).\n    reflexivity.\n  + rewrite H.(nrm_cequiv).\n    rewrite H.(inf_cequiv).\n    rewrite H0.(inf_cequiv).\n    reflexivity.\nQed.\n\n(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n\nLemma Rels_times_full_concat2:\n  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n    (X × B) ∘ Y ⊆ X × C.\nProof.\n  intros.\n  sets_unfold.\n  intros a c.\n  intros [b [? ?] ].\n  tauto.\nQed.\n\nLemma Rels_times_full_concat1:\n  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n    (X × B) ∘ Y ⊆ X.\nProof.\n  intros.\n  sets_unfold.\n  intros a.\n  intros [b [? ?] ].\n  tauto.\nQed.\n\n(** 下面证明顺序执行能保持精化关系。*)\n\nInstance CSeq_mono:\n  Proper (crefine ==> crefine ==> crefine) CSeq.\nProof.\n  unfold Proper, respectful.\n  intros c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite H.(nrm_crefine).\n    rewrite H0.(nrm_crefine).\n    rewrite Rels_concat_union_distr_l.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_times_full_concat2. (**  ⟦ c12 ⟧.(err) × state ∘ ⟦ c22 ⟧.(err) × state) 属于  ⟦ c12 ⟧.(err) × state*)\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite H.(err_crefine). (**出错的情况*)\n    rewrite H.(nrm_crefine).\n    rewrite H0.(err_crefine).\n    rewrite Rels_concat_union_distr_r.\n    rewrite Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\n  + rewrite H.(inf_crefine). (**无穷的情况*)\n    rewrite H0.(inf_crefine).\n    rewrite H.(nrm_crefine).\n    rewrite Rels_concat_union_distr_l.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\nQed.\n\n(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n    _[test_false]_的性质。*)\n\nLemma test_true_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  test_true ⟦ e1 ⟧ ⊆\n  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\nProof.\n  intros.\n  unfold test_true; sets_unfold; intros s1 s2.\n  intros [ [i [? ?] ] ?].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  left; split; [| tauto].\n  exists i; tauto.\nQed.\n\nLemma test_false_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  test_false ⟦ e1 ⟧ ⊆\n  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\nProof.\n  intros.\n  unfold test_false; sets_unfold; intros s1 s2.\n  intros [? ?].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  tauto.\nQed.\n\nLemma test_true_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\nProof.\n  intros.\n  unfold test_true; sets_unfold; intros s1 s2.\n  apply and_iff_morphism; [| reflexivity].\n  apply ex_iff_morphism; intros i.\n  apply and_iff_morphism; [| reflexivity].\n  apply H.(nrm_eequiv).\nQed.\n\nLemma test_false_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\nProof.\n  intros.\n  unfold test_false; sets_unfold; intros s1 s2.\n  apply and_iff_morphism; [| reflexivity].\n  apply H.(nrm_eequiv).\nQed.\n\n(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n\nInstance CIf_congr:\n  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite (test_true_congr _ _ H).\n    rewrite (test_false_congr _ _ H).\n    rewrite H0.(nrm_cequiv).\n    rewrite H1.(nrm_cequiv).\n    reflexivity.\n  + rewrite (test_true_congr _ _ H).\n    rewrite (test_false_congr _ _ H).\n    rewrite H.(err_eequiv).\n    rewrite H0.(err_cequiv).\n    rewrite H1.(err_cequiv).\n    reflexivity.\n  + rewrite (test_true_congr _ _ H).\n    rewrite (test_false_congr _ _ H).\n    rewrite H0.(inf_cequiv).\n    rewrite H1.(inf_cequiv).\n    reflexivity.\nQed.\n\nInstance CIf_mono:\n  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite (test_true_mono e1 e2 H).\n    rewrite (test_false_mono e1 e2 H).\n    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat2.\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite (test_true_mono e1 e2 H).\n    rewrite (test_false_mono e1 e2 H).\n    rewrite H.(err_erefine).\n    rewrite H0.(err_crefine), H1.(err_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\n  + rewrite (test_true_mono e1 e2 H).\n    rewrite (test_false_mono e1 e2 H).\n    rewrite H0.(inf_crefine), H1.(inf_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\nQed.\n\n(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n    的次数进行归纳。*)\n\nInstance CWhile_congr:\n  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c1 c2 ?.\n  split; simpl.\n  (** 正常运行终止的情况。*)\n  + apply Sets_indexed_union_congr; intros n.\n    induction n; simpl.\n    - reflexivity.\n    - rewrite IHn.\n      rewrite (test_true_congr _ _ H).\n      rewrite (test_false_congr _ _ H).\n      rewrite H0.(nrm_cequiv).\n      reflexivity.\n  (** 运行出错的情况。*)\n  + apply Sets_indexed_union_congr; intros n.\n    induction n; simpl.\n    - reflexivity.\n    - rewrite IHn.\n      rewrite (test_true_congr _ _ H).\n      rewrite H.(err_eequiv).\n      rewrite H0.(nrm_cequiv).\n      rewrite H0.(err_cequiv).\n      reflexivity.\n  (** 运行不终止的情况。*)\n  + apply Sets_general_union_congr.\n    intros X.\n    unfold_CL_defs.\n    rewrite H0.(nrm_cequiv).\n    rewrite H0.(inf_cequiv).\n    rewrite (test_true_congr _ _ H).\n    reflexivity.\nQed.\n\n(** 要证明while语句保持精化关系就更复杂一些了。*)\n\nDefinition boundedLB_nrm\n             (D0: EDenote)\n             (D1: CDenote)\n             (n: nat):\n  state -> state -> Prop :=\n  Nat.iter\n    n\n    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n    ∅.\n\nDefinition boundedLB_err\n             (D0: EDenote)\n             (D1: CDenote)\n             (n: nat):\n  state -> Prop :=\n  Nat.iter\n    n\n    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n    ∅.\n\nDefinition is_inf\n             (D0: EDenote)\n             (D1: CDenote)\n             (X: state -> Prop): Prop :=\n  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n      test_true D0 ∘ D1.(inf).\n\nLemma boundedLB_nrm_mono_aux:\n  forall (e1 e2: expr) (c1 c2: com) n,\n    e1 <<= e2 ->\n    c1 <<= c2 ->\n    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\nProof.\n  intros.\n  induction n; simpl.\n  + apply Sets_empty_included.\n  + rewrite IHn.\n    rewrite (test_true_mono _ _ H).\n    rewrite (test_false_mono _ _ H).\n    rewrite H0.(nrm_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat2.\n    sets_unfold; intros s1 s2; tauto.\nQed.\n\nLemma boundedLB_err_mono_aux:\n  forall (e1 e2: expr) (c1 c2: com) n,\n    e1 <<= e2 ->\n    c1 <<= c2 ->\n    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\nProof.\n  intros.\n  induction n; simpl.\n  + apply Sets_empty_included.\n  + rewrite IHn.\n    rewrite (test_true_mono _ _ H).\n    rewrite H.(err_erefine).\n    rewrite H0.(nrm_crefine).\n    rewrite H0.(err_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\nQed.\n\nLemma Sets_complement_indexed_union:\n  forall {A I: Type} (Xs: I -> A -> Prop),\n    Sets.complement (⋃ Xs) ==\n    ⋂ (fun n => Sets.complement (Xs n)).\nProof.\n  intros.\n  sets_unfold.\n  split.\n  + apply not_ex_all_not.\n  + apply all_not_not_ex.\nQed.\n\nDefinition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n  Sets.complement (⋃ (boundedLB_err D1 D2)).\n\nLemma iter_err_fact:\n  forall (D1: EDenote) (D2: CDenote),\n    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n    ⋃ (boundedLB_err D1 D2).\nProof.\n  intros.\n  rewrite ! Rels_concat_indexed_union_distr_l.\n  apply Sets_indexed_union_included; intros n.\n  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n  simpl.\n  sets_unfold; intros s; tauto.\nQed.\n\nLemma Rels_concat_excluding_r:\n  forall\n    {A B: Type}\n    (R: A -> B -> Prop)\n    (S T: B -> Prop),\n    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n    R ∘ (S ∩ Sets.complement T).\nProof.\n  intros.\n  Sets_unfold; intros a.\n  intros [ [b [? ?] ] ?].\n  exists b.\n  split; [tauto |].\n  split; [tauto |].\n  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n  clear H1; intros.\n  exists b; tauto.\nQed.\n\nLemma noerrorLB_fact1:\n  forall (D1: EDenote) (D2: CDenote),\n    D1.(err) ∩ noerrorLB D1 D2 == ∅.\nProof.\n  intros.\n  unfold noerrorLB.\n  rewrite Sets_complement_indexed_union.\n  apply Sets_equiv_Sets_included.\n  split; [| apply Sets_empty_included].\n  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n  simpl.\n  sets_unfold; intros s.\n  tauto.\nQed.\n\nLemma noerrorLB_fact2:\n  forall (D1: EDenote) (D2: CDenote),\n    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\nProof.\n  intros.\n  unfold noerrorLB.\n  rewrite Sets_complement_indexed_union.\n  apply Sets_equiv_Sets_included.\n  split; [| apply Sets_empty_included].\n  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n  simpl.\n  sets_unfold; intros s.\n  tauto.\nQed.\n\nLemma inf_mono_aux:\n  forall (e1 e2: expr) (c1 c2: com) X,\n    e1 <<= e2 ->\n    c1 <<= c2 ->\n    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧). (**x集合中会执行while e2 do c2出错的情况排除*)\nProof.\n  unfold is_inf.\n  intros.\n  rewrite H1 at 1.\n  rewrite (test_true_mono _ _ H).\n  rewrite H0.(nrm_crefine).\n  rewrite H0.(inf_crefine).\n  rewrite ! Rels_concat_union_distr_r.\n  rewrite ! Rels_concat_union_distr_l.\n  rewrite ! Rels_times_full_concat1.\n  rewrite ! Sets_intersect_union_distr_r. (**交集对于bingji的分配律*)\n  rewrite noerrorLB_fact1.\n  rewrite noerrorLB_fact2.\n  rewrite ! Sets_union_empty.\n  unfold noerrorLB at 1.\n  rewrite <- iter_err_fact at 1.\n  rewrite ! Rels_concat_excluding_r.\n  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n  sets_unfold; intros s; tauto.\nQed.\n\nInstance CWhile_mono:\n  Proper (erefine ==> crefine ==> crefine) CWhile.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c1 c2 ?.\n  split; simpl.\n  + apply Sets_indexed_union_included; intros n. (**无穷并的每一项都是有*)\n    unfold BW_LFix. unfold_CPO_defs.\n    rewrite <- ! (Sets_included_indexed_union _ _ n).\n    apply boundedLB_nrm_mono_aux; tauto.\n  + apply Sets_indexed_union_included; intros n.\n    unfold BW_LFix. unfold_CPO_defs.\n    rewrite <- (Sets_included_indexed_union _ _ n).\n    apply boundedLB_err_mono_aux; tauto.\n  + apply Sets_general_union_included. unfold_CL_defs.\n    intros X ?.\n    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n    unfold KT_GFix; unfold_CL_defs.\n    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n      by (exact H2).\n    unfold noerrorLB.\n    sets_unfold; intros s; tauto.\nQed.\n\n(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n\nExample cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\nProof.\n  intros.\n  rewrite CSeq_assoc.\n  rewrite CIf_CSeq.\n  reflexivity.\nQed.\n\n"
        }
    ]
}