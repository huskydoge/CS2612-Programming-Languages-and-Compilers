{
    "sourceFile": "DenotationalSemantics.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1697022719826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1697022719826,
            "name": "Commit-0",
            "content": "Require Import Coq.Logic.Classical_Prop.\nRequire Import Coq.Strings.String.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Psatz.\nRequire Import SetsClass.SetsClass. Import SetsNotation.\nRequire Import PL.SyntaxInCoq.\nLocal Open Scope string.\nLocal Open Scope Z.\nLocal Open Scope sets.\n\n(** * 简单表达式的指称语义 *)\n\nModule DntSem_SimpleWhile1.\nImport Lang_SimpleWhile.\n\n\n\n(** 指称语义是一种定义程序行为的方式。在极简的SimpleWhile语言中，整数类型表达式\n    中只有整数常量、变量、加法、减法与乘法运算。  \n\n    我们约定其中整数变量的值、整数运算的结果都是没有范围限制的。基于这一约定，我\n    们可以如下定义表达式_[e]_在程序状态_[st]_上的值。\n\n    首先定义程序状态集合：*)\n\nDefinition state: Type := var_name -> Z.\n\n(** 下面使用Coq递归函数定义整数类型表达式的行为。*)\n\nFixpoint eval_expr_int (e: expr_int) (s: state) : Z :=\n  match e with\n  | EConst n => n\n  | EVar X => s X\n  | EAdd e1 e2 => eval_expr_int e1 s + eval_expr_int e2 s\n  | ESub e1 e2 => eval_expr_int e1 s - eval_expr_int e2 s\n  | EMul e1 e2 => eval_expr_int e1 s * eval_expr_int e2 s\n  end.\n\n(** 下面是两个具体的例子。*)\n\nExample eval_example1: forall (s: state),\n  s \"x\" = 1 ->\n  s \"y\" = 2 ->\n  eval_expr_int [[\"x\" + \"y\"]] s = 3.\nProof. intros. simpl. rewrite H, H0. reflexivity. Qed.\n\nExample eval_example2: forall (s: state),\n  s \"x\" = 1 ->\n  s \"y\" = 2 ->\n  eval_expr_int [[\"x\" * \"y\" + 1]] s = 3.\nProof. intros. simpl. rewrite H, H0. reflexivity. Qed.\n\n(** * 行为等价 *)\n\n(** 基于整数类型表达式的语义定义_[eval_expr_int]_，我们可以定义整数类型表达式之\n    间的行为等价（亦称语义等价）：两个表达式_[e1]_与_[e2]_是等价的当且仅当它们在\n    任何程序状态上的求值结果都相同。*)\n\nDefinition expr_int_equiv (e1 e2: expr_int): Prop :=\n  forall st, eval_expr_int e1 st = eval_expr_int e2 st.\n\nNotation \"e1 '~=~' e2\" := (expr_int_equiv e1 e2)\n  (at level 69, no associativity).\n\n(** 下面是一些表达式语义等价的例子。 *)\n\n\n\nExample expr_int_equiv_sample:\n  [[\"x\" + \"x\"]] ~=~ [[\"x\" * 2]].\nProof.\n  intros.\n  unfold expr_int_equiv.\n  (** 上面的_[unfold]_指令表示展开一项定义，一般用于非递归的定义。*)\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma zero_plus_equiv: forall (a: expr_int),\n  [[0 + a]] ~=~ a.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma plus_zero_equiv: forall (a: expr_int),\n  [[a + 0]] ~=~ a.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma minus_zero_equiv: forall (a: expr_int),\n  [[a - 0]] ~=~ a.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma zero_mult_equiv: forall (a: expr_int),\n  [[0 * a]] ~=~ 0.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma mult_zero_equiv: forall (a: expr_int),\n  [[a * 0]] ~=~ 0.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma const_plus_const: forall n m: Z,\n  [[EConst n + EConst m]] ~=~ EConst (n + m).\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\nLemma const_minus_const: forall n m: Z,\n  [[EConst n - EConst m]] ~=~ EConst (n - m).\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\nLemma const_mult_const: forall n m: Z,\n  [[EConst n * EConst m]] ~=~ EConst (n * m).\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\n(** 下面定义一种简单的语法变换---常量折叠---并证明其保持语义等价性。所谓常量折叠\n    指的是将只包含常量而不包含变量的表达式替换成为这个表达式的值。*)\n\nFixpoint fold_constants (e : expr_int) : expr_int :=\n  match e with\n  | EConst n    => EConst n\n  | EVar x      => EVar x\n  | EAdd e1 e2  =>\n      match fold_constants e1, fold_constants e2 with\n      | EConst n1, EConst n2 => EConst (n1 + n2)\n      | _, _ => EAdd (fold_constants e1) (fold_constants e2)\n      end\n  | ESub e1 e2 =>\n      match fold_constants e1, fold_constants e2 with\n      | EConst n1, EConst n2 => EConst (n1 - n2)\n      | _, _ => ESub (fold_constants e1) (fold_constants e2)\n    end\n  | EMul e1 e2 =>\n      match fold_constants e1, fold_constants e2 with\n      | EConst n1, EConst n2 => EConst (n1 * n2)\n      | _, _ => EMul (fold_constants e1) (fold_constants e2)\n    end\n  end.\n\n(** 这里我们可以看到，Coq中_[match]_的使用是非常灵活的。(1) 我们不仅可以对一个变\n    量的值做分类讨论，还可以对一个复杂的Coq式子的取值做分类讨论；(2) 我们可以对\n    多个值同时做分类讨论；(3) 我们可以用下划线表示_[match]_的缺省情况。下面是两\n    个例子：*)\n\nExample fold_constants_ex1:\n    fold_constants [[(1 + 2) * \"k\"]] = [[3 * \"k\"]].\nProof. intros. reflexivity. Qed.\n\n(** 注意，根据我们的定义，_[fold_constants]_并不会将_[0 + \"y\"]_中的_[0]_消去。*)\n\nExample fold_expr_int_ex2 :\n  fold_constants [[\"x\" - ((0 * 6) + \"y\")]] = [[\"x\" - (0 + \"y\")]].\nProof. intros. reflexivity. Qed.\n\n(** 下面我们在Coq中证明，_[fold_constants]_保持表达式行为不变。 *)\n\nTheorem fold_constants_sound : forall a,\n  fold_constants a ~=~ a.\nProof.\n  unfold expr_int_equiv. intros.\n  induction a.\n  (** 常量的情况 *)\n  + simpl.\n    reflexivity.\n  (** 变量的情况 *)\n  + simpl.\n    reflexivity.\n  (** 加号的情况 *)\n  + simpl.\n    destruct (fold_constants a1), (fold_constants a2);\n    rewrite <- IHa1, <- IHa2;\n    reflexivity.\n  (** 减号的情况 *)\n  + simpl.\n    destruct (fold_constants a1), (fold_constants a2);\n    rewrite <- IHa1, <- IHa2;\n    reflexivity.\n  (** 乘号的情况 *)\n  + simpl.\n    destruct (fold_constants a1), (fold_constants a2);\n    rewrite <- IHa1, <- IHa2;\n    reflexivity.\nQed.\n\nEnd DntSem_SimpleWhile1.\n\n(** * 利用高阶函数定义指称语义 *)\n\nModule DntSem_SimpleWhile2.\nImport Lang_SimpleWhile.\n\nDefinition state: Type := var_name -> Z.\n\nDefinition add_sem (D1 D2: state -> Z) (s: state): Z :=\n  D1 s + D2 s.\n\nDefinition sub_sem (D1 D2: state -> Z) (s: state): Z :=\n  D1 s - D2 s.\n\nDefinition mul_sem (D1 D2: state -> Z) (s: state): Z :=\n  D1 s * D2 s.\n\n(** 下面是用于类型查询的_[Check]_指令。*)\n\nCheck add_sem.\n\n(** 可以看到_[add_sem]_的类型是_[(state -> Z) -> (state -> Z) -> state -> Z]_，\n    这既可以被看做一个三元函数，也可以被看做一个二元函数，即函数之间的二元函数。  \n\n    基于上面高阶函数，可以重新定义表达式的指称语义。*)\n\nDefinition const_sem (n: Z) (s: state): Z := n.\nDefinition var_sem (X: var_name) (s: state): Z := s X.\n\nFixpoint eval_expr_int (e: expr_int): state -> Z :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      add_sem (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\nEnd DntSem_SimpleWhile2.\n\n(** * 布尔表达式语义 *)\n\nModule DntSem_SimpleWhile3.\nImport Lang_SimpleWhile DntSem_SimpleWhile2.\n\n(** 在Coq中可以如下定义：*)\n\nDefinition true_sem (s: state): bool := true.\n\nDefinition false_sem (s: state): bool := false.\n\nDefinition lt_sem (D1 D2: state -> Z) s: bool :=\n  Z.ltb (D1 s) (D2 s).\n\nDefinition and_sem (D1 D2: state -> bool) s: bool :=\n  andb (D1 s) (D2 s).\n\nDefinition not_sem (D: state -> bool) s: bool :=\n  negb (D s).\n\nFixpoint eval_expr_bool (e: expr_bool): state -> bool :=\n  match e with\n  | ETrue =>\n      true_sem\n  | EFalse =>\n      false_sem\n  | ELt e1 e2 =>\n      lt_sem (eval_expr_int e1) (eval_expr_int e2)\n  | EAnd e1 e2 =>\n      and_sem (eval_expr_bool e1) (eval_expr_bool e2)\n  | ENot e1 =>\n      not_sem (eval_expr_bool e1)\n  end.\n\nEnd DntSem_SimpleWhile3.\n\n(** * Coq中的集合与关系 *)\n\n\n(** 本课程提供的SetsClass库中提供了有关集合的一系列定义。例如：\n\n    - 空集：用 _[∅]_ 或者一堆方括号表示，定义为_[Sets.empty]_；\n\n    - 单元集：用一对方括号表示，定义为_[Sets.singleton]_；\n\n    - 并集：用_[∪]_表示，定义为_[Sets.union]_；\n\n    - 交集：用_[∩]_表示，定义为_[Sets.intersect]_；\n\n    - 一列集合的并：用_[⋃]_表示，定义为_[Sets.omega_union]_；\n\n    - 一列集合的交：用_[⋂]_表示，定义为_[Sets.omega_intersect]_；\n\n    - 集合相等：用_[==]_表示，定义为_[Sets.equiv]_；\n\n    - 元素与集合关系：用_[∈]_表示，定义为_[Sets.In]_；\n\n    - 子集关系：用_[⊆]_表示，定义为_[Sets.included]_；\n\n    - 二元关系的连接：用_[∘]_表示，定义为_[Rels.concat]_；\n\n    - 等同关系：定义为_[Rels.id]_；\n\n    - 测试关系：定义为_[Rels.test]_。\n\n    在CoqIDE中，你可以利用CoqIDE对于unicode的支持打出特殊字符：\n\n    - 首先，在打出特殊字符的latex表示法；\n\n    - 再按shift+空格键；\n\n    - latex表示法就自动转化为了相应的特殊字符。\n\n    例如，如果你需要打出符号_[∈]_，请先在输入框中输入_[\\in]_，当光标紧跟在_[n]_\n    这个字符之后的时候，按shift+空格键即可。例如，下面是两个关于集合的命题：*)\n\nCheck forall A (X: A -> Prop), X ∪ ∅ == X.\n\nCheck forall A B (X Y: A -> B -> Prop), X ∪ Y ⊆ X.\n\n(** 由于集合以及集合间的运算是基于Coq中的命题进行定义的，集合相关性质的证明也可\n    以规约为与命题有关的逻辑证明。例如，我们想要证明，交集运算具有交换律：*)\n\nLemma Sets_intersect_comm: forall A (X Y: A -> Prop),\n  X ∩ Y == Y ∩ X.\nProof.\n  intros.\n  (** 下面一条命令_[sets_unfold]_是SetsClass库提供的自动证明指令，它可以将有关\n      集合的性质转化为有关命题的性质。*)\n  sets_unfold.\n  (** 原本要证明的关于交集的性质现在就转化为了：\n        _[forall a : A, X a /\\ Y a <-> Y a /\\ X a]_\n      其中_[forall]_就是逻辑中『任意』的意思；_[/\\]_之前我们已经了解，它表示『并\n      且』的意思；_[<->]_表示『当且仅当』的意思；_[X a]_可以念做性质_[X]_对于\n      _[a]_成立，也可以理解为_[a]_是集合_[X]_的元素。\n\n      我们稍后再来完成相关性质的证明。在Coq中，要放弃当前的证明，可以用下面的\n      _[Abort]_指令。*)\nAbort.\n\n(** 下面是一条关于并集运算的性质。*)\n\nLemma Sets_included_union1: forall A (X Y: A -> Prop),\n  X ⊆ X ∪ Y.\nProof.\n  intros.\n  sets_unfold.\n  (** 经过转化，要证明的结论是：_[forall a : A, X a -> X a \\/ Y a]_。这里，\n      _[\\/]_表示『或者』；_[->]_表示推出，也可以念做『如果...那么...』。*)\nAbort.\n\n(** 下面是一条关于二元运算的性质。*)\n\nLemma Rels_concat_assoc: forall A (X Y Z: A -> A -> Prop),\n  (X ∘ Y) ∘ Z == X ∘ (Y ∘ Z).\nProof.\n  intros.\n  rels_unfold.\n  (** 关于二元关系的性质，要使用_[rels_unfold]_展开成为基于逻辑的定义。*)\nAbort.\n\n(** SetsClass库中提供了一系列有关集合运算的性质的证明。未来大家在证明中既可以使\n    用_[sets_unfold]_与_[rels_unfold]_将关于集合运算的命题转化为关于逻辑的命题，\n    也可以直接使用下面这些性质完成证明。  \n\n      Sets_equiv_Sets_included:\n    forall x y, x == y <-> x ⊆ y /\\ y ⊆ x;\n  Sets_empty_included:\n    forall x, ∅ ⊆ x;\n  Sets_included_full:\n    forall x, x ⊆ Sets.full;\n  Sets_intersect_included1:\n    forall x y, x ∩ y ⊆ x;\n  Sets_intersect_included2:\n    forall x y, x ∩ y ⊆ y;\n  Sets_included_intersect:\n    forall x y z, x ⊆ y -> x ⊆ z -> x ⊆ y ∩ z;\n  Sets_included_union1:\n    forall x y, x ⊆ x ∪ y;\n  Sets_included_union2:\n    forall x y, y ⊆ x ∪ y;\n  Sets_union_included_strong2:\n    forall x y z u,\n       x ∩ u ⊆ z -> y ∩ u ⊆ z -> (x ∪ y) ∩ u ⊆ z;\n  \n      Sets_included_omega_union:\n    forall xs n, xs n ⊆ ⋃ xs;  挑一个n第n个是子集\n  Sets_omega_union_included:\n    forall xs y, (forall n, xs n ⊆ y) -> ⋃ xs ⊆ y;\n  Sets_omega_intersect_included:\n    forall xs n, ⋂ xs ⊆ xs n;\n  Sets_included_omega_intersect:\n    forall xs y, (forall n : nat, y ⊆ xs n) -> y ⊆ ⋂ xs;\n  \n      Rels_concat_union_distr_r:\n    forall x1 x2 y,\n      (x1 ∪ x2) ∘ y == (x1 ∘ y) ∪ (x2 ∘ y);  如果变成一列的并，也会有这个性质。\n  Rels_concat_union_distr_l:\n    forall x y1 y2,\n      x ∘ (y1 ∪ y2) == (x ∘ y1) ∪ (x ∘ y2);\n  Rels_concat_mono:\n    forall x1 x2,\n      x1 ⊆ x2 ->\n      forall y1 y2,\n        y1 ⊆ y2 ->\n        x1 ∘ y1 ⊆ x2 ∘ y2;\n  Rels_concat_assoc:\n    forall x y z,\n      (x ∘ y) ∘ z == x ∘ (y ∘ z);\n*)\n\n\n(** * 在Coq中定义程序语句的语义 *)\n\nModule DntSem_SimpleWhile4.\nImport Lang_SimpleWhile\n       DntSem_SimpleWhile2\n       DntSem_SimpleWhile3.\n\n(** 下面在Coq中写出程序语句的指称语义。*)\n\nDefinition skip_sem: state -> state -> Prop :=\n  Rels.id.\n\nDefinition asgn_sem\n             (X: var_name)\n             (D: state -> Z)\n             (st1 st2: state): Prop :=\n  st2 X = D st1 /\\\n  forall Y, X <> Y -> st2 Y = st1 Y.\n\nDefinition seq_sem\n             (D1 D2: state -> state -> Prop):\n  state -> state -> Prop :=\n  D1 ∘ D2.\n\nDefinition test_true\n             (D: state -> bool):\n  state -> state -> Prop :=\n  Rels.test (fun st => D st = true).\n\nDefinition test_false\n             (D: state -> bool):\n  state -> state -> Prop :=\n  Rels.test (fun st => D st = false).\n\nDefinition if_sem\n             (D0: state -> bool)\n             (D1 D2: state -> state -> Prop):\n  state -> state -> Prop :=\n  (test_true D0 ∘ D1) ∪ (test_false D0 ∘ D2).\n\nFixpoint iter_n\n           (D0: state -> bool)\n           (D1: state -> state -> Prop)\n           (n: nat):\n  state -> state -> Prop :=\n  match n with\n  | O => test_false D0\n  | S n0 => test_true D0 ∘ D1 ∘ iter_n D0 D1 n0\n  end.\n\nModule WhileSem1.\n\nDefinition while_sem\n             (D0: state -> bool)\n             (D1: state -> state -> Prop):\n  state -> state -> Prop :=\n  ⋃ (iter_n D0 D1).\n\nEnd WhileSem1.\n\nFixpoint iter_lt_n\n           (D0: state -> bool)\n           (D1: state -> state -> Prop)\n           (n: nat):\n  state -> state -> Prop :=\n  match n with\n  | O => ∅\n  | S n0 =>\n      (test_true D0 ∘ D1 ∘ iter_lt_n D0 D1 n0) ∪\n      (test_false D0)\n  end.\n\nModule WhileSem2.\n\nDefinition while_sem\n             (D0: state -> bool)\n             (D1: state -> state -> Prop):\n  state -> state -> Prop :=\n  ⋃ (iter_lt_n D0 D1).\n\nEnd WhileSem2.\n\n(** 我们选择第一种定义。*)\n\nExport WhileSem1.\n\n(** 下面是程序语句指称语义的递归定义。*)\n\nFixpoint eval_com (c: com): state -> state -> Prop :=\n  match c with\n  | CSkip =>\n      skip_sem\n  | CAsgn X e =>\n      asgn_sem X (eval_expr_int e)\n  | CSeq c1 c2 =>\n      seq_sem (eval_com c1) (eval_com c2)\n  | CIf e c1 c2 =>\n      if_sem (eval_expr_bool e) (eval_com c1) (eval_com c2)\n  | CWhile e c1 =>\n      while_sem (eval_expr_bool e) (eval_com c1)\n  end.\n\n\n\n\n\nEnd DntSem_SimpleWhile4.\n\n"
        }
    ]
}