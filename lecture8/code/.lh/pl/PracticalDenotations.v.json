{
    "sourceFile": "pl/PracticalDenotations.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1700546317121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1700546341757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1087 @@\n+Require Import Coq.micromega.Psatz.\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.Strings.String.\n+Require Import Coq.Classes.Morphisms.\n+Require Import SetsClass.SetsClass. Import SetsNotation.\n+Require Import compcert.lib.Integers.\n+Require Import PL.SyntaxInCoq.\n+Require Import PL.DenotationalSemantics.\n+Local Open Scope bool.\n+Local Open Scope string.\n+Local Open Scope Z.\n+Local Open Scope sets.\n+\n+(** * 表示64位整数运算的整数表达式语义 *)\n+\n+Module DntSem_SimpleWhile6.\n+Import Lang_SimpleWhile.\n+\n+\n+(** 程序状态的修改：  \n+\n+    Coq定义：*)\n+\n+Definition state: Type := var_name -> int64.\n+\n+(** 这里_[int64]_是CompCert库中定义的64位整数，该定义是_[compcert.lib.Integers]_\n+    这一头文件导入的。除了_[int64]_的类型定义，CompCert还定义了64位整数的运算并\n+    证明相关运算的一些基本性质，例如_[Int64.add]_表示64位算术加法，_[Int64.and]_\n+    表示按位做『与』运算。  \n+\n+\n+\n+    除了上述表达算术运算、位运算的函数外，还有3个64位整数相关的函数十分常用，分\n+    别是：_[Int64.repr]_, _[Int64.signed]_, _[Int64.unsigned]_。另外，下面几个常\n+    数定义了有符号64位整数与无符号64位整数的大小边界：_[Int64.max_unsigned]_,\n+    _[Int64.max_signed]_, _[Int64.min_signed]_。  \n+\n+    除了修改程序状态的定义，还需要相应修改程序证整数类型表达式的语义。在Coq中，\n+    _[eval_expr_int e]_的类型就需要改为_[state -> int64]_。*)\n+\n+Definition add_sem (D1 D2: state -> int64) s: int64 :=\n+  Int64.add (D1 s) (D2 s).\n+\n+Definition sub_sem (D1 D2: state -> int64) s: int64 :=\n+  Int64.sub (D1 s) (D2 s).\n+\n+Definition mul_sem (D1 D2: state -> int64) s: int64 :=\n+  Int64.mul (D1 s) (D2 s).\n+\n+Definition const_sem (n: Z) (s: state): int64 :=\n+  Int64.repr n.\n+\n+Definition var_sem (X: var_name) (s: state): int64 :=\n+  s X.\n+\n+Fixpoint eval_expr_int (e: expr_int) : state -> int64 :=\n+  match e with\n+  | EConst n =>\n+      const_sem n\n+  | EVar X =>\n+      var_sem X\n+  | EAdd e1 e2 =>\n+      add_sem (eval_expr_int e1) (eval_expr_int e2)\n+  | ESub e1 e2 =>\n+      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n+  | EMul e1 e2 =>\n+      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n+  end.\n+\n+\n+End DntSem_SimpleWhile6.\n+\n+(** * 将运算越界定义为表达式求值错误 - 用部分函数 *)\n+\n+Module DntSem_SimpleWhile7.\n+Import Lang_SimpleWhile.\n+\n+Definition state: Type := var_name -> int64.\n+\n+Ltac int64_lia :=\n+  change Int64.min_signed with (-9223372036854775808) in *;\n+  change Int64.max_signed with 9223372036854775807 in *;\n+  lia.\n+\n+\n+(** 在讲解并实现简单解释器之前，我们曾经约定while语言的算术运算语义基本遵循C标准\n+    的规定。特别的，有符号64位整数的运算越界应当被视为程序错误（C11标准6.5章节第\n+    5段落）。然而，这一点并未在上面定义中得到体现。  \n+\n+    为了解决这一问题，我们需要能够在定义中表达『程序表达式求值出错』这一概念。这\n+    在数学上有两种常见方案。其一是将求值结果由64位整数集合改为64位整数或求值失\n+    败。  \n+\n+\n+\n+    在Coq中可以使用_[option]_类型描述相关概念。*)\n+\n+\n+Print option.\n+\n+(** 具体而言，对于任意Coq类型_[A]_，_[option A]_的元素要么是_[Some a]_（其中\n+    _[a]_是_[A]_的元素）要么是_[None]_。可以看到_[option]_也是一个Coq归纳类型，\n+    只不过其定义中并不需要对自身归纳。我们可以像处理先前其他归纳类型一样使用Coq\n+    中的_[match]_定义相关的函数或性质，例如：*)\n+\n+Definition option_plus1 (o: option Z): option Z :=\n+  match o with\n+  | Some x => Some (x + 1)\n+  | None => None\n+  end.\n+\n+(** 例如上面这一定义说的是：如果_[o]_的值是_[None]_那么就返回_[None]_，如果_[o]_\n+    的值是某个整数（_[Some]_的情况），那就将它加一返回。  \n+\n+    利用类似_[option]_类型可以改写表达式的语义定义。*)\n+\n+Definition const_sem (n: Z) (s: state): option int64 :=\n+  if (n <=? Int64.max_signed) && (n >=? Int64.min_signed)\n+  then Some (Int64.repr n)\n+  else None.\n+\n+Definition var_sem (x: var_name) (s: state): option int64 :=\n+  Some (s x).\n+\n+Definition add_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n+  match D1 s, D2 s with\n+  | Some i1, Some i2 =>\n+      if (Int64.signed i1 + Int64.signed i2 <=? Int64.max_signed) &&\n+         (Int64.signed i1 + Int64.signed i2 >=? Int64.min_signed)\n+      then Some (Int64.add i1 i2)\n+      else None\n+  | _, _ => None\n+  end.\n+\n+Definition sub_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n+  match D1 s, D2 s with\n+  | Some i1, Some i2 =>\n+      if (Int64.signed i1 - Int64.signed i2 <=? Int64.max_signed) &&\n+         (Int64.signed i1 - Int64.signed i2 >=? Int64.min_signed)\n+      then Some (Int64.sub i1 i2)\n+      else None\n+  | _, _ => None\n+  end.\n+\n+Definition mul_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n+  match D1 s, D2 s with\n+  | Some i1, Some i2 =>\n+      if (Int64.signed i1 * Int64.signed i2 <=? Int64.max_signed) &&\n+         (Int64.signed i1 * Int64.signed i2 >=? Int64.min_signed)\n+      then Some (Int64.mul i1 i2)\n+      else None\n+  | _, _ => None\n+  end.\n+\n+(** 最终，整数类型表达式的语义可以归结为下面递归定义。*)\n+\n+Fixpoint eval_expr_int (e: expr_int): state -> option int64 :=\n+  match e with\n+  | EConst n =>\n+      const_sem n\n+  | EVar X =>\n+      var_sem X\n+  | EAdd e1 e2 =>\n+      add_sem (eval_expr_int e1) (eval_expr_int e2)\n+  | ESub e1 e2 =>\n+      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n+  | EMul e1 e2 =>\n+      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n+  end.\n+\n+(** 上述定义中除了用到Coq的_[option]_类型，还用到了Coq的_[bool]_类型。*)\n+\n+Print bool.\n+\n+(** 根据定义_[bool]_类型只有两种可能的取值：_[true]_与_[false]_。请注意，Coq中的\n+    _[bool]_类型与命题（_[Prop]_类型）并不相同，前者专门用于关于真与假的真值运\n+    算，而后者则可以描述关于任意、存在等真假难以判定、无法计算真值的命题。上面的\n+    _[eval_expr_int]_定义要用于计算出_[option int64]_类型的结果，因此就只能使用\n+    _[bool]_类型的Coq函数来做判定了，他们分别是_[<=?]_, _[>=?]_与_[&&]_。*)\n+\n+Check 1 <=? 2.\n+Check 1 <= 2.\n+\n+(** 可以看到，_[1 <=? 2]_是用_[bool]_类型表达的判断两数大小的结果，这一符号对应\n+    的定义是：_[Z.leb 1 2]_。而_[1 <= 2]_则是关于两数大小关系的命题，这一符号对\n+    应的定义是：_[Z.le 1 2]_。Coq标准库中也证明了两者的联系。*)\n+\n+Check Z.leb_le.\n+\n+(** 这个定理说的是：_[forall n m : Z, (n <=? m) = true <-> n <= m]_。当然，Coq标\n+    准库中还有很多类似的有用的性质，这里就不再一一罗列了，相关信息也可以通过\n+    _[Search Z.leb]_或_[Search Z.le]_等方法查找。  \n+\n+    最后，在Coq中，可以用_[&&]_表示布尔值的合取（Coq定义是_[andb]_）并且使用\n+    _[if]_，_[then]_，_[else]_针对布尔表达式求值为真以及为假的情况分别采取不同的\n+    求值方法。将这些定义组合在一起，就得到了上面的_[eval_expr_int]_定义。  \n+\n+    下面是一些证明自动化指令（可以跳过）。*)\n+\n+Ltac int64_arith_simpl :=\n+  repeat\n+  match goal with\n+  | |- context [if ?X then Some ?A else None] =>\n+         match X with\n+         | context [?A <=? ?B] =>\n+            first\n+            [ assert (A <= B) as HHH by int64_lia;\n+              apply Z.leb_le in HHH;\n+              rewrite HHH; clear HHH]\n+         | context [?A >=? ?B] =>\n+            first\n+            [ assert (B <= A) as HHH by int64_lia;\n+              apply Z.geb_le in HHH;\n+              rewrite HHH; clear HHH]\n+         | context [true && ?b] => change (true && b) with b\n+         | context [false && ?b] => change (false && b) with false\n+         end\n+  | |- context [if true then ?A else ?B] =>\n+         change (if true then A else B) with A\n+  | |- context [if false then ?A else ?B] =>\n+         change (if false then A else B) with B\n+  | |- context [match Some ?A with | Some _ => _ | None => _ end] =>\n+         cbv beta iota\n+  | |- context [Int64.signed (Int64.repr ?n)] =>\n+         rewrite (Int64.signed_repr n) by int64_lia\n+  end.\n+\n+(** 我们可以在Coq中证明一些关于表达式指称语义的基本性质。*)\n+\n+Example eval_expr_int_fact0: forall st,\n+  st \"x\" = Int64.repr 0 ->\n+  eval_expr_int [[\"x\" + 1]] st = Some (Int64.repr 1).\n+Proof.\n+  intros.\n+  simpl.\n+  unfold add_sem, var_sem, const_sem.\n+  rewrite H.\n+  int64_arith_simpl.\n+  reflexivity.\n+Qed.\n+\n+\n+End DntSem_SimpleWhile7.\n+\n+Module DntSem_SimpleWhile8.\n+Import Lang_SimpleWhile\n+       DntSem_SimpleWhile7.\n+\n+\n+(** 上面定义中有三个分支的定义是相似，我们也可以统一定义。  \n+\n+    这里，_[Zfun: Z -> Z -> Z]_可以看做对整数加法（_[Z.add]_)、整数减法\n+    （_[Z.sub]_）与整数乘法（_[Z.mul]_）的抽象。而\n+     _[i64fun: int64 -> int64 -> int64]_可以看做对64位整数二元运算的抽象。*)\n+\n+Definition arith_sem\n+             (Zfun: Z -> Z -> Z)\n+             (int64fun: int64 -> int64 -> int64)\n+             (D1 D2: state -> option int64)\n+             (s: state): option int64 :=\n+  match D1 s, D2 s with\n+  | Some i1, Some i2 =>\n+      if (Zfun (Int64.signed i1) (Int64.signed i2)\n+                               <=? Int64.max_signed) &&\n+         (Zfun (Int64.signed i1) (Int64.signed i2)\n+                               >=? Int64.min_signed)\n+      then Some (int64fun i1 i2)\n+      else None\n+  | _, _ => None\n+  end.\n+\n+(** 例如，下面将_[Zfun]_取_[Z.add]_、_[int64fun]_取_[Int64.add]_代入：*)\n+\n+Example arith_sem_add_fact: forall D1 D2 s,\n+  arith_sem Z.add Int64.add D1 D2 s =\n+  match D1 s, D2 s with\n+  | Some i1, Some i2 =>\n+      if (Int64.signed i1 + Int64.signed i2\n+                               <=? Int64.max_signed) &&\n+         (Int64.signed i1 + Int64.signed i2\n+                               >=? Int64.min_signed)\n+      then Some (Int64.add i1 i2)\n+      else None\n+  | _, _ => None\n+  end.\n+Proof. intros. reflexivity. Qed.\n+\n+(** 这样，_[eval_expr_int]_的定义就可以简化为：*)\n+\n+Fixpoint eval_expr_int (e: expr_int):\n+  state -> option int64 :=\n+  match e with\n+  | EConst n =>\n+      const_sem n\n+  | EVar X =>\n+      var_sem X\n+  | EAdd e1 e2 =>\n+      arith_sem Z.add Int64.add\n+        (eval_expr_int e1) (eval_expr_int e2)\n+  | ESub e1 e2 =>\n+      arith_sem Z.sub Int64.sub\n+        (eval_expr_int e1) (eval_expr_int e2)\n+  | EMul e1 e2 =>\n+      arith_sem Z.mul Int64.mul\n+        (eval_expr_int e1) (eval_expr_int e2)\n+  end.\n+\n+\n+End DntSem_SimpleWhile8.\n+\n+(** * 将运算越界定义为表达式求值错误 - 用二元关系 *)\n+\n+(** 上面我们讨论了将表达式语义定义为程序状态到_[option int64]_的函数这一方案。下\n+    面我们探讨另一种描述程序运行出错或未定义行为的方案，即将表达式的语义定义为程\n+    序状态与_[int64]_之间的二元关系。  \n+\n+\n+    下面给出相应的Coq定义。首先定义64位整数之间在有符号64位整数范围内的运算关系。*)\n+\n+Definition arith_compute1_nrm\n+             (Zfun: Z -> Z -> Z)\n+             (i1 i2 i: int64): Prop :=\n+  let res := Zfun (Int64.signed i1) (Int64.signed i2) in\n+    i = Int64.repr res /\\\n+    Int64.min_signed <= res <= Int64.max_signed.\n+\n+Definition arith_compute1_err\n+             (Zfun: Z -> Z -> Z)\n+             (i1 i2: int64): Prop :=\n+  let res := Zfun (Int64.signed i1) (Int64.signed i2) in\n+    res < Int64.min_signed \\/ res > Int64.max_signed.\n+\n+Module DntSem_SimpleWhile9.\n+Import Lang_SimpleWhile.\n+\n+(** 接下去利用表达式与64位整数值间的二元关系表达『程序表达式求值出错』这一概念。\n+    具体而言，如果表达式_[e]_在程序状态_[s]_上能成果求值且求值结果为_[i]_，那么\n+    _[s]_与_[i]_这个有序对就在_[e]_的语义中。*)\n+\n+Definition state: Type := var_name -> int64.\n+\n+\n+(** 下面定义统一刻画了三种算术运算的语义。*)\n+\n+Definition arith_sem1_nrm\n+             (Zfun: Z -> Z -> Z)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute1_nrm Zfun i1 i2 i.\n+\n+Definition arith_sem1_err\n+             (Zfun: Z -> Z -> Z)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute1_err Zfun i1 i2.\n+\n+(** 一个表达式的语义分为两部分：求值成功的情况与求值出错的情况。*)\n+\n+Record denote: Type := {\n+  nrm: state -> int64 -> Prop;\n+  err: state -> Prop;\n+}.\n+\n+(** 下面_[Notation]_定义用于提供便捷易懂的表示方法，可以忽略其中的声明细节。*)\n+\n+Notation \"x '.(nrm)'\" := (nrm x) (at level 1).\n+Notation \"x '.(err)'\" := (err x) (at level 1).\n+\n+\n+(** Coq中的_[Record]_与许多程序语言中的结构体是类似的。在上面定义中，每个表达式\n+    的语义_[D: denote]_都有两个域：_[D.(nrm)]_与_[D.(err)]_分别描述前面提到的两\n+    种情况。*)\n+\n+Definition arith_sem1 Zfun (D1 D2: denote): denote :=\n+  {|\n+    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ D2.(err) ∪\n+           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n+  |}.\n+\n+Definition const_sem (n: Z): denote :=\n+  {|\n+    nrm := fun s i =>\n+             i = Int64.repr n /\\\n+             Int64.min_signed <= n <= Int64.max_signed;\n+    err := fun s =>\n+             n < Int64.min_signed \\/\n+             n > Int64.max_signed;\n+  |}.\n+\n+Definition var_sem (X: var_name): denote :=\n+  {|\n+    nrm := fun s i => i = s X;\n+    err := ∅;\n+  |}.\n+\n+(** 最终，整数类型表达式的语义可以归结为下面递归定义。*)\n+\n+Fixpoint eval_expr_int (e: expr_int): denote :=\n+  match e with\n+  | EConst n =>\n+      const_sem n\n+  | EVar X =>\n+      var_sem X\n+  | EAdd e1 e2 =>\n+      arith_sem1 Z.add (eval_expr_int e1) (eval_expr_int e2)\n+  | ESub e1 e2 =>\n+      arith_sem1 Z.sub (eval_expr_int e1) (eval_expr_int e2)\n+  | EMul e1 e2 =>\n+      arith_sem1 Z.mul (eval_expr_int e1) (eval_expr_int e2)\n+  end.\n+\n+\n+\n+End DntSem_SimpleWhile9.\n+\n+(** * 未初始化的变量 *)\n+\n+(** 在C语言和很多实际编程语言中，都不允许或不建议在运算中或赋值中使用未初始化的\n+    变量的值。若要根据这一设定定义程序语义，那么就需要修改程序状态的定义。变量的\n+    值可能是一个64位整数，也可能是未初始化。*)\n+\n+Inductive val: Type :=\n+| Vuninit: val\n+| Vint (i: int64): val.\n+\n+Module DntSem_SimpleWhile10.\n+Import Lang_SimpleWhile.\n+\n+(** 程序状态就变成变量名到_[val]_的函数。*)\n+\n+Definition state: Type := var_name -> val.\n+\n+(** 表达式的指称依旧包含原有的两部分。*)\n+\n+Record denote: Type := {\n+  nrm: state -> int64 -> Prop;\n+  err: state -> Prop;\n+}.\n+\n+Notation \"x '.(nrm)'\" := (nrm x) (at level 1).\n+Notation \"x '.(err)'\" := (err x) (at level 1).\n+\n+(** 下面这些Coq定义也不变。*)\n+\n+Definition arith_sem1_nrm\n+             (Zfun: Z -> Z -> Z)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute1_nrm Zfun i1 i2 i.\n+\n+Definition arith_sem1_err\n+             (Zfun: Z -> Z -> Z)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute1_err Zfun i1 i2.\n+\n+Definition arith_sem1 Zfun (D1 D2: denote): denote :=\n+  {|\n+    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ D2.(err) ∪\n+           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n+  |}.\n+\n+Definition const_sem (n: Z): denote :=\n+  {|\n+    nrm := fun s i =>\n+             i = Int64.repr n /\\\n+             Int64.min_signed <= n <= Int64.max_signed;\n+    err := fun s =>\n+             n < Int64.min_signed \\/\n+             n > Int64.max_signed;\n+  |}.\n+\n+(** 唯有整数类型表达式中变量的语义需要重新定义。*)\n+\n+Definition var_sem (X: var_name): denote :=\n+  {|\n+    nrm := fun s i => s X = Vint i;\n+    err := fun s => s X = Vuninit;\n+  |}.\n+\n+(** 最终，整数类型表达式的语义还是可以写成同样的递归定义。*)\n+\n+Fixpoint eval_expr_int (e: expr_int): denote :=\n+  match e with\n+  | EConst n =>\n+      const_sem n\n+  | EVar X =>\n+      var_sem X\n+  | EAdd e1 e2 =>\n+      arith_sem1 Z.add (eval_expr_int e1) (eval_expr_int e2)\n+  | ESub e1 e2 =>\n+      arith_sem1 Z.sub (eval_expr_int e1) (eval_expr_int e2)\n+  | EMul e1 e2 =>\n+      arith_sem1 Z.mul (eval_expr_int e1) (eval_expr_int e2)\n+  end.\n+\n+End DntSem_SimpleWhile10.\n+\n+(** * While语言的语义 *)\n+\n+(** 有了上面这些准备工作，我们可以定义完整While语言的语义。完整While语言中支持更\n+    多运算符，要描述除法和取余运算符的行为，要定义不同于加减乘的运算关系。下面定\n+    义参考了C标准对于有符号整数除法和取余的规定。*)\n+\n+Definition arith_compute2_nrm\n+             (int64fun: int64 -> int64 -> int64)\n+             (i1 i2 i: int64): Prop :=\n+  i = int64fun i1 i2 /\\\n+  Int64.signed i2 <> 0 /\\\n+  (Int64.signed i1 <> Int64.min_signed \\/\n+   Int64.signed i2 <> - 1).\n+\n+Definition arith_compute2_err (i1 i2: int64): Prop :=\n+  Int64.signed i2 = 0 \\/\n+  (Int64.signed i1 = Int64.min_signed /\\\n+   Int64.signed i2 = - 1).\n+\n+(** 下面定义的比较运算关系利用了CompCert库定义的_[comparison]_类型和_[Int64.cmp]_\n+    函数。*)\n+\n+Definition cmp_compute_nrm\n+             (c: comparison)\n+             (i1 i2 i: int64): Prop :=\n+  i = if Int64.cmp c i1 i2\n+      then Int64.repr 1\n+      else Int64.repr 0.\n+\n+(** 一元运算的行为比较容易定义：*)\n+\n+Definition neg_compute_nrm (i1 i: int64): Prop :=\n+  i = Int64.neg i1 /\\\n+  Int64.signed i1 <> Int64.min_signed.\n+\n+Definition neg_compute_err (i1: int64): Prop :=\n+  Int64.signed i1 = Int64.min_signed.\n+\n+Definition not_compute_nrm (i1 i: int64): Prop :=\n+  Int64.signed i1 <> 0 /\\ i = Int64.repr 0 \\/\n+  i1 = Int64.repr 0 /\\ i = Int64.repr 1.\n+\n+(** 最后，二元布尔运算的行为需要考虑短路求值的情况。下面定义中的缩写_[SC]_表示\n+    short circuit。*)\n+\n+Definition SC_and_compute_nrm (i1 i: int64): Prop :=\n+  i1 = Int64.repr 0 /\\ i = Int64.repr 0.\n+\n+Definition SC_or_compute_nrm (i1 i: int64): Prop :=\n+  Int64.signed i1 <> 0 /\\ i = Int64.repr 1.\n+\n+Definition NonSC_and (i1: int64): Prop :=\n+  Int64.signed i1 <> 0.\n+\n+Definition NonSC_or (i1: int64): Prop :=\n+  i1 = Int64.repr 0.\n+\n+Definition NonSC_compute_nrm (i2 i: int64): Prop :=\n+  i2 = Int64.repr 0 /\\ i = Int64.repr 0 \\/\n+  Int64.signed i2 <> 0 /\\ i = Int64.repr 1.\n+\n+\n+Module DntSem_While1.\n+Import Lang_While\n+       BWFix Sets_CPO.\n+\n+(** 程序状态依旧是变量名到64位整数或未初始化值的函数，表达式的指称依旧包含成功求\n+    值情况与求值失败情况这两部分。*)\n+\n+Definition state: Type := var_name -> val.\n+\n+Module EDenote.\n+\n+Record EDenote: Type := {\n+  nrm: state -> int64 -> Prop;\n+  err: state -> Prop;\n+}.\n+\n+End EDenote.\n+\n+(** 以下为_[Notation]_声明，细节可以忽略。*)\n+\n+Import EDenote.\n+\n+Notation \"x '.(nrm)'\" := (EDenote.nrm x)\n+  (at level 1, only printing).\n+\n+Notation \"x '.(err)'\" := (EDenote.err x)\n+  (at level 1, only printing).\n+\n+Ltac any_nrm x := exact (EDenote.nrm x).\n+\n+Ltac any_err x := exact (EDenote.err x).\n+\n+Notation \"x '.(nrm)'\" := (ltac:(any_nrm x))\n+  (at level 1, only parsing).\n+\n+Notation \"x '.(err)'\" := (ltac:(any_err x))\n+  (at level 1, only parsing).\n+\n+(** 以下为语义定义。*)\n+\n+Definition arith_sem1_nrm\n+             (Zfun: Z -> Z -> Z)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute1_nrm Zfun i1 i2 i.\n+\n+Definition arith_sem1_err\n+             (Zfun: Z -> Z -> Z)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute1_err Zfun i1 i2.\n+\n+Definition arith_sem1 Zfun (D1 D2: EDenote): EDenote :=\n+  {|\n+    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ D2.(err) ∪\n+           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n+  |}.\n+\n+Definition arith_sem2_nrm\n+             (int64fun: int64 -> int64 -> int64)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute2_nrm int64fun i1 i2 i.\n+\n+Definition arith_sem2_err\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\\n+    arith_compute2_err i1 i2.\n+\n+Definition arith_sem2 int64fun (D1 D2: EDenote): EDenote :=\n+  {|\n+    nrm := arith_sem2_nrm int64fun D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ D2.(err) ∪\n+           arith_sem2_err D1.(nrm) D2.(nrm);\n+  |}.\n+\n+Definition cmp_sem_nrm\n+             (c: comparison)\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1 i2,\n+    D1 s i1 /\\ D2 s i2 /\\ cmp_compute_nrm c i1 i2 i.\n+\n+Definition cmp_sem c (D1 D2: EDenote): EDenote :=\n+  {|\n+    nrm := cmp_sem_nrm c D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ D2.(err);\n+  |}.\n+\n+Definition neg_sem_nrm\n+             (D1: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1, D1 s i1 /\\ neg_compute_nrm i1 i.\n+\n+Definition neg_sem_err\n+             (D1: state -> int64 -> Prop)\n+             (s: state): Prop :=\n+  exists i1, D1 s i1 /\\ neg_compute_err i1.\n+\n+Definition neg_sem (D1: EDenote): EDenote :=\n+  {|\n+    nrm := neg_sem_nrm D1.(nrm);\n+    err := D1.(err) ∪ neg_sem_err D1.(nrm);\n+  |}.\n+\n+Definition not_sem_nrm\n+             (D1: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1, D1 s i1 /\\ not_compute_nrm i1 i.\n+\n+Definition not_sem (D1: EDenote): EDenote :=\n+  {|\n+    nrm := not_sem_nrm D1.(nrm);\n+    err := D1.(err);\n+  |}.\n+\n+(** 所有运算符的语义中，二元布尔运算由于涉及短路求值，其定义是最复杂的。*)\n+\n+Definition and_sem_nrm\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1,\n+    D1 s i1 /\\\n+    (SC_and_compute_nrm i1 i \\/\n+     NonSC_and i1 /\\\n+     exists i2,\n+       D2 s i2 /\\ NonSC_compute_nrm i2 i).\n+\n+Definition and_sem_err\n+             (D1: state -> int64 -> Prop)\n+             (D2: state -> Prop)\n+             (s: state): Prop :=\n+  exists i1,\n+    D1 s i1 /\\ NonSC_and i1 /\\ D2 s.\n+\n+Definition and_sem (D1 D2: EDenote): EDenote :=\n+  {|\n+    nrm := and_sem_nrm D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ and_sem_err D1.(nrm) D2.(err);\n+  |}.\n+\n+Definition or_sem_nrm\n+             (D1 D2: state -> int64 -> Prop)\n+             (s: state)\n+             (i: int64): Prop :=\n+  exists i1,\n+    D1 s i1 /\\\n+    (SC_or_compute_nrm i1 i \\/\n+     NonSC_or i1 /\\\n+     exists i2,\n+       D2 s i2 /\\ NonSC_compute_nrm i2 i).\n+\n+Definition or_sem_err\n+             (D1: state -> int64 -> Prop)\n+             (D2: state -> Prop)\n+             (s: state): Prop :=\n+  exists i1,\n+    D1 s i1 /\\ NonSC_or i1 /\\ D2 s.\n+\n+Definition or_sem (D1 D2: EDenote): EDenote :=\n+  {|\n+    nrm := or_sem_nrm D1.(nrm) D2.(nrm);\n+    err := D1.(err) ∪ or_sem_err D1.(nrm) D2.(err);\n+  |}.\n+\n+(** 最终我们可以将所有一元运算与二元运算的语义汇总起来：*)\n+\n+Definition unop_sem (op: unop) (D: EDenote): EDenote :=\n+  match op with\n+  | ONeg => neg_sem D\n+  | ONot => not_sem D\n+  end.\n+\n+Definition binop_sem (op: binop) (D1 D2: EDenote): EDenote :=\n+  match op with\n+  | OOr => or_sem D1 D2\n+  | OAnd => and_sem D1 D2\n+  | OLt => cmp_sem Clt D1 D2\n+  | OLe => cmp_sem Cle D1 D2\n+  | OGt => cmp_sem Cgt D1 D2\n+  | OGe => cmp_sem Cge D1 D2\n+  | OEq => cmp_sem Ceq D1 D2\n+  | ONe => cmp_sem Cne D1 D2\n+  | OPlus => arith_sem1 Z.add D1 D2\n+  | OMinus => arith_sem1 Z.sub D1 D2\n+  | OMul => arith_sem1 Z.mul D1 D2\n+  | ODiv => arith_sem2 Int64.divs D1 D2\n+  | OMod => arith_sem2 Int64.mods D1 D2\n+  end.\n+\n+(** 最后补上常数和变量的语义即可得到完整的表达式语义。*)\n+\n+Definition const_sem (n: Z): EDenote :=\n+  {|\n+    nrm := fun s i =>\n+             i = Int64.repr n /\\\n+             Int64.min_signed <= n <= Int64.max_signed;\n+    err := fun s =>\n+             n < Int64.min_signed \\/\n+             n > Int64.max_signed;\n+  |}.\n+\n+Definition var_sem (X: var_name): EDenote :=\n+  {|\n+    nrm := fun s i => s X = Vint i;\n+    err := fun s => s X = Vuninit;\n+  |}.\n+\n+Fixpoint eval_expr (e: expr): EDenote :=\n+  match e with\n+  | EConst n =>\n+      const_sem n\n+  | EVar X =>\n+      var_sem X\n+  | EBinop op e1 e2 =>\n+      binop_sem op (eval_expr e1) (eval_expr e2)\n+  | EUnop op e1 =>\n+      unop_sem op (eval_expr e1)\n+  end.\n+\n+(** 基于表达式的指称语义，可以证明一些简单性质。*)\n+\n+Lemma const_plus_const_nrm:\n+  forall (n m: Z) (s: state) (i: int64),\n+    (eval_expr (EBinop OPlus (EConst n) (EConst m))).(nrm) s i ->\n+    (eval_expr (EConst (n + m))).(nrm) s i.\n+Proof.\n+  intros.\n+  simpl in H; unfold arith_sem1_nrm, arith_compute1_nrm in H.\n+  simpl.\n+  destruct H as [i1 [i2 [? [? [? ?] ] ] ] ].\n+  destruct H, H0.\n+  rewrite H1.\n+  apply Int64.signed_repr in H3.\n+  apply Int64.signed_repr in H4.\n+  rewrite <- H in H3.\n+  rewrite <- H0 in H4.\n+  rewrite <- H3, <- H4.\n+  tauto.\n+Qed.\n+\n+(** 下面定义程序语句的语义。程序语句的语义包含三种情况：正常运行终止、运行出错以\n+    及安全运行但不终止。*)\n+\n+Module CDenote.\n+\n+Record CDenote: Type := {\n+  nrm: state -> state -> Prop;\n+  err: state -> Prop;\n+  inf: state -> Prop\n+}.\n+\n+End CDenote.\n+\n+(** 以下为_[Notation]_声明，细节可以忽略。*)\n+\n+Import CDenote.\n+\n+Notation \"x '.(nrm)'\" := (CDenote.nrm x)\n+  (at level 1, only printing).\n+\n+Notation \"x '.(err)'\" := (CDenote.err x)\n+  (at level 1, only printing).\n+\n+Notation \"x '.(inf)'\" := (CDenote.inf x)\n+  (at level 1).\n+\n+Ltac any_nrm x ::=\n+  match type of x with\n+  | EDenote => exact (EDenote.nrm x)\n+  | CDenote => exact (CDenote.nrm x)\n+  end.\n+\n+Ltac any_err x ::=\n+  match type of x with\n+  | EDenote => exact (EDenote.err x)\n+  | CDenote => exact (CDenote.err x)\n+  end.\n+\n+(** 空语句的语义：*)\n+\n+Definition skip_sem: CDenote :=\n+  {|\n+    nrm := Rels.id;\n+    err := ∅;\n+    inf := ∅;\n+  |}.\n+\n+(** 赋值语句的语义：*)\n+\n+Definition asgn_sem\n+             (X: var_name)\n+             (D: EDenote): CDenote :=\n+  {|\n+    nrm := fun s1 s2 =>\n+      exists i,\n+        D.(nrm) s1 i /\\ s2 X = Vint i /\\\n+        (forall Y, X <> Y -> s2 Y = s1 Y);\n+    err := D.(err);\n+    inf := ∅;\n+  |}.\n+\n+(** 顺序执行语句的语义：*)\n+\n+Definition seq_sem (D1 D2: CDenote): CDenote :=\n+  {|\n+    nrm := D1.(nrm) ∘ D2.(nrm);\n+    err := D1.(err) ∪ (D1.(nrm) ∘ D2.(err));\n+    inf := D1.(inf) ∪ (D1.(nrm) ∘ D2.(inf));\n+  |}.\n+\n+(** 条件分支语句的语义：*)\n+\n+Definition test_true (D: EDenote):\n+  state -> state -> Prop :=\n+  Rels.test\n+    (fun s =>\n+       exists i, D.(nrm) s i /\\ Int64.signed i <> 0).\n+\n+Definition test_false (D: EDenote):\n+  state -> state -> Prop :=\n+  Rels.test (fun s => D.(nrm) s (Int64.repr 0)).\n+\n+Definition if_sem\n+             (D0: EDenote)\n+             (D1 D2: CDenote): CDenote :=\n+  {|\n+    nrm := (test_true D0 ∘ D1.(nrm)) ∪\n+           (test_false D0 ∘ D2.(nrm));\n+    err := D0.(err) ∪\n+           (test_true D0 ∘ D1.(err)) ∪\n+           (test_false D0 ∘ D2.(err));\n+    inf := (test_true D0 ∘ D1.(inf)) ∪\n+           (test_false D0 ∘ D2.(inf))\n+  |}.\n+\n+\n+(** While循环语句不终止的情况分为两种：每次执行循环体程序都正常运行终止但是\n+    由于一直满足循环条件将执行无穷多次循环体；某次执行循环体时，执行循环体的过程\n+    本身不终止。  \n+\n+\n+    下面定义的_[is_inf]_描述了以下关于程序状态集合_[X]_的性质：从集\n+    合_[X]_中的任意一个状态出发，计算循环条件的结果都为真（也不会计算出错），进\n+    入循环体执行后，要么正常运行终止并且终止于另一个（可以是同一个）_[X]_集合中\n+    的状态上，要么循环体运行不终止。*)\n+\n+Definition is_inf\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (X: state -> Prop): Prop :=\n+  X ⊆ test_true D0 ∘ ((D1.(nrm) ∘ X) ∪ D1.(inf)).\n+\n+(** 这样一来，循环不终止的情况可以定义为所有满足_[is_inf]_性质的集合的并集。*)\n+\n+Definition while_sem\n+             (D0: EDenote)\n+             (D1: CDenote): CDenote :=\n+  {|\n+    nrm := BW_LFix\n+             (fun X =>\n+                test_true D0 ∘ D1.(nrm) ∘ X ∪\n+                test_false D0);\n+    err := BW_LFix\n+             (fun X =>\n+                test_true D0 ∘ D1.(nrm) ∘ X ∪\n+                test_true D0 ∘ D1.(err) ∪ D0.(err));\n+    inf := Sets.general_union (is_inf D0 D1);\n+  |}.\n+\n+(** 程序语句的语义可以最后表示成下面递归函数。*)\n+\n+Fixpoint eval_com (c: com): CDenote :=\n+  match c with\n+  | CSkip =>\n+      skip_sem\n+  | CAsgn X e =>\n+      asgn_sem X (eval_expr e)\n+  | CSeq c1 c2 =>\n+      seq_sem (eval_com c1) (eval_com c2)\n+  | CIf e c1 c2 =>\n+      if_sem (eval_expr e) (eval_com c1) (eval_com c2)\n+  | CWhile e c1 =>\n+      while_sem (eval_expr e) (eval_com c1)\n+  end.\n+\n+\n+\n+\n+End DntSem_While1.\n+\n+(** * Knaster-Tarski不动点定理 *)\n+\n+\n+Module KTFix.\n+Import BWFix.\n+\n+(** 下面是这一不动点定理的Coq证明。*)\n+\n+Local Open Scope order_scope.\n+\n+(** 首先定义完备格。*)\n+\n+Definition is_lub {A: Type} {RA: Order A} (X: A -> Prop) (a: A): Prop :=\n+  is_ub X a /\\ is_lb (is_ub X) a.\n+\n+Definition is_glb {A: Type} {RA: Order A} (X: A -> Prop) (a: A): Prop :=\n+  is_lb X a /\\ is_ub (is_lb X) a.\n+\n+Class Lub (A: Type): Type :=\n+  lub: (A -> Prop) -> A.\n+\n+Class Glb (A: Type): Type :=\n+  glb: (A -> Prop) -> A.\n+\n+Class LubProperty (A: Type) {RA: Order A} {LubA: Lub A}: Prop :=\n+  lub_is_lub: forall X: A -> Prop, is_lub X (lub X).\n+\n+Class GlbProperty (A: Type) {RA: Order A} {GlbA: Glb A}: Prop :=\n+  glb_is_glb: forall X: A -> Prop, is_glb X (glb X).\n+\n+Lemma glb_sound: forall {A: Type} `{GlbPA: GlbProperty A},\n+  forall X: A -> Prop, is_lb X (glb X).\n+Proof. intros. destruct (glb_is_glb X). tauto. Qed.\n+\n+Lemma glb_tight: forall {A: Type} `{GlbPA: GlbProperty A},\n+  forall X: A -> Prop, is_ub (is_lb X) (glb X).\n+Proof. intros. destruct (glb_is_glb X). tauto. Qed.\n+\n+Class CompleteLattice_Setoid (A: Type)\n+        {RA: Order A} {EA: Equiv A} {LubA: Lub A} {glbA: Glb A}: Prop :=\n+{\n+  CL_PartialOrder:> PartialOrder_Setoid A;\n+  CL_LubP:> LubProperty A;\n+  CL_GlbP:> GlbProperty A\n+}.\n+\n+(** 下面基于完备格与单调函数的定义证明Knaster-Tarski不动点定理。*)\n+\n+Definition KT_LFix\n+             {A: Type}\n+             `{CLA: CompleteLattice_Setoid A}\n+             (f: A -> A): A :=\n+  glb (fun a => f a <= a).\n+\n+Lemma KT_LFix_is_pre_fix:\n+  forall\n+    {A: Type}\n+    `{CLA: CompleteLattice_Setoid A}\n+    {EquivA: Equivalence equiv}\n+    (f: A -> A),\n+    mono f ->\n+    f (KT_LFix f) <= KT_LFix f.\n+Proof.\n+  intros.\n+  unfold KT_LFix.\n+  apply glb_tight; unfold is_lb; intros.\n+  rewrite <- H0.\n+  apply H.\n+  apply glb_sound.\n+  apply H0.\n+Qed.\n+\n+Lemma KT_LFix_is_fix:\n+  forall\n+    {A: Type}\n+    `{CLA: CompleteLattice_Setoid A}\n+    {EquivA: Equivalence equiv}\n+    (f: A -> A),\n+    mono f ->\n+    f (KT_LFix f) == KT_LFix f.\n+Proof.\n+  intros.\n+  pose proof KT_LFix_is_pre_fix f H.\n+  apply antisymmetricity_setoid.\n+  + apply H0.\n+  + apply glb_sound.\n+    apply H, H0.\n+Qed.\n+\n+Lemma KT_LFix_is_least_fix:\n+  forall\n+    {A: Type}\n+    `{CLA: CompleteLattice_Setoid A}\n+    {EquivA: Equivalence equiv}\n+    (f: A -> A)\n+    (a: A),\n+    mono f ->\n+    f a == a ->\n+    KT_LFix f <= a.\n+Proof.\n+  intros.\n+  apply glb_sound.\n+  apply reflexivity_setoid.\n+  apply H0.\n+Qed.\n+\n+Local Close Scope order_scope.\n+\n+End KTFix.\n"
                },
                {
                    "date": 1700554993609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1084,1091 +1084,4 @@\n \n Local Close Scope order_scope.\n \n End KTFix.\n-Require Import Coq.micromega.Psatz.\n-Require Import Coq.ZArith.ZArith.\n-Require Import Coq.Strings.String.\n-Require Import Coq.Classes.Morphisms.\n-Require Import SetsClass.SetsClass. Import SetsNotation.\n-Require Import compcert.lib.Integers.\n-Require Import PL.SyntaxInCoq.\n-Require Import PL.DenotationalSemantics.\n-Local Open Scope bool.\n-Local Open Scope string.\n-Local Open Scope Z.\n-Local Open Scope sets.\n-\n-(** * 表示64位整数运算的整数表达式语义 *)\n-\n-Module DntSem_SimpleWhile6.\n-Import Lang_SimpleWhile.\n-\n-\n-(** 程序状态的修改：  \n-\n-    Coq定义：*)\n-\n-Definition state: Type := var_name -> int64.\n-\n-(** 这里_[int64]_是CompCert库中定义的64位整数，该定义是_[compcert.lib.Integers]_\n-    这一头文件导入的。除了_[int64]_的类型定义，CompCert还定义了64位整数的运算并\n-    证明相关运算的一些基本性质，例如_[Int64.add]_表示64位算术加法，_[Int64.and]_\n-    表示按位做『与』运算。  \n-\n-\n-\n-    除了上述表达算术运算、位运算的函数外，还有3个64位整数相关的函数十分常用，分\n-    别是：_[Int64.repr]_, _[Int64.signed]_, _[Int64.unsigned]_。另外，下面几个常\n-    数定义了有符号64位整数与无符号64位整数的大小边界：_[Int64.max_unsigned]_,\n-    _[Int64.max_signed]_, _[Int64.min_signed]_。  \n-\n-    除了修改程序状态的定义，还需要相应修改程序证整数类型表达式的语义。在Coq中，\n-    _[eval_expr_int e]_的类型就需要改为_[state -> int64]_。*)\n-\n-Definition add_sem (D1 D2: state -> int64) s: int64 :=\n-  Int64.add (D1 s) (D2 s).\n-\n-Definition sub_sem (D1 D2: state -> int64) s: int64 :=\n-  Int64.sub (D1 s) (D2 s).\n-\n-Definition mul_sem (D1 D2: state -> int64) s: int64 :=\n-  Int64.mul (D1 s) (D2 s).\n-\n-Definition const_sem (n: Z) (s: state): int64 :=\n-  Int64.repr n.\n-\n-Definition var_sem (X: var_name) (s: state): int64 :=\n-  s X.\n-\n-Fixpoint eval_expr_int (e: expr_int) : state -> int64 :=\n-  match e with\n-  | EConst n =>\n-      const_sem n\n-  | EVar X =>\n-      var_sem X\n-  | EAdd e1 e2 =>\n-      add_sem (eval_expr_int e1) (eval_expr_int e2)\n-  | ESub e1 e2 =>\n-      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n-  | EMul e1 e2 =>\n-      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n-  end.\n-\n-\n-End DntSem_SimpleWhile6.\n-\n-(** * 将运算越界定义为表达式求值错误 - 用部分函数 *)\n-\n-Module DntSem_SimpleWhile7.\n-Import Lang_SimpleWhile.\n-\n-Definition state: Type := var_name -> int64.\n-\n-Ltac int64_lia :=\n-  change Int64.min_signed with (-9223372036854775808) in *;\n-  change Int64.max_signed with 9223372036854775807 in *;\n-  lia.\n-\n-\n-(** 在讲解并实现简单解释器之前，我们曾经约定while语言的算术运算语义基本遵循C标准\n-    的规定。特别的，有符号64位整数的运算越界应当被视为程序错误（C11标准6.5章节第\n-    5段落）。然而，这一点并未在上面定义中得到体现。  \n-\n-    为了解决这一问题，我们需要能够在定义中表达『程序表达式求值出错』这一概念。这\n-    在数学上有两种常见方案。其一是将求值结果由64位整数集合改为64位整数或求值失\n-    败。  \n-\n-\n-\n-    在Coq中可以使用_[option]_类型描述相关概念。*)\n-\n-\n-Print option.\n-\n-(** 具体而言，对于任意Coq类型_[A]_，_[option A]_的元素要么是_[Some a]_（其中\n-    _[a]_是_[A]_的元素）要么是_[None]_。可以看到_[option]_也是一个Coq归纳类型，\n-    只不过其定义中并不需要对自身归纳。我们可以像处理先前其他归纳类型一样使用Coq\n-    中的_[match]_定义相关的函数或性质，例如：*)\n-\n-Definition option_plus1 (o: option Z): option Z :=\n-  match o with\n-  | Some x => Some (x + 1)\n-  | None => None\n-  end.\n-\n-(** 例如上面这一定义说的是：如果_[o]_的值是_[None]_那么就返回_[None]_，如果_[o]_\n-    的值是某个整数（_[Some]_的情况），那就将它加一返回。  \n-\n-    利用类似_[option]_类型可以改写表达式的语义定义。*)\n-\n-Definition const_sem (n: Z) (s: state): option int64 :=\n-  if (n <=? Int64.max_signed) && (n >=? Int64.min_signed)\n-  then Some (Int64.repr n)\n-  else None.\n-\n-Definition var_sem (x: var_name) (s: state): option int64 :=\n-  Some (s x).\n-\n-Definition add_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n-  match D1 s, D2 s with\n-  | Some i1, Some i2 =>\n-      if (Int64.signed i1 + Int64.signed i2 <=? Int64.max_signed) &&\n-         (Int64.signed i1 + Int64.signed i2 >=? Int64.min_signed)\n-      then Some (Int64.add i1 i2)\n-      else None\n-  | _, _ => None\n-  end.\n-\n-Definition sub_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n-  match D1 s, D2 s with\n-  | Some i1, Some i2 =>\n-      if (Int64.signed i1 - Int64.signed i2 <=? Int64.max_signed) &&\n-         (Int64.signed i1 - Int64.signed i2 >=? Int64.min_signed)\n-      then Some (Int64.sub i1 i2)\n-      else None\n-  | _, _ => None\n-  end.\n-\n-Definition mul_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n-  match D1 s, D2 s with\n-  | Some i1, Some i2 =>\n-      if (Int64.signed i1 * Int64.signed i2 <=? Int64.max_signed) &&\n-         (Int64.signed i1 * Int64.signed i2 >=? Int64.min_signed)\n-      then Some (Int64.mul i1 i2)\n-      else None\n-  | _, _ => None\n-  end.\n-\n-(** 最终，整数类型表达式的语义可以归结为下面递归定义。*)\n-\n-Fixpoint eval_expr_int (e: expr_int): state -> option int64 :=\n-  match e with\n-  | EConst n =>\n-      const_sem n\n-  | EVar X =>\n-      var_sem X\n-  | EAdd e1 e2 =>\n-      add_sem (eval_expr_int e1) (eval_expr_int e2)\n-  | ESub e1 e2 =>\n-      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n-  | EMul e1 e2 =>\n-      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n-  end.\n-\n-(** 上述定义中除了用到Coq的_[option]_类型，还用到了Coq的_[bool]_类型。*)\n-\n-Print bool.\n-\n-(** 根据定义_[bool]_类型只有两种可能的取值：_[true]_与_[false]_。请注意，Coq中的\n-    _[bool]_类型与命题（_[Prop]_类型）并不相同，前者专门用于关于真与假的真值运\n-    算，而后者则可以描述关于任意、存在等真假难以判定、无法计算真值的命题。上面的\n-    _[eval_expr_int]_定义要用于计算出_[option int64]_类型的结果，因此就只能使用\n-    _[bool]_类型的Coq函数来做判定了，他们分别是_[<=?]_, _[>=?]_与_[&&]_。*)\n-\n-Check 1 <=? 2.\n-Check 1 <= 2.\n-\n-(** 可以看到，_[1 <=? 2]_是用_[bool]_类型表达的判断两数大小的结果，这一符号对应\n-    的定义是：_[Z.leb 1 2]_。而_[1 <= 2]_则是关于两数大小关系的命题，这一符号对\n-    应的定义是：_[Z.le 1 2]_。Coq标准库中也证明了两者的联系。*)\n-\n-Check Z.leb_le.\n-\n-(** 这个定理说的是：_[forall n m : Z, (n <=? m) = true <-> n <= m]_。当然，Coq标\n-    准库中还有很多类似的有用的性质，这里就不再一一罗列了，相关信息也可以通过\n-    _[Search Z.leb]_或_[Search Z.le]_等方法查找。  \n-\n-    最后，在Coq中，可以用_[&&]_表示布尔值的合取（Coq定义是_[andb]_）并且使用\n-    _[if]_，_[then]_，_[else]_针对布尔表达式求值为真以及为假的情况分别采取不同的\n-    求值方法。将这些定义组合在一起，就得到了上面的_[eval_expr_int]_定义。  \n-\n-    下面是一些证明自动化指令（可以跳过）。*)\n-\n-Ltac int64_arith_simpl :=\n-  repeat\n-  match goal with\n-  | |- context [if ?X then Some ?A else None] =>\n-         match X with\n-         | context [?A <=? ?B] =>\n-            first\n-            [ assert (A <= B) as HHH by int64_lia;\n-              apply Z.leb_le in HHH;\n-              rewrite HHH; clear HHH]\n-         | context [?A >=? ?B] =>\n-            first\n-            [ assert (B <= A) as HHH by int64_lia;\n-              apply Z.geb_le in HHH;\n-              rewrite HHH; clear HHH]\n-         | context [true && ?b] => change (true && b) with b\n-         | context [false && ?b] => change (false && b) with false\n-         end\n-  | |- context [if true then ?A else ?B] =>\n-         change (if true then A else B) with A\n-  | |- context [if false then ?A else ?B] =>\n-         change (if false then A else B) with B\n-  | |- context [match Some ?A with | Some _ => _ | None => _ end] =>\n-         cbv beta iota\n-  | |- context [Int64.signed (Int64.repr ?n)] =>\n-         rewrite (Int64.signed_repr n) by int64_lia\n-  end.\n-\n-(** 我们可以在Coq中证明一些关于表达式指称语义的基本性质。*)\n-\n-Example eval_expr_int_fact0: forall st,\n-  st \"x\" = Int64.repr 0 ->\n-  eval_expr_int [[\"x\" + 1]] st = Some (Int64.repr 1).\n-Proof.\n-  intros.\n-  simpl.\n-  unfold add_sem, var_sem, const_sem.\n-  rewrite H.\n-  int64_arith_simpl.\n-  reflexivity.\n-Qed.\n-\n-\n-End DntSem_SimpleWhile7.\n-\n-Module DntSem_SimpleWhile8.\n-Import Lang_SimpleWhile\n-       DntSem_SimpleWhile7.\n-\n-\n-(** 上面定义中有三个分支的定义是相似，我们也可以统一定义。  \n-\n-    这里，_[Zfun: Z -> Z -> Z]_可以看做对整数加法（_[Z.add]_)、整数减法\n-    （_[Z.sub]_）与整数乘法（_[Z.mul]_）的抽象。而\n-     _[i64fun: int64 -> int64 -> int64]_可以看做对64位整数二元运算的抽象。*)\n-\n-Definition arith_sem\n-             (Zfun: Z -> Z -> Z)\n-             (int64fun: int64 -> int64 -> int64)\n-             (D1 D2: state -> option int64)\n-             (s: state): option int64 :=\n-  match D1 s, D2 s with\n-  | Some i1, Some i2 =>\n-      if (Zfun (Int64.signed i1) (Int64.signed i2)\n-                               <=? Int64.max_signed) &&\n-         (Zfun (Int64.signed i1) (Int64.signed i2)\n-                               >=? Int64.min_signed)\n-      then Some (int64fun i1 i2)\n-      else None\n-  | _, _ => None\n-  end.\n-\n-(** 例如，下面将_[Zfun]_取_[Z.add]_、_[int64fun]_取_[Int64.add]_代入：*)\n-\n-Example arith_sem_add_fact: forall D1 D2 s,\n-  arith_sem Z.add Int64.add D1 D2 s =\n-  match D1 s, D2 s with\n-  | Some i1, Some i2 =>\n-      if (Int64.signed i1 + Int64.signed i2\n-                               <=? Int64.max_signed) &&\n-         (Int64.signed i1 + Int64.signed i2\n-                               >=? Int64.min_signed)\n-      then Some (Int64.add i1 i2)\n-      else None\n-  | _, _ => None\n-  end.\n-Proof. intros. reflexivity. Qed.\n-\n-(** 这样，_[eval_expr_int]_的定义就可以简化为：*)\n-\n-Fixpoint eval_expr_int (e: expr_int):\n-  state -> option int64 :=\n-  match e with\n-  | EConst n =>\n-      const_sem n\n-  | EVar X =>\n-      var_sem X\n-  | EAdd e1 e2 =>\n-      arith_sem Z.add Int64.add\n-        (eval_expr_int e1) (eval_expr_int e2)\n-  | ESub e1 e2 =>\n-      arith_sem Z.sub Int64.sub\n-        (eval_expr_int e1) (eval_expr_int e2)\n-  | EMul e1 e2 =>\n-      arith_sem Z.mul Int64.mul\n-        (eval_expr_int e1) (eval_expr_int e2)\n-  end.\n-\n-\n-End DntSem_SimpleWhile8.\n-\n-(** * 将运算越界定义为表达式求值错误 - 用二元关系 *)\n-\n-(** 上面我们讨论了将表达式语义定义为程序状态到_[option int64]_的函数这一方案。下\n-    面我们探讨另一种描述程序运行出错或未定义行为的方案，即将表达式的语义定义为程\n-    序状态与_[int64]_之间的二元关系。  \n-\n-\n-    下面给出相应的Coq定义。首先定义64位整数之间在有符号64位整数范围内的运算关系。*)\n-\n-Definition arith_compute1_nrm\n-             (Zfun: Z -> Z -> Z)\n-             (i1 i2 i: int64): Prop :=\n-  let res := Zfun (Int64.signed i1) (Int64.signed i2) in\n-    i = Int64.repr res /\\\n-    Int64.min_signed <= res <= Int64.max_signed.\n-\n-Definition arith_compute1_err\n-             (Zfun: Z -> Z -> Z)\n-             (i1 i2: int64): Prop :=\n-  let res := Zfun (Int64.signed i1) (Int64.signed i2) in\n-    res < Int64.min_signed \\/ res > Int64.max_signed.\n-\n-Module DntSem_SimpleWhile9.\n-Import Lang_SimpleWhile.\n-\n-(** 接下去利用表达式与64位整数值间的二元关系表达『程序表达式求值出错』这一概念。\n-    具体而言，如果表达式_[e]_在程序状态_[s]_上能成果求值且求值结果为_[i]_，那么\n-    _[s]_与_[i]_这个有序对就在_[e]_的语义中。*)\n-\n-Definition state: Type := var_name -> int64.\n-\n-\n-(** 下面定义统一刻画了三种算术运算的语义。*)\n-\n-Definition arith_sem1_nrm\n-             (Zfun: Z -> Z -> Z)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute1_nrm Zfun i1 i2 i.\n-\n-Definition arith_sem1_err\n-             (Zfun: Z -> Z -> Z)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute1_err Zfun i1 i2.\n-\n-(** 一个表达式的语义分为两部分：求值成功的情况与求值出错的情况。*)\n-\n-Record denote: Type := {\n-  nrm: state -> int64 -> Prop;\n-  err: state -> Prop;\n-}.\n-\n-(** 下面_[Notation]_定义用于提供便捷易懂的表示方法，可以忽略其中的声明细节。*)\n-\n-Notation \"x '.(nrm)'\" := (nrm x) (at level 1).\n-Notation \"x '.(err)'\" := (err x) (at level 1).\n-\n-\n-(** Coq中的_[Record]_与许多程序语言中的结构体是类似的。在上面定义中，每个表达式\n-    的语义_[D: denote]_都有两个域：_[D.(nrm)]_与_[D.(err)]_分别描述前面提到的两\n-    种情况。*)\n-\n-Definition arith_sem1 Zfun (D1 D2: denote): denote :=\n-  {|\n-    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ D2.(err) ∪\n-           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n-  |}.\n-\n-Definition const_sem (n: Z): denote :=\n-  {|\n-    nrm := fun s i =>\n-             i = Int64.repr n /\\\n-             Int64.min_signed <= n <= Int64.max_signed;\n-    err := fun s =>\n-             n < Int64.min_signed \\/\n-             n > Int64.max_signed;\n-  |}.\n-\n-Definition var_sem (X: var_name): denote :=\n-  {|\n-    nrm := fun s i => i = s X;\n-    err := ∅;\n-  |}.\n-\n-(** 最终，整数类型表达式的语义可以归结为下面递归定义。*)\n-\n-Fixpoint eval_expr_int (e: expr_int): denote :=\n-  match e with\n-  | EConst n =>\n-      const_sem n\n-  | EVar X =>\n-      var_sem X\n-  | EAdd e1 e2 =>\n-      arith_sem1 Z.add (eval_expr_int e1) (eval_expr_int e2)\n-  | ESub e1 e2 =>\n-      arith_sem1 Z.sub (eval_expr_int e1) (eval_expr_int e2)\n-  | EMul e1 e2 =>\n-      arith_sem1 Z.mul (eval_expr_int e1) (eval_expr_int e2)\n-  end.\n-\n-\n-\n-End DntSem_SimpleWhile9.\n-\n-(** * 未初始化的变量 *)\n-\n-(** 在C语言和很多实际编程语言中，都不允许或不建议在运算中或赋值中使用未初始化的\n-    变量的值。若要根据这一设定定义程序语义，那么就需要修改程序状态的定义。变量的\n-    值可能是一个64位整数，也可能是未初始化。*)\n-\n-Inductive val: Type :=\n-| Vuninit: val\n-| Vint (i: int64): val.\n-\n-Module DntSem_SimpleWhile10.\n-Import Lang_SimpleWhile.\n-\n-(** 程序状态就变成变量名到_[val]_的函数。*)\n-\n-Definition state: Type := var_name -> val.\n-\n-(** 表达式的指称依旧包含原有的两部分。*)\n-\n-Record denote: Type := {\n-  nrm: state -> int64 -> Prop;\n-  err: state -> Prop;\n-}.\n-\n-Notation \"x '.(nrm)'\" := (nrm x) (at level 1).\n-Notation \"x '.(err)'\" := (err x) (at level 1).\n-\n-(** 下面这些Coq定义也不变。*)\n-\n-Definition arith_sem1_nrm\n-             (Zfun: Z -> Z -> Z)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute1_nrm Zfun i1 i2 i.\n-\n-Definition arith_sem1_err\n-             (Zfun: Z -> Z -> Z)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute1_err Zfun i1 i2.\n-\n-Definition arith_sem1 Zfun (D1 D2: denote): denote :=\n-  {|\n-    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ D2.(err) ∪\n-           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n-  |}.\n-\n-Definition const_sem (n: Z): denote :=\n-  {|\n-    nrm := fun s i =>\n-             i = Int64.repr n /\\\n-             Int64.min_signed <= n <= Int64.max_signed;\n-    err := fun s =>\n-             n < Int64.min_signed \\/\n-             n > Int64.max_signed;\n-  |}.\n-\n-(** 唯有整数类型表达式中变量的语义需要重新定义。*)\n-\n-Definition var_sem (X: var_name): denote :=\n-  {|\n-    nrm := fun s i => s X = Vint i;\n-    err := fun s => s X = Vuninit;\n-  |}.\n-\n-(** 最终，整数类型表达式的语义还是可以写成同样的递归定义。*)\n-\n-Fixpoint eval_expr_int (e: expr_int): denote :=\n-  match e with\n-  | EConst n =>\n-      const_sem n\n-  | EVar X =>\n-      var_sem X\n-  | EAdd e1 e2 =>\n-      arith_sem1 Z.add (eval_expr_int e1) (eval_expr_int e2)\n-  | ESub e1 e2 =>\n-      arith_sem1 Z.sub (eval_expr_int e1) (eval_expr_int e2)\n-  | EMul e1 e2 =>\n-      arith_sem1 Z.mul (eval_expr_int e1) (eval_expr_int e2)\n-  end.\n-\n-End DntSem_SimpleWhile10.\n-\n-(** * While语言的语义 *)\n-\n-(** 有了上面这些准备工作，我们可以定义完整While语言的语义。完整While语言中支持更\n-    多运算符，要描述除法和取余运算符的行为，要定义不同于加减乘的运算关系。下面定\n-    义参考了C标准对于有符号整数除法和取余的规定。*)\n-\n-Definition arith_compute2_nrm\n-             (int64fun: int64 -> int64 -> int64)\n-             (i1 i2 i: int64): Prop :=\n-  i = int64fun i1 i2 /\\\n-  Int64.signed i2 <> 0 /\\\n-  (Int64.signed i1 <> Int64.min_signed \\/\n-   Int64.signed i2 <> - 1).\n-\n-Definition arith_compute2_err (i1 i2: int64): Prop :=\n-  Int64.signed i2 = 0 \\/\n-  (Int64.signed i1 = Int64.min_signed /\\\n-   Int64.signed i2 = - 1).\n-\n-(** 下面定义的比较运算关系利用了CompCert库定义的_[comparison]_类型和_[Int64.cmp]_\n-    函数。*)\n-\n-Definition cmp_compute_nrm\n-             (c: comparison)\n-             (i1 i2 i: int64): Prop :=\n-  i = if Int64.cmp c i1 i2\n-      then Int64.repr 1\n-      else Int64.repr 0.\n-\n-(** 一元运算的行为比较容易定义：*)\n-\n-Definition neg_compute_nrm (i1 i: int64): Prop :=\n-  i = Int64.neg i1 /\\\n-  Int64.signed i1 <> Int64.min_signed.\n-\n-Definition neg_compute_err (i1: int64): Prop :=\n-  Int64.signed i1 = Int64.min_signed.\n-\n-Definition not_compute_nrm (i1 i: int64): Prop :=\n-  Int64.signed i1 <> 0 /\\ i = Int64.repr 0 \\/\n-  i1 = Int64.repr 0 /\\ i = Int64.repr 1.\n-\n-(** 最后，二元布尔运算的行为需要考虑短路求值的情况。下面定义中的缩写_[SC]_表示\n-    short circuit。*)\n-\n-Definition SC_and_compute_nrm (i1 i: int64): Prop :=\n-  i1 = Int64.repr 0 /\\ i = Int64.repr 0.\n-\n-Definition SC_or_compute_nrm (i1 i: int64): Prop :=\n-  Int64.signed i1 <> 0 /\\ i = Int64.repr 1.\n-\n-Definition NonSC_and (i1: int64): Prop :=\n-  Int64.signed i1 <> 0.\n-\n-Definition NonSC_or (i1: int64): Prop :=\n-  i1 = Int64.repr 0.\n-\n-Definition NonSC_compute_nrm (i2 i: int64): Prop :=\n-  i2 = Int64.repr 0 /\\ i = Int64.repr 0 \\/\n-  Int64.signed i2 <> 0 /\\ i = Int64.repr 1.\n-\n-\n-Module DntSem_While1.\n-Import Lang_While\n-       BWFix Sets_CPO.\n-\n-(** 程序状态依旧是变量名到64位整数或未初始化值的函数，表达式的指称依旧包含成功求\n-    值情况与求值失败情况这两部分。*)\n-\n-Definition state: Type := var_name -> val.\n-\n-Module EDenote.\n-\n-Record EDenote: Type := {\n-  nrm: state -> int64 -> Prop;\n-  err: state -> Prop;\n-}.\n-\n-End EDenote.\n-\n-(** 以下为_[Notation]_声明，细节可以忽略。*)\n-\n-Import EDenote.\n-\n-Notation \"x '.(nrm)'\" := (EDenote.nrm x)\n-  (at level 1, only printing).\n-\n-Notation \"x '.(err)'\" := (EDenote.err x)\n-  (at level 1, only printing).\n-\n-Ltac any_nrm x := exact (EDenote.nrm x).\n-\n-Ltac any_err x := exact (EDenote.err x).\n-\n-Notation \"x '.(nrm)'\" := (ltac:(any_nrm x))\n-  (at level 1, only parsing).\n-\n-Notation \"x '.(err)'\" := (ltac:(any_err x))\n-  (at level 1, only parsing).\n-\n-(** 以下为语义定义。*)\n-\n-Definition arith_sem1_nrm\n-             (Zfun: Z -> Z -> Z)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute1_nrm Zfun i1 i2 i.\n-\n-Definition arith_sem1_err\n-             (Zfun: Z -> Z -> Z)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute1_err Zfun i1 i2.\n-\n-Definition arith_sem1 Zfun (D1 D2: EDenote): EDenote :=\n-  {|\n-    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ D2.(err) ∪\n-           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n-  |}.\n-\n-Definition arith_sem2_nrm\n-             (int64fun: int64 -> int64 -> int64)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute2_nrm int64fun i1 i2 i.\n-\n-Definition arith_sem2_err\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\\n-    arith_compute2_err i1 i2.\n-\n-Definition arith_sem2 int64fun (D1 D2: EDenote): EDenote :=\n-  {|\n-    nrm := arith_sem2_nrm int64fun D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ D2.(err) ∪\n-           arith_sem2_err D1.(nrm) D2.(nrm);\n-  |}.\n-\n-Definition cmp_sem_nrm\n-             (c: comparison)\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1 i2,\n-    D1 s i1 /\\ D2 s i2 /\\ cmp_compute_nrm c i1 i2 i.\n-\n-Definition cmp_sem c (D1 D2: EDenote): EDenote :=\n-  {|\n-    nrm := cmp_sem_nrm c D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ D2.(err);\n-  |}.\n-\n-Definition neg_sem_nrm\n-             (D1: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1, D1 s i1 /\\ neg_compute_nrm i1 i.\n-\n-Definition neg_sem_err\n-             (D1: state -> int64 -> Prop)\n-             (s: state): Prop :=\n-  exists i1, D1 s i1 /\\ neg_compute_err i1.\n-\n-Definition neg_sem (D1: EDenote): EDenote :=\n-  {|\n-    nrm := neg_sem_nrm D1.(nrm);\n-    err := D1.(err) ∪ neg_sem_err D1.(nrm);\n-  |}.\n-\n-Definition not_sem_nrm\n-             (D1: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1, D1 s i1 /\\ not_compute_nrm i1 i.\n-\n-Definition not_sem (D1: EDenote): EDenote :=\n-  {|\n-    nrm := not_sem_nrm D1.(nrm);\n-    err := D1.(err);\n-  |}.\n-\n-(** 所有运算符的语义中，二元布尔运算由于涉及短路求值，其定义是最复杂的。*)\n-\n-Definition and_sem_nrm\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1,\n-    D1 s i1 /\\\n-    (SC_and_compute_nrm i1 i \\/\n-     NonSC_and i1 /\\\n-     exists i2,\n-       D2 s i2 /\\ NonSC_compute_nrm i2 i).\n-\n-Definition and_sem_err\n-             (D1: state -> int64 -> Prop)\n-             (D2: state -> Prop)\n-             (s: state): Prop :=\n-  exists i1,\n-    D1 s i1 /\\ NonSC_and i1 /\\ D2 s.\n-\n-Definition and_sem (D1 D2: EDenote): EDenote :=\n-  {|\n-    nrm := and_sem_nrm D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ and_sem_err D1.(nrm) D2.(err);\n-  |}.\n-\n-Definition or_sem_nrm\n-             (D1 D2: state -> int64 -> Prop)\n-             (s: state)\n-             (i: int64): Prop :=\n-  exists i1,\n-    D1 s i1 /\\\n-    (SC_or_compute_nrm i1 i \\/\n-     NonSC_or i1 /\\\n-     exists i2,\n-       D2 s i2 /\\ NonSC_compute_nrm i2 i).\n-\n-Definition or_sem_err\n-             (D1: state -> int64 -> Prop)\n-             (D2: state -> Prop)\n-             (s: state): Prop :=\n-  exists i1,\n-    D1 s i1 /\\ NonSC_or i1 /\\ D2 s.\n-\n-Definition or_sem (D1 D2: EDenote): EDenote :=\n-  {|\n-    nrm := or_sem_nrm D1.(nrm) D2.(nrm);\n-    err := D1.(err) ∪ or_sem_err D1.(nrm) D2.(err);\n-  |}.\n-\n-(** 最终我们可以将所有一元运算与二元运算的语义汇总起来：*)\n-\n-Definition unop_sem (op: unop) (D: EDenote): EDenote :=\n-  match op with\n-  | ONeg => neg_sem D\n-  | ONot => not_sem D\n-  end.\n-\n-Definition binop_sem (op: binop) (D1 D2: EDenote): EDenote :=\n-  match op with\n-  | OOr => or_sem D1 D2\n-  | OAnd => and_sem D1 D2\n-  | OLt => cmp_sem Clt D1 D2\n-  | OLe => cmp_sem Cle D1 D2\n-  | OGt => cmp_sem Cgt D1 D2\n-  | OGe => cmp_sem Cge D1 D2\n-  | OEq => cmp_sem Ceq D1 D2\n-  | ONe => cmp_sem Cne D1 D2\n-  | OPlus => arith_sem1 Z.add D1 D2\n-  | OMinus => arith_sem1 Z.sub D1 D2\n-  | OMul => arith_sem1 Z.mul D1 D2\n-  | ODiv => arith_sem2 Int64.divs D1 D2\n-  | OMod => arith_sem2 Int64.mods D1 D2\n-  end.\n-\n-(** 最后补上常数和变量的语义即可得到完整的表达式语义。*)\n-\n-Definition const_sem (n: Z): EDenote :=\n-  {|\n-    nrm := fun s i =>\n-             i = Int64.repr n /\\\n-             Int64.min_signed <= n <= Int64.max_signed;\n-    err := fun s =>\n-             n < Int64.min_signed \\/\n-             n > Int64.max_signed;\n-  |}.\n-\n-Definition var_sem (X: var_name): EDenote :=\n-  {|\n-    nrm := fun s i => s X = Vint i;\n-    err := fun s => s X = Vuninit;\n-  |}.\n-\n-Fixpoint eval_expr (e: expr): EDenote :=\n-  match e with\n-  | EConst n =>\n-      const_sem n\n-  | EVar X =>\n-      var_sem X\n-  | EBinop op e1 e2 =>\n-      binop_sem op (eval_expr e1) (eval_expr e2)\n-  | EUnop op e1 =>\n-      unop_sem op (eval_expr e1)\n-  end.\n-\n-(** 基于表达式的指称语义，可以证明一些简单性质。*)\n-\n-Lemma const_plus_const_nrm:\n-  forall (n m: Z) (s: state) (i: int64),\n-    (eval_expr (EBinop OPlus (EConst n) (EConst m))).(nrm) s i ->\n-    (eval_expr (EConst (n + m))).(nrm) s i.\n-Proof.\n-  intros.\n-  simpl in H; unfold arith_sem1_nrm, arith_compute1_nrm in H.\n-  simpl.\n-  destruct H as [i1 [i2 [? [? [? ?] ] ] ] ].\n-  destruct H, H0.\n-  rewrite H1.\n-  apply Int64.signed_repr in H3.\n-  apply Int64.signed_repr in H4.\n-  rewrite <- H in H3.\n-  rewrite <- H0 in H4.\n-  rewrite <- H3, <- H4.\n-  tauto.\n-Qed.\n-\n-(** 下面定义程序语句的语义。程序语句的语义包含三种情况：正常运行终止、运行出错以\n-    及安全运行但不终止。*)\n-\n-Module CDenote.\n-\n-Record CDenote: Type := {\n-  nrm: state -> state -> Prop;\n-  err: state -> Prop;\n-  inf: state -> Prop\n-}.\n-\n-End CDenote.\n-\n-(** 以下为_[Notation]_声明，细节可以忽略。*)\n-\n-Import CDenote.\n-\n-Notation \"x '.(nrm)'\" := (CDenote.nrm x)\n-  (at level 1, only printing).\n-\n-Notation \"x '.(err)'\" := (CDenote.err x)\n-  (at level 1, only printing).\n-\n-Notation \"x '.(inf)'\" := (CDenote.inf x)\n-  (at level 1).\n-\n-Ltac any_nrm x ::=\n-  match type of x with\n-  | EDenote => exact (EDenote.nrm x)\n-  | CDenote => exact (CDenote.nrm x)\n-  end.\n-\n-Ltac any_err x ::=\n-  match type of x with\n-  | EDenote => exact (EDenote.err x)\n-  | CDenote => exact (CDenote.err x)\n-  end.\n-\n-(** 空语句的语义：*)\n-\n-Definition skip_sem: CDenote :=\n-  {|\n-    nrm := Rels.id;\n-    err := ∅;\n-    inf := ∅;\n-  |}.\n-\n-(** 赋值语句的语义：*)\n-\n-Definition asgn_sem\n-             (X: var_name)\n-             (D: EDenote): CDenote :=\n-  {|\n-    nrm := fun s1 s2 =>\n-      exists i,\n-        D.(nrm) s1 i /\\ s2 X = Vint i /\\\n-        (forall Y, X <> Y -> s2 Y = s1 Y);\n-    err := D.(err);\n-    inf := ∅;\n-  |}.\n-\n-(** 顺序执行语句的语义：*)\n-\n-Definition seq_sem (D1 D2: CDenote): CDenote :=\n-  {|\n-    nrm := D1.(nrm) ∘ D2.(nrm);\n-    err := D1.(err) ∪ (D1.(nrm) ∘ D2.(err));\n-    inf := D1.(inf) ∪ (D1.(nrm) ∘ D2.(inf));\n-  |}.\n-\n-(** 条件分支语句的语义：*)\n-\n-Definition test_true (D: EDenote):\n-  state -> state -> Prop :=\n-  Rels.test\n-    (fun s =>\n-       exists i, D.(nrm) s i /\\ Int64.signed i <> 0).\n-\n-Definition test_false (D: EDenote):\n-  state -> state -> Prop :=\n-  Rels.test (fun s => D.(nrm) s (Int64.repr 0)).\n-\n-Definition if_sem\n-             (D0: EDenote)\n-             (D1 D2: CDenote): CDenote :=\n-  {|\n-    nrm := (test_true D0 ∘ D1.(nrm)) ∪\n-           (test_false D0 ∘ D2.(nrm));\n-    err := D0.(err) ∪\n-           (test_true D0 ∘ D1.(err)) ∪\n-           (test_false D0 ∘ D2.(err));\n-    inf := (test_true D0 ∘ D1.(inf)) ∪\n-           (test_false D0 ∘ D2.(inf))\n-  |}.\n-\n-\n-(** While循环语句不终止的情况分为两种：每次执行循环体程序都正常运行终止但是\n-    由于一直满足循环条件将执行无穷多次循环体；某次执行循环体时，执行循环体的过程\n-    本身不终止。  \n-\n-\n-    下面定义的_[is_inf]_描述了以下关于程序状态集合_[X]_的性质：从集\n-    合_[X]_中的任意一个状态出发，计算循环条件的结果都为真（也不会计算出错），进\n-    入循环体执行后，要么正常运行终止并且终止于另一个（可以是同一个）_[X]_集合中\n-    的状态上，要么循环体运行不终止。*)\n-\n-Definition is_inf\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (X: state -> Prop): Prop :=\n-  X ⊆ test_true D0 ∘ ((D1.(nrm) ∘ X) ∪ D1.(inf)).\n-\n-(** 这样一来，循环不终止的情况可以定义为所有满足_[is_inf]_性质的集合的并集。*)\n-\n-Definition while_sem\n-             (D0: EDenote)\n-             (D1: CDenote): CDenote :=\n-  {|\n-    nrm := BW_LFix\n-             (fun X =>\n-                test_true D0 ∘ D1.(nrm) ∘ X ∪\n-                test_false D0);\n-    err := BW_LFix\n-             (fun X =>\n-                test_true D0 ∘ D1.(nrm) ∘ X ∪\n-                test_true D0 ∘ D1.(err) ∪ D0.(err));\n-    inf := Sets.general_union (is_inf D0 D1);\n-  |}.\n-\n-(** 程序语句的语义可以最后表示成下面递归函数。*)\n-\n-Fixpoint eval_com (c: com): CDenote :=\n-  match c with\n-  | CSkip =>\n-      skip_sem\n-  | CAsgn X e =>\n-      asgn_sem X (eval_expr e)\n-  | CSeq c1 c2 =>\n-      seq_sem (eval_com c1) (eval_com c2)\n-  | CIf e c1 c2 =>\n-      if_sem (eval_expr e) (eval_com c1) (eval_com c2)\n-  | CWhile e c1 =>\n-      while_sem (eval_expr e) (eval_com c1)\n-  end.\n-\n-\n-\n-\n-End DntSem_While1.\n-\n-(** * Knaster-Tarski不动点定理 *)\n-\n-\n-Module KTFix.\n-Import BWFix.\n-\n-(** 下面是这一不动点定理的Coq证明。*)\n-\n-Local Open Scope order_scope.\n-\n-(** 首先定义完备格。*)\n-\n-Definition is_lub {A: Type} {RA: Order A} (X: A -> Prop) (a: A): Prop :=\n-  is_ub X a /\\ is_lb (is_ub X) a.\n-\n-Definition is_glb {A: Type} {RA: Order A} (X: A -> Prop) (a: A): Prop :=\n-  is_lb X a /\\ is_ub (is_lb X) a.\n-\n-Class Lub (A: Type): Type :=\n-  lub: (A -> Prop) -> A.\n-\n-Class Glb (A: Type): Type :=\n-  glb: (A -> Prop) -> A.\n-\n-Class LubProperty (A: Type) {RA: Order A} {LubA: Lub A}: Prop :=\n-  lub_is_lub: forall X: A -> Prop, is_lub X (lub X).\n-\n-Class GlbProperty (A: Type) {RA: Order A} {GlbA: Glb A}: Prop :=\n-  glb_is_glb: forall X: A -> Prop, is_glb X (glb X).\n-\n-Lemma glb_sound: forall {A: Type} `{GlbPA: GlbProperty A},\n-  forall X: A -> Prop, is_lb X (glb X).\n-Proof. intros. destruct (glb_is_glb X). tauto. Qed.\n-\n-Lemma glb_tight: forall {A: Type} `{GlbPA: GlbProperty A},\n-  forall X: A -> Prop, is_ub (is_lb X) (glb X).\n-Proof. intros. destruct (glb_is_glb X). tauto. Qed.\n-\n-Class CompleteLattice_Setoid (A: Type)\n-        {RA: Order A} {EA: Equiv A} {LubA: Lub A} {glbA: Glb A}: Prop :=\n-{\n-  CL_PartialOrder:> PartialOrder_Setoid A;\n-  CL_LubP:> LubProperty A;\n-  CL_GlbP:> GlbProperty A\n-}.\n-\n-(** 下面基于完备格与单调函数的定义证明Knaster-Tarski不动点定理。*)\n-\n-Definition KT_LFix\n-             {A: Type}\n-             `{CLA: CompleteLattice_Setoid A}\n-             (f: A -> A): A :=\n-  glb (fun a => f a <= a).\n-\n-Lemma KT_LFix_is_pre_fix:\n-  forall\n-    {A: Type}\n-    `{CLA: CompleteLattice_Setoid A}\n-    {EquivA: Equivalence equiv}\n-    (f: A -> A),\n-    mono f ->\n-    f (KT_LFix f) <= KT_LFix f.\n-Proof.\n-  intros.\n-  unfold KT_LFix.\n-  apply glb_tight; unfold is_lb; intros.\n-  rewrite <- H0.\n-  apply H.\n-  apply glb_sound.\n-  apply H0.\n-Qed.\n-\n-Lemma KT_LFix_is_fix:\n-  forall\n-    {A: Type}\n-    `{CLA: CompleteLattice_Setoid A}\n-    {EquivA: Equivalence equiv}\n-    (f: A -> A),\n-    mono f ->\n-    f (KT_LFix f) == KT_LFix f.\n-Proof.\n-  intros.\n-  pose proof KT_LFix_is_pre_fix f H.\n-  apply antisymmetricity_setoid.\n-  + apply H0.\n-  + apply glb_sound.\n-    apply H, H0.\n-Qed.\n-\n-Lemma KT_LFix_is_least_fix:\n-  forall\n-    {A: Type}\n-    `{CLA: CompleteLattice_Setoid A}\n-    {EquivA: Equivalence equiv}\n-    (f: A -> A)\n-    (a: A),\n-    mono f ->\n-    f a == a ->\n-    KT_LFix f <= a.\n-Proof.\n-  intros.\n-  apply glb_sound.\n-  apply reflexivity_setoid.\n-  apply H0.\n-Qed.\n-\n-Local Close Scope order_scope.\n-\n-End KTFix.\n"
                }
            ],
            "date": 1700546317121,
            "name": "Commit-0",
            "content": "Require Import Coq.micromega.Psatz.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Strings.String.\nRequire Import Coq.Classes.Morphisms.\nRequire Import SetsClass.SetsClass. Import SetsNotation.\nRequire Import compcert.lib.Integers.\nRequire Import PL.SyntaxInCoq.\nRequire Import PL.DenotationalSemantics.\nLocal Open Scope bool.\nLocal Open Scope string.\nLocal Open Scope Z.\nLocal Open Scope sets.\n\n(** * 表示64位整数运算的整数表达式语义 *)\n\nModule DntSem_SimpleWhile6.\nImport Lang_SimpleWhile.\n\n\n(** 程序状态的修改：  \n\n    Coq定义：*)\n\nDefinition state: Type := var_name -> int64.\n\n(** 这里_[int64]_是CompCert库中定义的64位整数，该定义是_[compcert.lib.Integers]_\n    这一头文件导入的。除了_[int64]_的类型定义，CompCert还定义了64位整数的运算并\n    证明相关运算的一些基本性质，例如_[Int64.add]_表示64位算术加法，_[Int64.and]_\n    表示按位做『与』运算。  \n\n\n\n    除了上述表达算术运算、位运算的函数外，还有3个64位整数相关的函数十分常用，分\n    别是：_[Int64.repr]_, _[Int64.signed]_, _[Int64.unsigned]_。另外，下面几个常\n    数定义了有符号64位整数与无符号64位整数的大小边界：_[Int64.max_unsigned]_,\n    _[Int64.max_signed]_, _[Int64.min_signed]_。  \n\n    除了修改程序状态的定义，还需要相应修改程序证整数类型表达式的语义。在Coq中，\n    _[eval_expr_int e]_的类型就需要改为_[state -> int64]_。*)\n\nDefinition add_sem (D1 D2: state -> int64) s: int64 :=\n  Int64.add (D1 s) (D2 s).\n\nDefinition sub_sem (D1 D2: state -> int64) s: int64 :=\n  Int64.sub (D1 s) (D2 s).\n\nDefinition mul_sem (D1 D2: state -> int64) s: int64 :=\n  Int64.mul (D1 s) (D2 s).\n\nDefinition const_sem (n: Z) (s: state): int64 :=\n  Int64.repr n.\n\nDefinition var_sem (X: var_name) (s: state): int64 :=\n  s X.\n\nFixpoint eval_expr_int (e: expr_int) : state -> int64 :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      add_sem (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\n\nEnd DntSem_SimpleWhile6.\n\n(** * 将运算越界定义为表达式求值错误 - 用部分函数 *)\n\nModule DntSem_SimpleWhile7.\nImport Lang_SimpleWhile.\n\nDefinition state: Type := var_name -> int64.\n\nLtac int64_lia :=\n  change Int64.min_signed with (-9223372036854775808) in *;\n  change Int64.max_signed with 9223372036854775807 in *;\n  lia.\n\n\n(** 在讲解并实现简单解释器之前，我们曾经约定while语言的算术运算语义基本遵循C标准\n    的规定。特别的，有符号64位整数的运算越界应当被视为程序错误（C11标准6.5章节第\n    5段落）。然而，这一点并未在上面定义中得到体现。  \n\n    为了解决这一问题，我们需要能够在定义中表达『程序表达式求值出错』这一概念。这\n    在数学上有两种常见方案。其一是将求值结果由64位整数集合改为64位整数或求值失\n    败。  \n\n\n\n    在Coq中可以使用_[option]_类型描述相关概念。*)\n\n\nPrint option.\n\n(** 具体而言，对于任意Coq类型_[A]_，_[option A]_的元素要么是_[Some a]_（其中\n    _[a]_是_[A]_的元素）要么是_[None]_。可以看到_[option]_也是一个Coq归纳类型，\n    只不过其定义中并不需要对自身归纳。我们可以像处理先前其他归纳类型一样使用Coq\n    中的_[match]_定义相关的函数或性质，例如：*)\n\nDefinition option_plus1 (o: option Z): option Z :=\n  match o with\n  | Some x => Some (x + 1)\n  | None => None\n  end.\n\n(** 例如上面这一定义说的是：如果_[o]_的值是_[None]_那么就返回_[None]_，如果_[o]_\n    的值是某个整数（_[Some]_的情况），那就将它加一返回。  \n\n    利用类似_[option]_类型可以改写表达式的语义定义。*)\n\nDefinition const_sem (n: Z) (s: state): option int64 :=\n  if (n <=? Int64.max_signed) && (n >=? Int64.min_signed)\n  then Some (Int64.repr n)\n  else None.\n\nDefinition var_sem (x: var_name) (s: state): option int64 :=\n  Some (s x).\n\nDefinition add_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n  match D1 s, D2 s with\n  | Some i1, Some i2 =>\n      if (Int64.signed i1 + Int64.signed i2 <=? Int64.max_signed) &&\n         (Int64.signed i1 + Int64.signed i2 >=? Int64.min_signed)\n      then Some (Int64.add i1 i2)\n      else None\n  | _, _ => None\n  end.\n\nDefinition sub_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n  match D1 s, D2 s with\n  | Some i1, Some i2 =>\n      if (Int64.signed i1 - Int64.signed i2 <=? Int64.max_signed) &&\n         (Int64.signed i1 - Int64.signed i2 >=? Int64.min_signed)\n      then Some (Int64.sub i1 i2)\n      else None\n  | _, _ => None\n  end.\n\nDefinition mul_sem (D1 D2: state -> option int64) (s: state): option int64 :=\n  match D1 s, D2 s with\n  | Some i1, Some i2 =>\n      if (Int64.signed i1 * Int64.signed i2 <=? Int64.max_signed) &&\n         (Int64.signed i1 * Int64.signed i2 >=? Int64.min_signed)\n      then Some (Int64.mul i1 i2)\n      else None\n  | _, _ => None\n  end.\n\n(** 最终，整数类型表达式的语义可以归结为下面递归定义。*)\n\nFixpoint eval_expr_int (e: expr_int): state -> option int64 :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      add_sem (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\n(** 上述定义中除了用到Coq的_[option]_类型，还用到了Coq的_[bool]_类型。*)\n\nPrint bool.\n\n(** 根据定义_[bool]_类型只有两种可能的取值：_[true]_与_[false]_。请注意，Coq中的\n    _[bool]_类型与命题（_[Prop]_类型）并不相同，前者专门用于关于真与假的真值运\n    算，而后者则可以描述关于任意、存在等真假难以判定、无法计算真值的命题。上面的\n    _[eval_expr_int]_定义要用于计算出_[option int64]_类型的结果，因此就只能使用\n    _[bool]_类型的Coq函数来做判定了，他们分别是_[<=?]_, _[>=?]_与_[&&]_。*)\n\nCheck 1 <=? 2.\nCheck 1 <= 2.\n\n(** 可以看到，_[1 <=? 2]_是用_[bool]_类型表达的判断两数大小的结果，这一符号对应\n    的定义是：_[Z.leb 1 2]_。而_[1 <= 2]_则是关于两数大小关系的命题，这一符号对\n    应的定义是：_[Z.le 1 2]_。Coq标准库中也证明了两者的联系。*)\n\nCheck Z.leb_le.\n\n(** 这个定理说的是：_[forall n m : Z, (n <=? m) = true <-> n <= m]_。当然，Coq标\n    准库中还有很多类似的有用的性质，这里就不再一一罗列了，相关信息也可以通过\n    _[Search Z.leb]_或_[Search Z.le]_等方法查找。  \n\n    最后，在Coq中，可以用_[&&]_表示布尔值的合取（Coq定义是_[andb]_）并且使用\n    _[if]_，_[then]_，_[else]_针对布尔表达式求值为真以及为假的情况分别采取不同的\n    求值方法。将这些定义组合在一起，就得到了上面的_[eval_expr_int]_定义。  \n\n    下面是一些证明自动化指令（可以跳过）。*)\n\nLtac int64_arith_simpl :=\n  repeat\n  match goal with\n  | |- context [if ?X then Some ?A else None] =>\n         match X with\n         | context [?A <=? ?B] =>\n            first\n            [ assert (A <= B) as HHH by int64_lia;\n              apply Z.leb_le in HHH;\n              rewrite HHH; clear HHH]\n         | context [?A >=? ?B] =>\n            first\n            [ assert (B <= A) as HHH by int64_lia;\n              apply Z.geb_le in HHH;\n              rewrite HHH; clear HHH]\n         | context [true && ?b] => change (true && b) with b\n         | context [false && ?b] => change (false && b) with false\n         end\n  | |- context [if true then ?A else ?B] =>\n         change (if true then A else B) with A\n  | |- context [if false then ?A else ?B] =>\n         change (if false then A else B) with B\n  | |- context [match Some ?A with | Some _ => _ | None => _ end] =>\n         cbv beta iota\n  | |- context [Int64.signed (Int64.repr ?n)] =>\n         rewrite (Int64.signed_repr n) by int64_lia\n  end.\n\n(** 我们可以在Coq中证明一些关于表达式指称语义的基本性质。*)\n\nExample eval_expr_int_fact0: forall st,\n  st \"x\" = Int64.repr 0 ->\n  eval_expr_int [[\"x\" + 1]] st = Some (Int64.repr 1).\nProof.\n  intros.\n  simpl.\n  unfold add_sem, var_sem, const_sem.\n  rewrite H.\n  int64_arith_simpl.\n  reflexivity.\nQed.\n\n\nEnd DntSem_SimpleWhile7.\n\nModule DntSem_SimpleWhile8.\nImport Lang_SimpleWhile\n       DntSem_SimpleWhile7.\n\n\n(** 上面定义中有三个分支的定义是相似，我们也可以统一定义。  \n\n    这里，_[Zfun: Z -> Z -> Z]_可以看做对整数加法（_[Z.add]_)、整数减法\n    （_[Z.sub]_）与整数乘法（_[Z.mul]_）的抽象。而\n     _[i64fun: int64 -> int64 -> int64]_可以看做对64位整数二元运算的抽象。*)\n\nDefinition arith_sem\n             (Zfun: Z -> Z -> Z)\n             (int64fun: int64 -> int64 -> int64)\n             (D1 D2: state -> option int64)\n             (s: state): option int64 :=\n  match D1 s, D2 s with\n  | Some i1, Some i2 =>\n      if (Zfun (Int64.signed i1) (Int64.signed i2)\n                               <=? Int64.max_signed) &&\n         (Zfun (Int64.signed i1) (Int64.signed i2)\n                               >=? Int64.min_signed)\n      then Some (int64fun i1 i2)\n      else None\n  | _, _ => None\n  end.\n\n(** 例如，下面将_[Zfun]_取_[Z.add]_、_[int64fun]_取_[Int64.add]_代入：*)\n\nExample arith_sem_add_fact: forall D1 D2 s,\n  arith_sem Z.add Int64.add D1 D2 s =\n  match D1 s, D2 s with\n  | Some i1, Some i2 =>\n      if (Int64.signed i1 + Int64.signed i2\n                               <=? Int64.max_signed) &&\n         (Int64.signed i1 + Int64.signed i2\n                               >=? Int64.min_signed)\n      then Some (Int64.add i1 i2)\n      else None\n  | _, _ => None\n  end.\nProof. intros. reflexivity. Qed.\n\n(** 这样，_[eval_expr_int]_的定义就可以简化为：*)\n\nFixpoint eval_expr_int (e: expr_int):\n  state -> option int64 :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      arith_sem Z.add Int64.add\n        (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      arith_sem Z.sub Int64.sub\n        (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      arith_sem Z.mul Int64.mul\n        (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\n\nEnd DntSem_SimpleWhile8.\n\n(** * 将运算越界定义为表达式求值错误 - 用二元关系 *)\n\n(** 上面我们讨论了将表达式语义定义为程序状态到_[option int64]_的函数这一方案。下\n    面我们探讨另一种描述程序运行出错或未定义行为的方案，即将表达式的语义定义为程\n    序状态与_[int64]_之间的二元关系。  \n\n\n    下面给出相应的Coq定义。首先定义64位整数之间在有符号64位整数范围内的运算关系。*)\n\nDefinition arith_compute1_nrm\n             (Zfun: Z -> Z -> Z)\n             (i1 i2 i: int64): Prop :=\n  let res := Zfun (Int64.signed i1) (Int64.signed i2) in\n    i = Int64.repr res /\\\n    Int64.min_signed <= res <= Int64.max_signed.\n\nDefinition arith_compute1_err\n             (Zfun: Z -> Z -> Z)\n             (i1 i2: int64): Prop :=\n  let res := Zfun (Int64.signed i1) (Int64.signed i2) in\n    res < Int64.min_signed \\/ res > Int64.max_signed.\n\nModule DntSem_SimpleWhile9.\nImport Lang_SimpleWhile.\n\n(** 接下去利用表达式与64位整数值间的二元关系表达『程序表达式求值出错』这一概念。\n    具体而言，如果表达式_[e]_在程序状态_[s]_上能成果求值且求值结果为_[i]_，那么\n    _[s]_与_[i]_这个有序对就在_[e]_的语义中。*)\n\nDefinition state: Type := var_name -> int64.\n\n\n(** 下面定义统一刻画了三种算术运算的语义。*)\n\nDefinition arith_sem1_nrm\n             (Zfun: Z -> Z -> Z)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute1_nrm Zfun i1 i2 i.\n\nDefinition arith_sem1_err\n             (Zfun: Z -> Z -> Z)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute1_err Zfun i1 i2.\n\n(** 一个表达式的语义分为两部分：求值成功的情况与求值出错的情况。*)\n\nRecord denote: Type := {\n  nrm: state -> int64 -> Prop;\n  err: state -> Prop;\n}.\n\n(** 下面_[Notation]_定义用于提供便捷易懂的表示方法，可以忽略其中的声明细节。*)\n\nNotation \"x '.(nrm)'\" := (nrm x) (at level 1).\nNotation \"x '.(err)'\" := (err x) (at level 1).\n\n\n(** Coq中的_[Record]_与许多程序语言中的结构体是类似的。在上面定义中，每个表达式\n    的语义_[D: denote]_都有两个域：_[D.(nrm)]_与_[D.(err)]_分别描述前面提到的两\n    种情况。*)\n\nDefinition arith_sem1 Zfun (D1 D2: denote): denote :=\n  {|\n    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ D2.(err) ∪\n           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n  |}.\n\nDefinition const_sem (n: Z): denote :=\n  {|\n    nrm := fun s i =>\n             i = Int64.repr n /\\\n             Int64.min_signed <= n <= Int64.max_signed;\n    err := fun s =>\n             n < Int64.min_signed \\/\n             n > Int64.max_signed;\n  |}.\n\nDefinition var_sem (X: var_name): denote :=\n  {|\n    nrm := fun s i => i = s X;\n    err := ∅;\n  |}.\n\n(** 最终，整数类型表达式的语义可以归结为下面递归定义。*)\n\nFixpoint eval_expr_int (e: expr_int): denote :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      arith_sem1 Z.add (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      arith_sem1 Z.sub (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      arith_sem1 Z.mul (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\n\n\nEnd DntSem_SimpleWhile9.\n\n(** * 未初始化的变量 *)\n\n(** 在C语言和很多实际编程语言中，都不允许或不建议在运算中或赋值中使用未初始化的\n    变量的值。若要根据这一设定定义程序语义，那么就需要修改程序状态的定义。变量的\n    值可能是一个64位整数，也可能是未初始化。*)\n\nInductive val: Type :=\n| Vuninit: val\n| Vint (i: int64): val.\n\nModule DntSem_SimpleWhile10.\nImport Lang_SimpleWhile.\n\n(** 程序状态就变成变量名到_[val]_的函数。*)\n\nDefinition state: Type := var_name -> val.\n\n(** 表达式的指称依旧包含原有的两部分。*)\n\nRecord denote: Type := {\n  nrm: state -> int64 -> Prop;\n  err: state -> Prop;\n}.\n\nNotation \"x '.(nrm)'\" := (nrm x) (at level 1).\nNotation \"x '.(err)'\" := (err x) (at level 1).\n\n(** 下面这些Coq定义也不变。*)\n\nDefinition arith_sem1_nrm\n             (Zfun: Z -> Z -> Z)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute1_nrm Zfun i1 i2 i.\n\nDefinition arith_sem1_err\n             (Zfun: Z -> Z -> Z)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute1_err Zfun i1 i2.\n\nDefinition arith_sem1 Zfun (D1 D2: denote): denote :=\n  {|\n    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ D2.(err) ∪\n           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n  |}.\n\nDefinition const_sem (n: Z): denote :=\n  {|\n    nrm := fun s i =>\n             i = Int64.repr n /\\\n             Int64.min_signed <= n <= Int64.max_signed;\n    err := fun s =>\n             n < Int64.min_signed \\/\n             n > Int64.max_signed;\n  |}.\n\n(** 唯有整数类型表达式中变量的语义需要重新定义。*)\n\nDefinition var_sem (X: var_name): denote :=\n  {|\n    nrm := fun s i => s X = Vint i;\n    err := fun s => s X = Vuninit;\n  |}.\n\n(** 最终，整数类型表达式的语义还是可以写成同样的递归定义。*)\n\nFixpoint eval_expr_int (e: expr_int): denote :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      arith_sem1 Z.add (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      arith_sem1 Z.sub (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      arith_sem1 Z.mul (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\nEnd DntSem_SimpleWhile10.\n\n(** * While语言的语义 *)\n\n(** 有了上面这些准备工作，我们可以定义完整While语言的语义。完整While语言中支持更\n    多运算符，要描述除法和取余运算符的行为，要定义不同于加减乘的运算关系。下面定\n    义参考了C标准对于有符号整数除法和取余的规定。*)\n\nDefinition arith_compute2_nrm\n             (int64fun: int64 -> int64 -> int64)\n             (i1 i2 i: int64): Prop :=\n  i = int64fun i1 i2 /\\\n  Int64.signed i2 <> 0 /\\\n  (Int64.signed i1 <> Int64.min_signed \\/\n   Int64.signed i2 <> - 1).\n\nDefinition arith_compute2_err (i1 i2: int64): Prop :=\n  Int64.signed i2 = 0 \\/\n  (Int64.signed i1 = Int64.min_signed /\\\n   Int64.signed i2 = - 1).\n\n(** 下面定义的比较运算关系利用了CompCert库定义的_[comparison]_类型和_[Int64.cmp]_\n    函数。*)\n\nDefinition cmp_compute_nrm\n             (c: comparison)\n             (i1 i2 i: int64): Prop :=\n  i = if Int64.cmp c i1 i2\n      then Int64.repr 1\n      else Int64.repr 0.\n\n(** 一元运算的行为比较容易定义：*)\n\nDefinition neg_compute_nrm (i1 i: int64): Prop :=\n  i = Int64.neg i1 /\\\n  Int64.signed i1 <> Int64.min_signed.\n\nDefinition neg_compute_err (i1: int64): Prop :=\n  Int64.signed i1 = Int64.min_signed.\n\nDefinition not_compute_nrm (i1 i: int64): Prop :=\n  Int64.signed i1 <> 0 /\\ i = Int64.repr 0 \\/\n  i1 = Int64.repr 0 /\\ i = Int64.repr 1.\n\n(** 最后，二元布尔运算的行为需要考虑短路求值的情况。下面定义中的缩写_[SC]_表示\n    short circuit。*)\n\nDefinition SC_and_compute_nrm (i1 i: int64): Prop :=\n  i1 = Int64.repr 0 /\\ i = Int64.repr 0.\n\nDefinition SC_or_compute_nrm (i1 i: int64): Prop :=\n  Int64.signed i1 <> 0 /\\ i = Int64.repr 1.\n\nDefinition NonSC_and (i1: int64): Prop :=\n  Int64.signed i1 <> 0.\n\nDefinition NonSC_or (i1: int64): Prop :=\n  i1 = Int64.repr 0.\n\nDefinition NonSC_compute_nrm (i2 i: int64): Prop :=\n  i2 = Int64.repr 0 /\\ i = Int64.repr 0 \\/\n  Int64.signed i2 <> 0 /\\ i = Int64.repr 1.\n\n\nModule DntSem_While1.\nImport Lang_While\n       BWFix Sets_CPO.\n\n(** 程序状态依旧是变量名到64位整数或未初始化值的函数，表达式的指称依旧包含成功求\n    值情况与求值失败情况这两部分。*)\n\nDefinition state: Type := var_name -> val.\n\nModule EDenote.\n\nRecord EDenote: Type := {\n  nrm: state -> int64 -> Prop;\n  err: state -> Prop;\n}.\n\nEnd EDenote.\n\n(** 以下为_[Notation]_声明，细节可以忽略。*)\n\nImport EDenote.\n\nNotation \"x '.(nrm)'\" := (EDenote.nrm x)\n  (at level 1, only printing).\n\nNotation \"x '.(err)'\" := (EDenote.err x)\n  (at level 1, only printing).\n\nLtac any_nrm x := exact (EDenote.nrm x).\n\nLtac any_err x := exact (EDenote.err x).\n\nNotation \"x '.(nrm)'\" := (ltac:(any_nrm x))\n  (at level 1, only parsing).\n\nNotation \"x '.(err)'\" := (ltac:(any_err x))\n  (at level 1, only parsing).\n\n(** 以下为语义定义。*)\n\nDefinition arith_sem1_nrm\n             (Zfun: Z -> Z -> Z)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute1_nrm Zfun i1 i2 i.\n\nDefinition arith_sem1_err\n             (Zfun: Z -> Z -> Z)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute1_err Zfun i1 i2.\n\nDefinition arith_sem1 Zfun (D1 D2: EDenote): EDenote :=\n  {|\n    nrm := arith_sem1_nrm Zfun D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ D2.(err) ∪\n           arith_sem1_err Zfun D1.(nrm) D2.(nrm);\n  |}.\n\nDefinition arith_sem2_nrm\n             (int64fun: int64 -> int64 -> int64)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute2_nrm int64fun i1 i2 i.\n\nDefinition arith_sem2_err\n             (D1 D2: state -> int64 -> Prop)\n             (s: state): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\\n    arith_compute2_err i1 i2.\n\nDefinition arith_sem2 int64fun (D1 D2: EDenote): EDenote :=\n  {|\n    nrm := arith_sem2_nrm int64fun D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ D2.(err) ∪\n           arith_sem2_err D1.(nrm) D2.(nrm);\n  |}.\n\nDefinition cmp_sem_nrm\n             (c: comparison)\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1 i2,\n    D1 s i1 /\\ D2 s i2 /\\ cmp_compute_nrm c i1 i2 i.\n\nDefinition cmp_sem c (D1 D2: EDenote): EDenote :=\n  {|\n    nrm := cmp_sem_nrm c D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ D2.(err);\n  |}.\n\nDefinition neg_sem_nrm\n             (D1: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1, D1 s i1 /\\ neg_compute_nrm i1 i.\n\nDefinition neg_sem_err\n             (D1: state -> int64 -> Prop)\n             (s: state): Prop :=\n  exists i1, D1 s i1 /\\ neg_compute_err i1.\n\nDefinition neg_sem (D1: EDenote): EDenote :=\n  {|\n    nrm := neg_sem_nrm D1.(nrm);\n    err := D1.(err) ∪ neg_sem_err D1.(nrm);\n  |}.\n\nDefinition not_sem_nrm\n             (D1: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1, D1 s i1 /\\ not_compute_nrm i1 i.\n\nDefinition not_sem (D1: EDenote): EDenote :=\n  {|\n    nrm := not_sem_nrm D1.(nrm);\n    err := D1.(err);\n  |}.\n\n(** 所有运算符的语义中，二元布尔运算由于涉及短路求值，其定义是最复杂的。*)\n\nDefinition and_sem_nrm\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1,\n    D1 s i1 /\\\n    (SC_and_compute_nrm i1 i \\/\n     NonSC_and i1 /\\\n     exists i2,\n       D2 s i2 /\\ NonSC_compute_nrm i2 i).\n\nDefinition and_sem_err\n             (D1: state -> int64 -> Prop)\n             (D2: state -> Prop)\n             (s: state): Prop :=\n  exists i1,\n    D1 s i1 /\\ NonSC_and i1 /\\ D2 s.\n\nDefinition and_sem (D1 D2: EDenote): EDenote :=\n  {|\n    nrm := and_sem_nrm D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ and_sem_err D1.(nrm) D2.(err);\n  |}.\n\nDefinition or_sem_nrm\n             (D1 D2: state -> int64 -> Prop)\n             (s: state)\n             (i: int64): Prop :=\n  exists i1,\n    D1 s i1 /\\\n    (SC_or_compute_nrm i1 i \\/\n     NonSC_or i1 /\\\n     exists i2,\n       D2 s i2 /\\ NonSC_compute_nrm i2 i).\n\nDefinition or_sem_err\n             (D1: state -> int64 -> Prop)\n             (D2: state -> Prop)\n             (s: state): Prop :=\n  exists i1,\n    D1 s i1 /\\ NonSC_or i1 /\\ D2 s.\n\nDefinition or_sem (D1 D2: EDenote): EDenote :=\n  {|\n    nrm := or_sem_nrm D1.(nrm) D2.(nrm);\n    err := D1.(err) ∪ or_sem_err D1.(nrm) D2.(err);\n  |}.\n\n(** 最终我们可以将所有一元运算与二元运算的语义汇总起来：*)\n\nDefinition unop_sem (op: unop) (D: EDenote): EDenote :=\n  match op with\n  | ONeg => neg_sem D\n  | ONot => not_sem D\n  end.\n\nDefinition binop_sem (op: binop) (D1 D2: EDenote): EDenote :=\n  match op with\n  | OOr => or_sem D1 D2\n  | OAnd => and_sem D1 D2\n  | OLt => cmp_sem Clt D1 D2\n  | OLe => cmp_sem Cle D1 D2\n  | OGt => cmp_sem Cgt D1 D2\n  | OGe => cmp_sem Cge D1 D2\n  | OEq => cmp_sem Ceq D1 D2\n  | ONe => cmp_sem Cne D1 D2\n  | OPlus => arith_sem1 Z.add D1 D2\n  | OMinus => arith_sem1 Z.sub D1 D2\n  | OMul => arith_sem1 Z.mul D1 D2\n  | ODiv => arith_sem2 Int64.divs D1 D2\n  | OMod => arith_sem2 Int64.mods D1 D2\n  end.\n\n(** 最后补上常数和变量的语义即可得到完整的表达式语义。*)\n\nDefinition const_sem (n: Z): EDenote :=\n  {|\n    nrm := fun s i =>\n             i = Int64.repr n /\\\n             Int64.min_signed <= n <= Int64.max_signed;\n    err := fun s =>\n             n < Int64.min_signed \\/\n             n > Int64.max_signed;\n  |}.\n\nDefinition var_sem (X: var_name): EDenote :=\n  {|\n    nrm := fun s i => s X = Vint i;\n    err := fun s => s X = Vuninit;\n  |}.\n\nFixpoint eval_expr (e: expr): EDenote :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EBinop op e1 e2 =>\n      binop_sem op (eval_expr e1) (eval_expr e2)\n  | EUnop op e1 =>\n      unop_sem op (eval_expr e1)\n  end.\n\n(** 基于表达式的指称语义，可以证明一些简单性质。*)\n\nLemma const_plus_const_nrm:\n  forall (n m: Z) (s: state) (i: int64),\n    (eval_expr (EBinop OPlus (EConst n) (EConst m))).(nrm) s i ->\n    (eval_expr (EConst (n + m))).(nrm) s i.\nProof.\n  intros.\n  simpl in H; unfold arith_sem1_nrm, arith_compute1_nrm in H.\n  simpl.\n  destruct H as [i1 [i2 [? [? [? ?] ] ] ] ].\n  destruct H, H0.\n  rewrite H1.\n  apply Int64.signed_repr in H3.\n  apply Int64.signed_repr in H4.\n  rewrite <- H in H3.\n  rewrite <- H0 in H4.\n  rewrite <- H3, <- H4.\n  tauto.\nQed.\n\n(** 下面定义程序语句的语义。程序语句的语义包含三种情况：正常运行终止、运行出错以\n    及安全运行但不终止。*)\n\nModule CDenote.\n\nRecord CDenote: Type := {\n  nrm: state -> state -> Prop;\n  err: state -> Prop;\n  inf: state -> Prop\n}.\n\nEnd CDenote.\n\n(** 以下为_[Notation]_声明，细节可以忽略。*)\n\nImport CDenote.\n\nNotation \"x '.(nrm)'\" := (CDenote.nrm x)\n  (at level 1, only printing).\n\nNotation \"x '.(err)'\" := (CDenote.err x)\n  (at level 1, only printing).\n\nNotation \"x '.(inf)'\" := (CDenote.inf x)\n  (at level 1).\n\nLtac any_nrm x ::=\n  match type of x with\n  | EDenote => exact (EDenote.nrm x)\n  | CDenote => exact (CDenote.nrm x)\n  end.\n\nLtac any_err x ::=\n  match type of x with\n  | EDenote => exact (EDenote.err x)\n  | CDenote => exact (CDenote.err x)\n  end.\n\n(** 空语句的语义：*)\n\nDefinition skip_sem: CDenote :=\n  {|\n    nrm := Rels.id;\n    err := ∅;\n    inf := ∅;\n  |}.\n\n(** 赋值语句的语义：*)\n\nDefinition asgn_sem\n             (X: var_name)\n             (D: EDenote): CDenote :=\n  {|\n    nrm := fun s1 s2 =>\n      exists i,\n        D.(nrm) s1 i /\\ s2 X = Vint i /\\\n        (forall Y, X <> Y -> s2 Y = s1 Y);\n    err := D.(err);\n    inf := ∅;\n  |}.\n\n(** 顺序执行语句的语义：*)\n\nDefinition seq_sem (D1 D2: CDenote): CDenote :=\n  {|\n    nrm := D1.(nrm) ∘ D2.(nrm);\n    err := D1.(err) ∪ (D1.(nrm) ∘ D2.(err));\n    inf := D1.(inf) ∪ (D1.(nrm) ∘ D2.(inf));\n  |}.\n\n(** 条件分支语句的语义：*)\n\nDefinition test_true (D: EDenote):\n  state -> state -> Prop :=\n  Rels.test\n    (fun s =>\n       exists i, D.(nrm) s i /\\ Int64.signed i <> 0).\n\nDefinition test_false (D: EDenote):\n  state -> state -> Prop :=\n  Rels.test (fun s => D.(nrm) s (Int64.repr 0)).\n\nDefinition if_sem\n             (D0: EDenote)\n             (D1 D2: CDenote): CDenote :=\n  {|\n    nrm := (test_true D0 ∘ D1.(nrm)) ∪\n           (test_false D0 ∘ D2.(nrm));\n    err := D0.(err) ∪\n           (test_true D0 ∘ D1.(err)) ∪\n           (test_false D0 ∘ D2.(err));\n    inf := (test_true D0 ∘ D1.(inf)) ∪\n           (test_false D0 ∘ D2.(inf))\n  |}.\n\n\n(** While循环语句不终止的情况分为两种：每次执行循环体程序都正常运行终止但是\n    由于一直满足循环条件将执行无穷多次循环体；某次执行循环体时，执行循环体的过程\n    本身不终止。  \n\n\n    下面定义的_[is_inf]_描述了以下关于程序状态集合_[X]_的性质：从集\n    合_[X]_中的任意一个状态出发，计算循环条件的结果都为真（也不会计算出错），进\n    入循环体执行后，要么正常运行终止并且终止于另一个（可以是同一个）_[X]_集合中\n    的状态上，要么循环体运行不终止。*)\n\nDefinition is_inf\n             (D0: EDenote)\n             (D1: CDenote)\n             (X: state -> Prop): Prop :=\n  X ⊆ test_true D0 ∘ ((D1.(nrm) ∘ X) ∪ D1.(inf)).\n\n(** 这样一来，循环不终止的情况可以定义为所有满足_[is_inf]_性质的集合的并集。*)\n\nDefinition while_sem\n             (D0: EDenote)\n             (D1: CDenote): CDenote :=\n  {|\n    nrm := BW_LFix\n             (fun X =>\n                test_true D0 ∘ D1.(nrm) ∘ X ∪\n                test_false D0);\n    err := BW_LFix\n             (fun X =>\n                test_true D0 ∘ D1.(nrm) ∘ X ∪\n                test_true D0 ∘ D1.(err) ∪ D0.(err));\n    inf := Sets.general_union (is_inf D0 D1);\n  |}.\n\n(** 程序语句的语义可以最后表示成下面递归函数。*)\n\nFixpoint eval_com (c: com): CDenote :=\n  match c with\n  | CSkip =>\n      skip_sem\n  | CAsgn X e =>\n      asgn_sem X (eval_expr e)\n  | CSeq c1 c2 =>\n      seq_sem (eval_com c1) (eval_com c2)\n  | CIf e c1 c2 =>\n      if_sem (eval_expr e) (eval_com c1) (eval_com c2)\n  | CWhile e c1 =>\n      while_sem (eval_expr e) (eval_com c1)\n  end.\n\n\n\n\nEnd DntSem_While1.\n\n(** * Knaster-Tarski不动点定理 *)\n\n\nModule KTFix.\nImport BWFix.\n\n(** 下面是这一不动点定理的Coq证明。*)\n\nLocal Open Scope order_scope.\n\n(** 首先定义完备格。*)\n\nDefinition is_lub {A: Type} {RA: Order A} (X: A -> Prop) (a: A): Prop :=\n  is_ub X a /\\ is_lb (is_ub X) a.\n\nDefinition is_glb {A: Type} {RA: Order A} (X: A -> Prop) (a: A): Prop :=\n  is_lb X a /\\ is_ub (is_lb X) a.\n\nClass Lub (A: Type): Type :=\n  lub: (A -> Prop) -> A.\n\nClass Glb (A: Type): Type :=\n  glb: (A -> Prop) -> A.\n\nClass LubProperty (A: Type) {RA: Order A} {LubA: Lub A}: Prop :=\n  lub_is_lub: forall X: A -> Prop, is_lub X (lub X).\n\nClass GlbProperty (A: Type) {RA: Order A} {GlbA: Glb A}: Prop :=\n  glb_is_glb: forall X: A -> Prop, is_glb X (glb X).\n\nLemma glb_sound: forall {A: Type} `{GlbPA: GlbProperty A},\n  forall X: A -> Prop, is_lb X (glb X).\nProof. intros. destruct (glb_is_glb X). tauto. Qed.\n\nLemma glb_tight: forall {A: Type} `{GlbPA: GlbProperty A},\n  forall X: A -> Prop, is_ub (is_lb X) (glb X).\nProof. intros. destruct (glb_is_glb X). tauto. Qed.\n\nClass CompleteLattice_Setoid (A: Type)\n        {RA: Order A} {EA: Equiv A} {LubA: Lub A} {glbA: Glb A}: Prop :=\n{\n  CL_PartialOrder:> PartialOrder_Setoid A;\n  CL_LubP:> LubProperty A;\n  CL_GlbP:> GlbProperty A\n}.\n\n(** 下面基于完备格与单调函数的定义证明Knaster-Tarski不动点定理。*)\n\nDefinition KT_LFix\n             {A: Type}\n             `{CLA: CompleteLattice_Setoid A}\n             (f: A -> A): A :=\n  glb (fun a => f a <= a).\n\nLemma KT_LFix_is_pre_fix:\n  forall\n    {A: Type}\n    `{CLA: CompleteLattice_Setoid A}\n    {EquivA: Equivalence equiv}\n    (f: A -> A),\n    mono f ->\n    f (KT_LFix f) <= KT_LFix f.\nProof.\n  intros.\n  unfold KT_LFix.\n  apply glb_tight; unfold is_lb; intros.\n  rewrite <- H0.\n  apply H.\n  apply glb_sound.\n  apply H0.\nQed.\n\nLemma KT_LFix_is_fix:\n  forall\n    {A: Type}\n    `{CLA: CompleteLattice_Setoid A}\n    {EquivA: Equivalence equiv}\n    (f: A -> A),\n    mono f ->\n    f (KT_LFix f) == KT_LFix f.\nProof.\n  intros.\n  pose proof KT_LFix_is_pre_fix f H.\n  apply antisymmetricity_setoid.\n  + apply H0.\n  + apply glb_sound.\n    apply H, H0.\nQed.\n\nLemma KT_LFix_is_least_fix:\n  forall\n    {A: Type}\n    `{CLA: CompleteLattice_Setoid A}\n    {EquivA: Equivalence equiv}\n    (f: A -> A)\n    (a: A),\n    mono f ->\n    f a == a ->\n    KT_LFix f <= a.\nProof.\n  intros.\n  apply glb_sound.\n  apply reflexivity_setoid.\n  apply H0.\nQed.\n\nLocal Close Scope order_scope.\n\nEnd KTFix.\n"
        }
    ]
}