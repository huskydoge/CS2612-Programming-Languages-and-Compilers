{
    "sourceFile": "DenotationalSemantics.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1697781617992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1697781617992,
            "name": "Commit-0",
            "content": "Require Import Coq.Logic.Classical_Prop.\nRequire Import Coq.Strings.String.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Psatz.\nRequire Import Coq.Classes.Morphisms.\nRequire Import SetsClass.SetsClass. Import SetsNotation.\nRequire Import PL.SyntaxInCoq.\nLocal Open Scope string.\nLocal Open Scope Z.\nLocal Open Scope sets.\n\n(** * 简单表达式的指称语义 *)\n\nModule DntSem_SimpleWhile1.\nImport Lang_SimpleWhile.\n\n\n\n(** 指称语义是一种定义程序行为的方式。在极简的SimpleWhile语言中，整数类型表达式\n    中只有整数常量、变量、加法、减法与乘法运算。  \n\n    我们约定其中整数变量的值、整数运算的结果都是没有范围限制的。基于这一约定，我\n    们可以如下定义表达式_[e]_在程序状态_[st]_上的值。\n\n    首先定义程序状态集合：*)\n\nDefinition state: Type := var_name -> Z.\n\n(** 下面使用Coq递归函数定义整数类型表达式的行为。*)\n\nFixpoint eval_expr_int (e: expr_int) (s: state) : Z :=\n  match e with\n  | EConst n => n\n  | EVar X => s X\n  | EAdd e1 e2 => eval_expr_int e1 s + eval_expr_int e2 s\n  | ESub e1 e2 => eval_expr_int e1 s - eval_expr_int e2 s\n  | EMul e1 e2 => eval_expr_int e1 s * eval_expr_int e2 s\n  end.\n\n(** 下面是两个具体的例子。*)\n\nExample eval_example1: forall (s: state),\n  s \"x\" = 1 ->\n  s \"y\" = 2 ->\n  eval_expr_int [[\"x\" + \"y\"]] s = 3.\nProof. intros. simpl. rewrite H, H0. reflexivity. Qed.\n\nExample eval_example2: forall (s: state),\n  s \"x\" = 1 ->\n  s \"y\" = 2 ->\n  eval_expr_int [[\"x\" * \"y\" + 1]] s = 3.\nProof. intros. simpl. rewrite H, H0. reflexivity. Qed.\n\n\n\n\n\n\n(** * 行为等价 *)\n\n(** 基于整数类型表达式的语义定义_[eval_expr_int]_，我们可以定义整数类型表达式之\n    间的行为等价（亦称语义等价）：两个表达式_[e1]_与_[e2]_是等价的当且仅当它们在\n    任何程序状态上的求值结果都相同。*)\n\nDefinition expr_int_equiv (e1 e2: expr_int): Prop :=\n  forall st, eval_expr_int e1 st = eval_expr_int e2 st.\n\nNotation \"e1 '~=~' e2\" := (expr_int_equiv e1 e2)\n  (at level 69, no associativity).\n\n(** 下面是一些表达式语义等价的例子。 *)\n\nExample expr_int_equiv_sample:\n  [[\"x\" + \"x\"]] ~=~ [[\"x\" * 2]].\nProof.\n  intros.\n  unfold expr_int_equiv.\n  (** 上面的_[unfold]_指令表示展开一项定义，一般用于非递归的定义。*)\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma zero_plus_equiv: forall (a: expr_int),\n  [[0 + a]] ~=~ a.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma plus_zero_equiv: forall (a: expr_int),\n  [[a + 0]] ~=~ a.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma minus_zero_equiv: forall (a: expr_int),\n  [[a - 0]] ~=~ a.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma zero_mult_equiv: forall (a: expr_int),\n  [[0 * a]] ~=~ 0.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma mult_zero_equiv: forall (a: expr_int),\n  [[a * 0]] ~=~ 0.\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  lia.\nQed.\n\nLemma const_plus_const: forall n m: Z,\n  [[EConst n + EConst m]] ~=~ EConst (n + m).\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\nLemma const_minus_const: forall n m: Z,\n  [[EConst n - EConst m]] ~=~ EConst (n - m).\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\nLemma const_mult_const: forall n m: Z,\n  [[EConst n * EConst m]] ~=~ EConst (n * m).\nProof.\n  intros.\n  unfold expr_int_equiv.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\n(** 下面定义一种简单的语法变换---常量折叠---并证明其保持语义等价性。所谓常量折叠\n    指的是将只包含常量而不包含变量的表达式替换成为这个表达式的值。*)\n\nFixpoint fold_constants (e : expr_int) : expr_int :=\n  match e with\n  | EConst n    => EConst n\n  | EVar x      => EVar x\n  | EAdd e1 e2  =>\n      match fold_constants e1, fold_constants e2 with\n      | EConst n1, EConst n2 => EConst (n1 + n2)\n      | _, _ => EAdd (fold_constants e1) (fold_constants e2)\n      end\n  | ESub e1 e2 =>\n      match fold_constants e1, fold_constants e2 with\n      | EConst n1, EConst n2 => EConst (n1 - n2)\n      | _, _ => ESub (fold_constants e1) (fold_constants e2)\n    end\n  | EMul e1 e2 =>\n      match fold_constants e1, fold_constants e2 with\n      | EConst n1, EConst n2 => EConst (n1 * n2)\n      | _, _ => EMul (fold_constants e1) (fold_constants e2)\n    end\n  end.\n\n(** 这里我们可以看到，Coq中_[match]_的使用是非常灵活的。(1) 我们不仅可以对一个变\n    量的值做分类讨论，还可以对一个复杂的Coq式子的取值做分类讨论；(2) 我们可以对\n    多个值同时做分类讨论；(3) 我们可以用下划线表示_[match]_的缺省情况。下面是两\n    个例子：*)\n\nExample fold_constants_ex1:\n    fold_constants [[(1 + 2) * \"k\"]] = [[3 * \"k\"]].\nProof. intros. reflexivity. Qed.\n\n(** 注意，根据我们的定义，_[fold_constants]_并不会将_[0 + \"y\"]_中的_[0]_消去。*)\n\nExample fold_expr_int_ex2 :\n  fold_constants [[\"x\" - ((0 * 6) + \"y\")]] = [[\"x\" - (0 + \"y\")]].\nProof. intros. reflexivity. Qed.\n\n(** 下面我们在Coq中证明，_[fold_constants]_保持表达式行为不变。 *)\n\nTheorem fold_constants_sound : forall a,\n  fold_constants a ~=~ a.\nProof.\n  unfold expr_int_equiv. intros.\n  induction a.\n  (** 常量的情况 *)\n  + simpl.\n    reflexivity.\n  (** 变量的情况 *)\n  + simpl.\n    reflexivity.\n  (** 加号的情况 *)\n  + simpl.\n    destruct (fold_constants a1), (fold_constants a2);\n    rewrite <- IHa1, <- IHa2;\n    reflexivity.\n  (** 减号的情况 *)\n  + simpl.\n    destruct (fold_constants a1), (fold_constants a2);\n    rewrite <- IHa1, <- IHa2;\n    reflexivity.\n  (** 乘号的情况 *)\n  + simpl.\n    destruct (fold_constants a1), (fold_constants a2);\n    rewrite <- IHa1, <- IHa2;\n    reflexivity.\nQed.\n\nEnd DntSem_SimpleWhile1.\n\n(** * 利用高阶函数定义指称语义 *)\n\nModule DntSem_SimpleWhile2.\nImport Lang_SimpleWhile.\n\nDefinition state: Type := var_name -> Z.\n\nDefinition add_sem (D1 D2: state -> Z) (s: state): Z :=\n  D1 s + D2 s.\n\nDefinition sub_sem (D1 D2: state -> Z) (s: state): Z :=\n  D1 s - D2 s.\n\nDefinition mul_sem (D1 D2: state -> Z) (s: state): Z :=\n  D1 s * D2 s.\n\n(** 下面是用于类型查询的_[Check]_指令。*)\n\nCheck add_sem.\n\n(** 可以看到_[add_sem]_的类型是_[(state -> Z) -> (state -> Z) -> state -> Z]_，\n    这既可以被看做一个三元函数，也可以被看做一个二元函数，即函数之间的二元函数。  \n\n    基于上面高阶函数，可以重新定义表达式的指称语义。*)\n\nDefinition const_sem (n: Z) (s: state): Z := n.\nDefinition var_sem (X: var_name) (s: state): Z := s X.\n\nFixpoint eval_expr_int (e: expr_int): state -> Z :=\n  match e with\n  | EConst n =>\n      const_sem n\n  | EVar X =>\n      var_sem X\n  | EAdd e1 e2 =>\n      add_sem (eval_expr_int e1) (eval_expr_int e2)\n  | ESub e1 e2 =>\n      sub_sem (eval_expr_int e1) (eval_expr_int e2)\n  | EMul e1 e2 =>\n      mul_sem (eval_expr_int e1) (eval_expr_int e2)\n  end.\n\nEnd DntSem_SimpleWhile2.\n\n(** * 布尔表达式语义 *)\n\nModule DntSem_SimpleWhile3.\nImport Lang_SimpleWhile DntSem_SimpleWhile2.\n\n(** 在Coq中可以如下定义：*)\n\nDefinition true_sem (s: state): bool := true.\n\nDefinition false_sem (s: state): bool := false.\n\nDefinition lt_sem (D1 D2: state -> Z) s: bool :=\n  Z.ltb (D1 s) (D2 s).\n\nDefinition and_sem (D1 D2: state -> bool) s: bool :=\n  andb (D1 s) (D2 s).\n\nDefinition not_sem (D: state -> bool) s: bool :=\n  negb (D s).\n\nFixpoint eval_expr_bool (e: expr_bool): state -> bool :=\n  match e with\n  | ETrue =>\n      true_sem\n  | EFalse =>\n      false_sem\n  | ELt e1 e2 =>\n      lt_sem (eval_expr_int e1) (eval_expr_int e2)\n  | EAnd e1 e2 =>\n      and_sem (eval_expr_bool e1) (eval_expr_bool e2)\n  | ENot e1 =>\n      not_sem (eval_expr_bool e1)\n  end.\n\nEnd DntSem_SimpleWhile3.\n\n\n\n\n(** * Coq中的集合与关系 *)\n\n\n(** 本课程提供的SetsClass库中提供了有关集合的一系列定义。例如：\n\n    - 空集：用 _[∅]_ 或者一堆方括号表示，定义为_[Sets.empty]_；\n\n    - 单元集：用一对方括号表示，定义为_[Sets.singleton]_；\n\n    - 并集：用_[∪]_表示，定义为_[Sets.union]_；\n\n    - 交集：用_[∩]_表示，定义为_[Sets.intersect]_；\n\n    - 一列集合的并：用_[⋃]_表示，定义为_[Sets.indexed_union]_；\n\n    - 一列集合的交：用_[⋂]_表示，定义为_[Sets.indexed_intersect]_；\n\n    - 集合相等：用_[==]_表示，定义为_[Sets.equiv]_；\n\n    - 元素与集合关系：用_[∈]_表示，定义为_[Sets.In]_；\n\n    - 子集关系：用_[⊆]_表示，定义为_[Sets.included]_；\n\n    - 二元关系的连接：用_[∘]_表示，定义为_[Rels.concat]_；\n\n    - 等同关系：定义为_[Rels.id]_；\n\n    - 测试关系：定义为_[Rels.test]_。\n\n    在CoqIDE中，你可以利用CoqIDE对于unicode的支持打出特殊字符：\n\n    - 首先，在打出特殊字符的latex表示法；\n\n    - 再按shift+空格键；\n\n    - latex表示法就自动转化为了相应的特殊字符。\n\n    例如，如果你需要打出符号_[∈]_，请先在输入框中输入_[\\in]_，当光标紧跟在_[n]_\n    这个字符之后的时候，按shift+空格键即可。例如，下面是两个关于集合的命题：*)\n\nCheck forall A (X: A -> Prop), X ∪ ∅ == X.\n\nCheck forall A B (X Y: A -> B -> Prop), X ∪ Y ⊆ X.\n\nModule SetsProofDemo.\n\n(** 由于集合以及集合间的运算是基于Coq中的命题进行定义的，集合相关性质的证明也可\n    以规约为与命题有关的逻辑证明。例如，我们想要证明，交集运算具有交换律：*)\n\nLemma Sets_intersect_comm: forall A (X Y: A -> Prop),\n  X ∩ Y == Y ∩ X.\nProof.\n  intros.\n  (** 下面一条命令_[Sets_unfold]_是SetsClass库提供的自动证明指令，它可以将有关\n      集合的性质转化为有关命题的性质。*)\n  Sets_unfold.\n  (** 原本要证明的关于交集的性质现在就转化为了：\n        _[forall a : A, a ∈ X /\\ a ∈ Y <-> a ∈ Y /\\ a ∈ X]_\n      这个关于逻辑的命题在Coq中是容易证明的。*)\n  intros.\n  tauto.\nQed.\n\n(** 下面是一条关于并集运算的性质。*)\n\nLemma Sets_included_union1: forall A (X Y: A -> Prop),\n  X ⊆ X ∪ Y.\nProof.\n  intros.\n  Sets_unfold.\n  (** 经过转化，要证明的结论是：_[forall a : A, a ∈ X -> a ∈ X \\/ a ∈ Y]_。*)\n  intros.\n  tauto.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n\n(** 下面是一条关于二元关系复合的性质。转化后得到的命题要复杂一些，请在Coq中证明这个关于\n    逻辑的命题。*)\n\nLemma Rels_concat_assoc: forall A (X Y Z: A -> A -> Prop),\n  (X ∘ Y) ∘ Z == X ∘ (Y ∘ Z).\nProof.\n  intros.\n  Sets_unfold.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\nEnd SetsProofDemo.\n\n(** SetsClass库中提供了一系列有关集合运算的性质的证明。未来大家在证明中既可以使用\n    _[Sets_unfold]_将关于集合运算的命题转化为关于逻辑的命题，也可以直接使用下面这些性\n    质完成证明。  \n\n      Sets_equiv_Sets_included:\n    forall x y, x == y <-> x ⊆ y /\\ y ⊆ x;\n  Sets_empty_included:\n    forall x, ∅ ⊆ x;\n  Sets_included_full:\n    forall x, x ⊆ Sets.full;\n  Sets_intersect_included1:\n    forall x y, x ∩ y ⊆ x;\n  Sets_intersect_included2:\n    forall x y, x ∩ y ⊆ y;\n  Sets_included_intersect:\n    forall x y z, x ⊆ y -> x ⊆ z -> x ⊆ y ∩ z;\n  Sets_included_union1:\n    forall x y, x ⊆ x ∪ y;\n  Sets_included_union2:\n    forall x y, y ⊆ x ∪ y;\n  Sets_union_included_strong2:\n    forall x y z u,\n       x ∩ u ⊆ z -> y ∩ u ⊆ z -> (x ∪ y) ∩ u ⊆ z;\n  \n      Sets_included_indexed_union:\n    forall xs n, xs n ⊆ ⋃ xs;\n  Sets_indexed_union_included:\n    forall xs y, (forall n, xs n ⊆ y) -> ⋃ xs ⊆ y;\n  Sets_indexed_intersect_included:\n    forall xs n, ⋂ xs ⊆ xs n;\n  Sets_included_indexed_intersect:\n    forall xs y, (forall n : nat, y ⊆ xs n) -> y ⊆ ⋂ xs;\n  \n      Rels_concat_union_distr_r:\n    forall x1 x2 y,\n      (x1 ∪ x2) ∘ y == (x1 ∘ y) ∪ (x2 ∘ y);\n  Rels_concat_union_distr_l:\n    forall x y1 y2,\n      x ∘ (y1 ∪ y2) == (x ∘ y1) ∪ (x ∘ y2);\n  Rels_concat_mono:\n    forall x1 x2,\n      x1 ⊆ x2 ->\n      forall y1 y2,\n        y1 ⊆ y2 ->\n        x1 ∘ y1 ⊆ x2 ∘ y2;\n  Rels_concat_assoc:\n    forall x y z,\n      (x ∘ y) ∘ z == x ∘ (y ∘ z);\n  Rels_concat_id_l:\n    forall x, Rels.id ∘ x == x;\n  Rels_concat_id_r:\n    forall x, x ∘ Rels.id == x;  \n\n    由于上面提到的集合与关系运算都能保持集合相等，也都能保持集合包含关系，因此\n    SetsClass库支持其用户使用_[rewrite]_指令处理集合之间的相等关系与包含关系。下面是\n    两个典型的例子*)\n\nFact sets_ex1:\n  forall (A: Type) (R1 R2 R3 R4: A -> A -> Prop),\n    R1 ∘ (R2 ∘ (R3 ∘ R4)) == ((R1 ∘ R2) ∘ R3) ∘ R4.\nProof.\n  intros.\n  rewrite Rels_concat_assoc.\n  rewrite Rels_concat_assoc.\n  reflexivity.\nQed.\n\nFact sets_ex2:\n  forall (A: Type) (R1 R2 R3 R4: A -> A -> Prop),\n    R1 ⊆ R2 ->\n    R1 ∘ R3 ∪ R4 ⊆ R2 ∘ R3 ∪ R4.\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.\n\n(** * 在Coq中定义程序语句的语义 *)\n\nModule DntSem_SimpleWhile4.\nImport Lang_SimpleWhile\n       LangTrans\n       DntSem_SimpleWhile2\n       DntSem_SimpleWhile3.\n\n(** 下面在Coq中写出程序语句的指称语义。*)\n\nDefinition skip_sem: state -> state -> Prop :=\n  Rels.id.\n\nDefinition asgn_sem\n             (X: var_name)\n             (D: state -> Z)\n             (st1 st2: state): Prop :=\n  st2 X = D st1 /\\\n  forall Y, X <> Y -> st2 Y = st1 Y.\n\nDefinition seq_sem\n             (D1 D2: state -> state -> Prop):\n  state -> state -> Prop :=\n  D1 ∘ D2.\n\nDefinition test_true\n             (D: state -> bool):\n  state -> state -> Prop :=\n  Rels.test (fun st => D st = true).\n\nDefinition test_false\n             (D: state -> bool):\n  state -> state -> Prop :=\n  Rels.test (fun st => D st = false).\n\nDefinition if_sem\n             (D0: state -> bool)\n             (D1 D2: state -> state -> Prop):\n  state -> state -> Prop :=\n  (test_true D0 ∘ D1) ∪ (test_false D0 ∘ D2).\n\nFixpoint iterLB\n           (D0: state -> bool)\n           (D1: state -> state -> Prop)\n           (n: nat):\n  state -> state -> Prop :=\n  match n with\n  | O => test_false D0\n  | S n0 => test_true D0 ∘ D1 ∘ iterLB D0 D1 n0\n  end.\n\nModule WhileSem1.\n\nDefinition while_sem\n             (D0: state -> bool)\n             (D1: state -> state -> Prop):\n  state -> state -> Prop :=\n  ⋃ (iterLB D0 D1).\n\nEnd WhileSem1.\n\nFixpoint boundedLB\n           (D0: state -> bool)\n           (D1: state -> state -> Prop)\n           (n: nat):\n  state -> state -> Prop :=\n  match n with\n  | O => ∅\n  | S n0 =>\n      (test_true D0 ∘ D1 ∘ boundedLB D0 D1 n0) ∪\n      (test_false D0)\n  end.\n\nModule WhileSem2.\n\nDefinition while_sem\n             (D0: state -> bool)\n             (D1: state -> state -> Prop):\n  state -> state -> Prop :=\n  ⋃ (boundedLB D0 D1).\n\nEnd WhileSem2.\n\n(** 我们选择第二种定义。*)\n\nExport WhileSem2.\n\n(** 下面是程序语句指称语义的递归定义。*)\n\nFixpoint eval_com (c: com): state -> state -> Prop :=\n  match c with\n  | CSkip =>\n      skip_sem\n  | CAsgn X e =>\n      asgn_sem X (eval_expr_int e)\n  | CSeq c1 c2 =>\n      seq_sem (eval_com c1) (eval_com c2)\n  | CIf e c1 c2 =>\n      if_sem (eval_expr_bool e) (eval_com c1) (eval_com c2)\n  | CWhile e c1 =>\n      while_sem (eval_expr_bool e) (eval_com c1)\n  end.\n\n(** 基于上面定义，可以证明一些简单的程序性质。*)\n\nExample inc_x_fact: forall s1 s2 n,\n  (s1, s2) ∈ eval_com (CAsgn \"x\" [[\"x\" + 1]]) ->\n  s1 \"x\" = n ->\n  s2 \"x\" = n + 1.\nProof.\n  intros.\n  simpl in H.\n  unfold asgn_sem, add_sem, var_sem, const_sem in H.\n  lia.\nQed.\n\n(** 更多关于程序行为的有用性质可以使用集合与关系的运算性质完成证明，_[seq_skip]_与\n    _[skip_seq]_表明了删除顺序执行中多余的空语句不改变程序行为。*)\n\nLemma seq_skip: forall c,\n  eval_com (CSeq c CSkip) == eval_com c.\nProof.\n  intros.\n  simpl.\n  unfold seq_sem, skip_sem.\n  apply Rels_concat_id_r.\nQed.\n\nLemma skip_seq: forall c,\n  eval_com (CSeq CSkip c) == eval_com c.\nProof.\n  intros.\n  simpl.\n  unfold seq_sem, skip_sem.\n  apply Rels_concat_id_l.\nQed.\n\n(** 类似的，_[seq_assoc]_表明顺序执行的结合顺序是不影响程序行为的，因此，所有实际的编\n    程中都不需要在程序开发的过程中额外标明顺序执行的结合方式。*)\n\nLemma seq_assoc: forall c1 c2 c3,\n  eval_com (CSeq (CSeq c1 c2) c3) ==\n  eval_com (CSeq c1 (CSeq c2 c3)).\nProof.\n  intros.\n  simpl.\n  unfold seq_sem.\n  apply Rels_concat_assoc.\nQed.\n\n(** 下面的_[while_sem_congr2]_说的则是：如果对循环体做行为等价变换，那么整个循环的行\n    为也不变。*)\n\nLemma while_sem_congr2: forall D1 D2 D2',\n  D2 == D2' ->\n  while_sem D1 D2 == while_sem D1 D2'.\nProof.\n  intros.\n  unfold while_sem.\n  apply Sets_indexed_union_congr.\n  intros n.\n  induction n; simpl.\n  + reflexivity.\n  + rewrite IHn.\n    rewrite H.\n    reflexivity.\nQed.\n\n(** 以下是证明自动化相关的设定。可以跳过。 *)\n\nInstance seq_sem_congr:\n  Proper (Sets.equiv ==> Sets.equiv ==> Sets.equiv) seq_sem.\nProof.\n  unfold Proper, respectful; intros.\n  unfold seq_sem; rewrite H, H0.\n  reflexivity.\nQed.\n\nInstance if_sem_congr: forall D0,\n  Proper (Sets.equiv ==> Sets.equiv ==> Sets.equiv) (if_sem D0).\nProof.\n  unfold Proper, respectful; intros.\n  unfold if_sem; rewrite H, H0.\n  reflexivity.\nQed.\n\nInstance while_sem_congr: forall D0,\n  Proper (Sets.equiv ==> Sets.equiv) (while_sem D0).\nProof.\n  unfold Proper, respectful; intros.\n  apply while_sem_congr2, H.\nQed.\n\n(** 下面我们证明，我们先前定义的_[remove_skip]_变换保持程序行为不变。*)\n\nTheorem remove_skip_sound: forall c,\n  eval_com (remove_skip c) == eval_com c.\nProof.\n  intros.\n  induction c; simpl.\n  + reflexivity.\n  + reflexivity.\n  + rewrite <- IHc1, <- IHc2.\n    destruct (remove_skip c1), (remove_skip c2);\n      simpl; unfold skip_sem, seq_sem;\n      rewrite ? Rels_concat_id_l, ? Rels_concat_id_r;\n      reflexivity.\n  + rewrite IHc1, IHc2.\n    reflexivity.\n  + apply while_sem_congr2.\n    apply IHc.\nQed.\n\n\n\n(** 前面提到，while循环语句的行为也可以描述为：只要循环条件成立，就先执行循环体再重新执\n    行循环。我们可以证明，我们目前定义的程序语义符合这一性质。*)\n\nLemma while_sem_unroll1: forall D0 D1,\n  while_sem D0 D1 ==\n  test_true D0 ∘ D1 ∘ while_sem D0 D1 ∪ test_false D0.\nProof.\n  intros.\n  simpl.\n  unfold while_sem.\n  apply Sets_equiv_Sets_included; split.\n  + apply Sets_indexed_union_included.\n    intros.\n    destruct n as [| n0]; simpl boundedLB.\n    - apply Sets_empty_included.\n    - rewrite <- (Sets_included_indexed_union _ _ n0).\n      reflexivity.\n  + apply Sets_union_included.\n    - rewrite Rels_concat_indexed_union_distr_l.\n      rewrite Rels_concat_indexed_union_distr_l.\n      apply Sets_indexed_union_included; intros.\n      rewrite <- (Sets_included_indexed_union _ _ (S n)).\n      simpl.\n      apply Sets_included_union1.\n    - rewrite <- (Sets_included_indexed_union _ _ (S O)).\n      simpl boundedLB.\n      apply Sets_included_union2.\nQed.\n\n\n\n\nEnd DntSem_SimpleWhile4.\n\n\n(** * Coq中证明并应用Bourbaki-Witt不动点定理 *)\n\nModule DntSem_SimpleWhile5.\nImport Lang_SimpleWhile\n       DntSem_SimpleWhile2\n       DntSem_SimpleWhile3\n       DntSem_SimpleWhile4.\n\n\n(** 下面我们将在Coq中证明Bourbaki-Witt不动点定理。在Bourbaki-Witt不动点定理中，\n    我们需要证明满足某些特定条件（例如偏序、完备偏序等）的二元关系的一些性质。在\n    Coq中，我们当然可以通过_[R: A -> A -> Prop]_来探讨二元关系_[R]_的性质。然而\n    Coq中并不能给这样的变量设定Notation符号，例如，我们希望用_[a <= b]_来表示\n    _[R a b]_，因此我们选择使用Coq的_[Class]_来帮助我们完成定义。  \n\n    下面这一定义说的是：_[Order]_是一类数学对象，任给一个类型_[A]_，_[Order A]_\n    也是一个类型，这个类型的每个元素都有一个域，这个域的名称是_[order_rel]_，它\n    的类型是_[A -> A -> Prop]_，即_[A]_上的二元关系。*)\n\nClass Order (A: Type): Type :=\n  order_rel: A -> A -> Prop.\n\n(** Coq中_[Class]_与_[Record]_有些像，但是有两点区别。第一：_[Class]_如果只有一\n    个域，它的中可以不使用大括号将这个域的定义围起来；第二：在定义或证明中，Coq\n    系统会试图自动搜索并填充类型为_[Class]_的参数，搜索范围为之前注册过可以使用\n    的_[Instance]_以及当前环境中的参数。例如，我们先前在证明等价关系、congruence\n    性质时就使用过_[Instance]_。例如，下面例子中，不需要指明_[order_rel]_是哪个\n    _[Order A]_的_[order_rel]_域，Coq会自动默认这是指_[RA]_的_[order_rel]_域。*)\n\nCheck forall {A: Type} {RA: Order A} (x: A),\n        exists (y: A), order_rel x y.\n\n(** 这样，我们就可以为_[order_rel]_定义Notation符号。*)\n\nDeclare Scope order_scope.\nNotation \"a <= b\" := (order_rel a b): order_scope.\nLocal Open Scope order_scope.\n\nCheck forall {A: Type} {RA: Order A} (x y: A),\n        x <= y \\/ y <= x.\n\n(** 基于序关系，我们就可以定义上界与下界的概念。由于Bourbaki-Witt不动点定理中主\n    要需要探讨无穷长元素序列的上界与上确界，下面既定义了元素集合的上下界也定义了\n    元素序列的上下界。*)\n\nDefinition is_lb\n             {A: Type} {RA: Order A}\n             (X: A -> Prop) (a: A): Prop :=\n  forall a', X a' -> a <= a'.\n\nDefinition is_ub\n             {A: Type} {RA: Order A}\n             (X: A -> Prop) (a: A): Prop :=\n  forall a', X a' -> a' <= a.\n\nDefinition is_omega_lb\n             {A: Type} {RA: Order A}\n             (l: nat -> A) (a: A): Prop :=\n  forall n, a <= l n.\n\nDefinition is_omega_ub\n             {A: Type} {RA: Order A}\n             (l: nat -> A) (a: A): Prop :=\n  forall n, l n <= a.\n\n(** 下面定义序列的上确界，所谓上确界就是上界中最小的一个，因此它的定义包含两个子\n    句。而在后续证明中，使用上确界性质的时候，有时需要用其第一条性质，有时需要用\n    其第二条性质。为了后续证明的方便，这里在定义之外提供了使用这两条性质的方法：\n    _[is_omega_lub_sound]_与_[is_omega_lub_tight]_。比起在证明中使用_[destruct]_\n    指令拆解上确界的定义，使用这两条引理，可以使得Coq证明更自然地表达我们的证明\n    思路。之后我们将在证明偏序集上上确界唯一性的时候会看到相关的用法。*)\n\nDefinition is_omega_lub\n             {A: Type} {RA: Order A}\n             (l: nat -> A) (a: A): Prop :=\n  is_omega_ub l a /\\ is_lb (is_omega_ub l) a.\n\nLemma is_omega_lub_sound:\n  forall {A: Type} {RA: Order A} {l: nat -> A} {a: A},\n    is_omega_lub l a -> is_omega_ub l a.\nProof. unfold is_omega_lub; intros; tauto. Qed.\n\nLemma is_omega_lub_tight:\n  forall {A: Type} {RA: Order A} {l: nat -> A} {a: A},\n    is_omega_lub l a -> is_lb (is_omega_ub l) a.\nProof. unfold is_omega_lub; intros; tauto. Qed.\n\n(** 在编写Coq定义时，另有一个问题需要专门考虑，有些数学上的相等关系在Coq中只是一\n    种等价关系。例如，我们之前在Coq中用过集合相等的定义。因此，我们描述\n    Bourbaki-Witt不动点定理的前提条件时，也需要假设有一个与序关系相关的等价关\n    系，我们用_[Equiv]_表示，并用_[==]_这个符号描述这个等价关系。*)\n\nClass Equiv (A: Type): Type :=\n  equiv: A -> A -> Prop.\n\nNotation \"a == b\" := (equiv a b): order_scope.\n\n(** 基于此，我们可以定义基于等价关系的自反性与反对称性。注意，传递性的定义与这个\n    等价关系无关。这里我们也用_[Class]_定义，这与Coq标准库中的自反、对称、传递的\n    定义是类似的，但是也有不同：(1) 我们的定义需要探讨一个二元关系与一个等价关系\n    之间的联系，而Coq标准库中只考虑了这个等价关系是普通等号的情况；(2) Coq标准库\n    中直接使用二元关系_[R: A -> A -> Prop]_作为参数，而我们的参数使用了_[Order]_\n    与_[Equiv]_这两个_[Class]_。   \n\n    自反性： *)\nClass Reflexive_Setoid\n        (A: Type) {RA: Order A} {EA: Equiv A}: Prop :=\n  reflexivity_setoid:\n    forall a b, a == b -> a <= b.\n\n(** 反对称性： *)\nClass AntiSymmetric_Setoid\n        (A: Type) {RA: Order A} {EA: Equiv A}: Prop :=\n  antisymmetricity_setoid:\n    forall a b, a <= b -> b <= a -> a == b.\n\n(** 现在，我们就可以如下定义偏序关系。*)\n\nClass PartialOrder_Setoid\n        (A: Type) {RA: Order A} {EA: Equiv A}: Prop :=\n{\n  PO_Reflexive_Setoid:> Reflexive_Setoid A;\n  PO_Transitive:> Transitive order_rel;\n  PO_AntiSymmetric_Setoid:> AntiSymmetric_Setoid A\n}.\n\n(** 下面证明两条偏序集的基本性质。在Coq中，我们使用前引号_[`]_让Coq自动填充\n    _[Class]_类型元素的参数。例如，_[`{POA: PartialOrder_Setoid A}]_会指引Coq\n    额外填上_[RA: Order A]_和_[EA: Equiv A]_。  \n\n\n    序关系两侧做等价变换不改变序关系：*)\n\nInstance PartialOrder_Setoid_Proper\n           {A: Type} `{POA: PartialOrder_Setoid A} {EquivA: Equivalence equiv}: (** 声明双等号具有自反对称传递：*)\n  Proper (equiv ==> equiv ==> iff) order_rel.\nProof.\n  unfold Proper, respectful.\n  intros.\n  split; intros.\n  + transitivity x0; [| apply reflexivity_setoid; tauto].\n    transitivity x; [apply reflexivity_setoid; symmetry; tauto |].\n    tauto.\n  + transitivity y0; [| apply reflexivity_setoid; symmetry; tauto].\n    transitivity y; [apply reflexivity_setoid; tauto |].\n    tauto.\nQed.\n\n(** 如果两个序列的所有上界都相同，那么他们的上确界也相同（如果有的话）：*)\n\nLemma same_omega_ub_same_omega_lub:\n  forall\n    {A: Type}\n    `{POA: PartialOrder_Setoid A}\n    (l1 l2: nat -> A)\n    (a1 a2: A),\n  (forall a, is_omega_ub l1 a <-> is_omega_ub l2 a) ->\n  is_omega_lub l1 a1 ->\n  is_omega_lub l2 a2 ->\n  a1 == a2.\nProof.\n  intros A ? ? POA.\n  sets_unfold.\n  intros.\n  apply antisymmetricity_setoid.\n  + apply (is_omega_lub_tight H0).\n    apply H.\n    apply (is_omega_lub_sound H1).\n  + apply (is_omega_lub_tight H1).\n    apply H.\n    apply (is_omega_lub_sound H0).\nQed.\n\n(** 证明Bourbaki-Witt不动点定理时还需要定义完备偏序集，由于在其证明中实际只用到\n    了完备偏序集有最小元和任意单调不减的元素序列有上确界，我们在Coq定义时也只考\n    虑符合这两个条件的偏序集，我们称为OmegaCPO，Omega表示可数无穷多项的意思。另\n    外，尽管数学上仅仅要求完备偏序集上的所有链有上确界，但是为了Coq证明的方便，\n    我们将_[omega_lub]_定义为所有元素序列的上确界计算函数，只不过我们仅仅要求该\n    函数在其参数为单调不减序列时能确实计算出上确界，见_[oCPO_completeness]_。*)\n\n\nClass OmegaLub (A: Type): Type :=\n  omega_lub: (nat -> A) -> A.\n\nClass Bot (A: Type): Type :=\n  bot: A.\n\nDefinition increasing\n             {A: Type} {RA: Order A} (l: nat -> A): Prop :=\n  forall n, l n <= l (S n).\n\nDefinition is_least {A: Type} {RA: Order A} (a: A): Prop :=\n  forall a', a <= a'.\n\nClass OmegaCompletePartialOrder_Setoid\n        (A: Type)\n        {RA: Order A} {EA: Equiv A}\n        {oLubA: OmegaLub A} {BotA: Bot A}: Prop :=\n{\n  oCPO_PartialOrder:> PartialOrder_Setoid A;\n  oCPO_completeness: forall T,\n    increasing T -> is_omega_lub T (omega_lub T);\n  bot_is_least: is_least bot\n}.\n\n(** 利用这里定义中的_[omega_lub]_函数，可以重述先前证明过的性质：两个单调不减序\n    列如果拥有完全相同的上界，那么他们也有同样的上确界。*)\n\nLemma same_omega_ub_same_omega_lub':\n  forall\n    {A: Type}\n    `{oCPOA: OmegaCompletePartialOrder_Setoid A}\n    (l1 l2: nat -> A),\n  (forall a, is_omega_ub l1 a <-> is_omega_ub l2 a) ->\n  increasing l1 ->\n  increasing l2 ->\n  omega_lub l1 == omega_lub l2.\nProof.\n  intros.\n  apply (same_omega_ub_same_omega_lub _ _ _ _ H).\n  + apply oCPO_completeness.\n    apply H0.\n  + apply oCPO_completeness.\n    apply H1.\nQed.\n\n(** 下面定义单调连续函数。从一个偏序集到另一个偏序集上也可以探讨单调性。*)\n\nDefinition mono\n             {A B: Type}\n             `{POA: PartialOrder_Setoid A}\n             `{POB: PartialOrder_Setoid B}\n             (f: A -> B): Prop :=\n  forall a1 a2, a1 <= a2 -> f a1 <= f a2.\n\nDefinition continuous\n             {A B: Type}\n             `{oCPOA: OmegaCompletePartialOrder_Setoid A}\n             `{oCPOB: OmegaCompletePartialOrder_Setoid B}\n             (f: A -> B): Prop :=\n  forall l: nat -> A,\n    increasing l ->\n    f (omega_lub l) == omega_lub (fun n => f (l n)).    (** 第n项是l作用在n上取f *)\n\n(** 下面我们可以证明：自反函数是单调连续的、复合函数能保持单调连续性。  \n\n    自反函数的单调性：*)\nLemma id_mono:\n  forall {A: Type}\n         `{POA: PartialOrder_Setoid A},\n  mono (fun x => x).\nProof.\n  unfold mono; intros.\n  apply H.\nQed.\n\n(** 复合函数保持单调性：*)\nLemma compose_mono:\n  forall {A B C: Type}\n         `{POA: PartialOrder_Setoid A}\n         `{POB: PartialOrder_Setoid B}\n         `{POC: PartialOrder_Setoid C}\n         (f: A -> B)\n         (g: B -> C),\n  mono f -> mono g -> mono (fun x => g (f x)).\nProof.\n  unfold mono; intros.\n  apply H0, H, H1.\nQed.\n\n(** 自反函数的连续性：*)\nLemma id_continuous:\n  forall {A: Type}\n         `{oCPOA: OmegaCompletePartialOrder_Setoid A}\n         {EquivA: Equivalence equiv},\n  continuous (fun x => x).\nProof.\n  unfold continuous; intros.\n  reflexivity.\nQed.\n\n(** 这里，要证明单调连续函数的复合结果也是连续的要复杂一些。显然，这其中需要证明\n    一个单调函数作用在一个单调不减序列的每一项后还会得到一个单调不减序列。下面的\n    引理_[increasing_mono_increasing]_描述了这一性质。*)\nLemma increasing_mono_increasing:\n  forall {A B: Type}\n         `{POA: PartialOrder_Setoid A}\n         `{POB: PartialOrder_Setoid B}\n         (f: A -> B)\n         (l: nat -> A),\n  increasing l -> mono f -> increasing (fun n => f (l n)).\nProof.\n  unfold increasing.\n  intros.\n  apply H0.\n  apply H.\nQed.\n\n(** 除此之外，我们还需要证明单调函数能保持相等关系，即，如果_[f]_是一个单调函\n    数，那么_[x == y]_能推出_[f x == f y]_。当然，如果这里的等价关系就是等号描述\n    的相等关系，那么这个性质是显然的。但是，对于一般的等价关系，这就并不显然了。\n    这一引理的正确性依赖于偏序关系中的自反性和反对称性。*)\nLemma mono_equiv_congr:\n  forall {A B: Type}\n         `{POA: PartialOrder_Setoid A}\n         `{POB: PartialOrder_Setoid B}\n          {EquivA: Equivalence (equiv: A -> A -> Prop)}\n         (f: A -> B),\n  mono f -> Proper (equiv ==> equiv) f. (**参数做等价变换*)\nProof.\n  unfold mono, Proper, respectful.\n  intros.\n  apply antisymmetricity_setoid; apply H.\n  + apply reflexivity_setoid.\n    apply H0.\n  + apply reflexivity_setoid.\n    rewrite H0.\n    reflexivity.\nQed.\n\n(** 现在，可以利用上面两条引理证明复合函数的连续性了。*)\nLemma compose_continuous:\n  forall {A B C: Type}\n         `{oCPOA: OmegaCompletePartialOrder_Setoid A}\n         `{oCPOB: OmegaCompletePartialOrder_Setoid B}\n         `{oCPOC: OmegaCompletePartialOrder_Setoid C}\n          {EquivB: Equivalence (equiv: B -> B -> Prop)}\n          {EquivC: Equivalence (equiv: C -> C -> Prop)}\n         (f: A -> B)\n         (g: B -> C),\n  mono f ->\n  mono g ->\n  continuous f ->\n  continuous g ->\n  continuous (fun x => g (f x)).\nProof.\n  unfold continuous.\n  intros.\n  pose proof increasing_mono_increasing f l H3 H.\n  specialize (H1 _ H3).\n  specialize (H2 _ H4).\n  simpl in H2.\n  rewrite <- H2.\n  apply mono_equiv_congr in H0.\n  apply H0.\n  apply H1.\nQed.\n\n(** 到目前为止，我们已经定义了Omega完备偏序集与单调连续函数。在证明Bourbaki-Witt\n    不动点定理之前还需要最后一项准备工作：定理描述本身的合法性。即，我们需要证明\n    _[bot]_, _[f bot]_, _[f (f bot)]_...这个序列的单调性。我们利用Coq标准库中的\n    _[Nat.iter]_来定义这个序列(迭代)，_[Nat.iter n f bot]_表示将_[f]_连续_[n]_次作用在\n    _[bot]_上。*)\n\nLemma iter_bot_increasing:\n  forall\n    {A: Type}\n    `{oCPOA: OmegaCompletePartialOrder_Setoid A}\n    (f: A -> A),\n    mono f ->\n    increasing (fun n => Nat.iter n f bot).\nProof.\n  unfold increasing.\n  intros.\n  induction n; simpl.\n  + apply bot_is_least.\n  + apply H.\n    apply IHn.\nQed.\n\n(** 当然，_[f bot]_, _[f (f bot)]_, _[f (f (f bot))]_...这个序列也是单调不减的。*)\nLemma iter_S_bot_increasing:\n  forall\n    {A: Type}\n    `{oCPOA: OmegaCompletePartialOrder_Setoid A}\n    (f: A -> A),\n    mono f ->\n    increasing (fun n => f (Nat.iter n f bot)).\nProof.\n  unfold increasing.\n  intros.\n  apply H.\n  apply iter_bot_increasing.\n  apply H.\nQed.\n\n(** _[BW_LFix]_定义了Bourbaki-Witt最小不动点。*)\nDefinition BW_LFix\n             {A: Type}\n             `{CPOA: OmegaCompletePartialOrder_Setoid A}\n             (f: A -> A): A :=\n  omega_lub (fun n => Nat.iter n f bot).\n\n(** 先证明，_[BW_LFix]_的计算结果确实是一个不动点。*)\nLemma BW_LFix_is_fix:\n  forall\n    {A: Type}\n    `{CPOA: OmegaCompletePartialOrder_Setoid A}\n    {EquivA: Equivalence equiv}\n    (f: A -> A),\n    mono f ->\n    continuous f ->\n    f (BW_LFix f) == BW_LFix f.\nProof.\n  unfold BW_LFix; intros.\n  rewrite H0 by (apply iter_bot_increasing; tauto).\n  apply same_omega_ub_same_omega_lub'.\n  + intros; unfold is_omega_ub.\n    split; intros.\n    - destruct n.\n      * apply bot_is_least.\n      * apply H1.\n    - specialize (H1 (S n)).\n      apply H1.\n  + apply iter_S_bot_increasing.\n    apply H.\n  + apply iter_bot_increasing.\n    apply H.\nQed.\n\n(** 再证明，_[BW_LFix]_的计算结果是最小不动点。*)\nLemma BW_LFix_is_least_fix:\n  forall\n    {A: Type}\n    `{CPOA: OmegaCompletePartialOrder_Setoid A}\n    {EquivA: Equivalence equiv}\n    (f: A -> A)\n    (a: A),\n    mono f ->\n    continuous f ->\n    f a == a ->\n    BW_LFix f <= a.\nProof.\n  unfold BW_LFix; intros.\n  pose proof iter_bot_increasing f H.\n  pose proof oCPO_completeness (fun n => Nat.iter n f bot) H2.\n  apply (is_omega_lub_tight H3).\n  unfold is_omega_ub.\n  induction n; simpl.\n  + apply bot_is_least.\n  + rewrite <- H1.\n    apply H.\n    apply IHn.\nQed.\n\nLocal Close Scope order_scope.\n\n(** 接下去我们将利用Bourbaki-Witt最小不动点定义While语句的程序语义中运行终止的情\n    况。  \n\n    首先需要定义我们所需的OmegaCPO。在定义_[Class]_类型的值时，可以使用\n    _[Intance]_关键字。如果_[Class]_中只有一个域并且_[Class]_的定义没有使用大括\n    号包围所有域，那么这个域的定义就是整个_[Class]_类型的值的定义；否则_[Class]_\n    类型的值应当像_[Record]_类型的值一样定义。*)\nInstance R_while_fin {A B: Type}: Order (A -> B -> Prop) :=\n  Sets.included.\n\nInstance Equiv_while_fin {A B: Type}: Equiv (A -> B -> Prop) :=\n  Sets.equiv.\n\n(** 下面证明这是一个偏序关系。证明的时候需要展开上面两个二元关系（一个表示序关系\n    另一个表示等价关系）。以序关系为例，此时需要将_[R_while_fin]_与_[order_rel]_\n    全部展开，前者表示将上面的定义展开，后者表示将从_[Class Order]_取出\n    _[order_rel]_域这一操作展开。其余的证明则只需用_[sets_unfold]_证明集合相关的\n    性质。*)\nInstance PO_while_fin {A B: Type}: PartialOrder_Setoid (A -> B -> Prop).\nProof.\n  split.\n  + unfold Reflexive_Setoid.\n    unfold equiv, order_rel, R_while_fin, Equiv_while_fin; simpl.\n    sets_unfold; intros a b H x y.\n    specialize (H x y).\n    tauto.\n  + unfold Transitive.\n    unfold equiv, order_rel, R_while_fin, Equiv_while_fin; simpl.\n    sets_unfold; intros a b c H H0 x y.\n    specialize (H x y).\n    specialize (H0 x y).\n    tauto.\n  + unfold AntiSymmetric_Setoid.\n    unfold equiv, order_rel, R_while_fin, Equiv_while_fin; simpl.\n    sets_unfold; intros a b H H0 x y.\n    specialize (H x y).\n    specialize (H0 x y).\n    tauto.\nQed.\n\n(** 下面再定义上确界计算函数与完备偏序集中的最小值。*)\nInstance oLub_while_fin {A B: Type}: OmegaLub (A -> B -> Prop) :=\n  Sets.indexed_union.\n\nInstance Bot_while_fin {A B: Type}: Bot (A -> B -> Prop) :=\n  ∅: A -> B -> Prop.\n\n(** 下面证明这构成一个Omega完备偏序集。*)\nInstance oCPO_while_fin {A B: Type}:\n  OmegaCompletePartialOrder_Setoid (A -> B -> Prop).\nProof.\n  split.\n  + apply PO_while_fin.\n  + unfold increasing, is_omega_lub, is_omega_ub, is_lb.\n    unfold omega_lub, order_rel, R_while_fin, oLub_while_fin; simpl.\n    sets_unfold; intros T H.\n    split.\n    - intros n x y; intros.\n      exists n.\n      tauto.\n    - intros a H0 x y H1.\n      destruct H1 as [n ?].\n      specialize (H0 n x y).\n      tauto.\n  + unfold is_least.\n    unfold bot, order_rel, R_while_fin, Bot_while_fin; simpl.\n    sets_unfold; intros a.\n    tauto.\nQed.\n\n(** 额外需要补充一点：_[Equiv_while_fin]_确实是一个等价关系。先前Bourbaki-Witt不\n    动点定理的证明中用到了这一前提。*)\nInstance Equiv_equiv_while_fin {A B: Type}:\n  Equivalence (@equiv (A -> B -> Prop) _).\nProof.\n  apply Sets_equiv_equiv.\nQed.\n\n(** 下面开始证明_[F(X) = (test1(D0) ∘ D ∘ while_denote D0 D) ∪ test0(D0)]_这个函\n    数的单调性与连续性。整体证明思路是：(1) _[F(X) = X]_是单调连续的；(2) 如果\n    _[F]_是单调连续的，那么_[G(X) = Y ∘ F(X)]_也是单调连续的；(3) 如果_[F]_是单\n    调连续的，那么_[G(X) = F(X) ∪ Y]_也是单调连续的；其中_[Y]_是给定的二元关系。  \n\n    下面证明前面提到的步骤(2)：如果_[F]_是单调连续的，那么_[G(X) = Y ∘ F(X)]_也\n    是单调连续的。主结论为_[BinRel_concat_left_mono_and_continuous]_，其用到了两\n    条下面的辅助引理以及前面证明过的复合函数单调连续性定理。*)\n\nLemma BinRel_concat_left_mono:\n  forall (A B C: Type) (Y: A -> B -> Prop),\n    mono (fun X: B -> C -> Prop => Y ∘ X).\nProof.\n  intros.\n  unfold mono.\n  unfold order_rel, R_while_fin.\n  intros.\n  rewrite H; reflexivity.\nQed.\n\nLemma BinRel_concat_left_continuous:\n  forall (A B C: Type) (Y: A -> B -> Prop),\n    continuous (fun X: B -> C -> Prop => Y ∘ X).\nProof.\n  intros.\n  unfold continuous.\n  unfold increasing, omega_lub, order_rel, equiv,\n         oLub_while_fin, R_while_fin, Equiv_while_fin.\n  intros.\n  apply Rels_concat_indexed_union_distr_l.\nQed.\n\nLemma BinRel_concat_left_mono_and_continuous:\n  forall\n    (A B C: Type)\n    (Y: A -> B -> Prop)\n    (f: (B -> C -> Prop) -> (B -> C -> Prop)),\n  mono f /\\ continuous f ->\n  mono (fun X => Y ∘ f X) /\\ continuous (fun X => Y ∘ f X).\nProof.\n  intros.\n  destruct H.\n  pose proof BinRel_concat_left_mono _ _ C Y.\n  pose proof BinRel_concat_left_continuous _ _ C Y.\n  split.\n  + exact (compose_mono f _ H H1).\n  + exact (compose_continuous f _ H H1 H0 H2).\nQed.\n\n(** 下面证明前面提到的步骤(3)：如果_[F]_是单调连续的，那么_[G(X) = Y ∘ F(X)]_也\n    是单调连续的。主结论为_[union_right2_mono_and_continuous]_，其用到了两条下面\n    的辅助引理以及前面证明过的复合函数单调连续性定理。*)\n\nLemma union_right2_mono:\n  forall (A B: Type) (Y: A -> B -> Prop),\n    mono (fun X => X ∪ Y).\nProof.\n  intros.\n  unfold mono.\n  unfold order_rel, R_while_fin.\n  sets_unfold.\n  intros R R' H st1 st2.\n  specialize (H st1 st2).\n  tauto.\nQed.\n\nLemma union_right2_continuous:\n  forall (A B: Type) (Y: A -> B -> Prop),\n    continuous (fun X => X ∪ Y).\nProof.\n  intros.\n  unfold continuous.\n  unfold increasing, omega_lub, order_rel, equiv,\n         oLub_while_fin, R_while_fin, Equiv_while_fin.\n  sets_unfold.\n  intros l H st1 st2.\n  split; intros.\n  + destruct H0 as [ [ n ? ] | ?].\n    - exists n; tauto.\n    - exists O; tauto.\n  + destruct H0 as [n [? | ? ] ].\n    - left.\n      exists n; tauto.\n    - tauto.\nQed.\n\nLemma union_right2_mono_and_continuous:\n  forall\n    (A B: Type)\n    (Y: A -> B -> Prop)\n    (f: (A -> B -> Prop) -> (A -> B -> Prop)),\n  mono f /\\ continuous f ->\n  mono (fun X => f X ∪ Y) /\\ continuous (fun X => f X ∪ Y).\nProof.\n  intros.\n  destruct H.\n  pose proof union_right2_mono _ _ Y.\n  pose proof union_right2_continuous _ _ Y.\n  split.\n  + exact (compose_mono f _ H H1).\n  + exact (compose_continuous f _ H H1 H0 H2).\nQed.\n\n(** 最终我们可以用Bourbaki-Witt不动点定义while语句运行终止的情况。  \n\n    首先给出语义定义。*)\nDefinition while_sem\n             (D0: state -> bool)\n             (D: state -> state -> Prop):\n  state -> state -> Prop :=\n  BW_LFix (fun X => (test_true(D0) ∘ D ∘ X) ∪ test_false(D0)).\n\n(** 下面可以直接使用Bourbaki-Witt不动点定理证明上述定义就是我们要的最小不动点。*)\nTheorem while_sem_is_least_fix: forall D0 D,\n  (test_true(D0) ∘ D ∘ while_sem D0 D) ∪ test_false(D0) == while_sem D0 D /\\\n  (forall X,\n    (test_true(D0) ∘ D ∘ X) ∪ test_false(D0) == X -> while_sem D0 D ⊆ X).\nProof.\n  intros.\n  assert (mono (fun X => (test_true(D0) ∘ D ∘ X) ∪ test_false(D0)) /\\\n          continuous (fun X => (test_true(D0) ∘ D ∘ X) ∪ test_false(D0))).\n  {\n    apply union_right2_mono_and_continuous.\n    apply BinRel_concat_left_mono_and_continuous.\n    apply BinRel_concat_left_mono_and_continuous.\n    split.\n    + apply id_mono.\n    + apply id_continuous.\n  }\n  destruct H.\n  split.\n  + apply (BW_LFix_is_fix (fun X => (test_true(D0) ∘ D ∘ X) ∪ test_false(D0)));\n      tauto.\n  + intros X.\n    apply (BW_LFix_is_least_fix (fun X => (test_true(D0) ∘ D ∘ X) ∪ test_false(D0)));\n      tauto.\nQed.\n\n\nEnd DntSem_SimpleWhile5.\n"
        }
    ]
}