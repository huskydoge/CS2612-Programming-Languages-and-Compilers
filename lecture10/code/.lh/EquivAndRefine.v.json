{
    "sourceFile": "EquivAndRefine.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 47,
            "patches": [
                {
                    "date": 1699336983325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1699337473900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n   (at level 1).\n Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n   (at level 1).\n Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n+Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H).\n (at level 1).\n   (at level 1).\n Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n   (at level 1).\n"
                },
                {
                    "date": 1699337479755,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,10 @@\n   (at level 1).\n Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n   (at level 1).\n Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H).\n+\n+Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n (at level 1).\n   (at level 1).\n Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n   (at level 1).\n"
                },
                {
                    "date": 1699337485636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,8 @@\n   (at level 1).\n Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n   (at level 1).\n Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-\n Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n (at level 1).\n   (at level 1).\n Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n"
                },
                {
                    "date": 1699337503594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,10 +174,10 @@\n   (at level 1).\n Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n   (at level 1).\n Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n+  (at level 1).\n Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n-(at level 1).\n   (at level 1).\n Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n   (at level 1).\n Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n"
                },
                {
                    "date": 1699337662275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -893,8 +893,9 @@\n   tauto.\n Qed.\n \n (** 下面把二元运算的情况汇总起来。*)\n+(** Proper: 表达式语法树的一个二元函数*)\n \n Instance EBinop_congr: forall op,\n   Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n Proof.\n"
                },
                {
                    "date": 1699337694781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -893,9 +893,9 @@\n   tauto.\n Qed.\n \n (** 下面把二元运算的情况汇总起来。*)\n-(** Proper: 表达式语法树的一个二元函数*)\n+(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n \n Instance EBinop_congr: forall op,\n   Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n Proof.\n"
                },
                {
                    "date": 1699337738265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1568 @@\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.micromega.Psatz.\n+Require Import Coq.Strings.String.\n+Require Import Coq.Classes.Morphisms.\n+Require Import Coq.Classes.Morphisms_Prop.\n+Require Import Coq.Classes.RelationClasses.\n+Require Import Coq.Logic.Classical_Pred_Type.\n+Require Import Coq.Logic.Classical_Prop.\n+Require Import SetsClass.SetsClass. Import SetsNotation.\n+Require Import compcert.lib.Integers.\n+Require Import PL.SyntaxInCoq.\n+Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n+Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n+Import Lang_While DntSem_While1 DntSem_While2.\n+Import EDenote CDenote.\n+Local Open Scope string.\n+Local Open Scope Z.\n+Local Open Scope sets.\n+\n+(** * 定义与例子 *)\n+\n+Definition EVar': string -> expr := EVar.\n+Coercion EConst: Z >-> expr.\n+Coercion EVar: var_name >-> expr.\n+Coercion EVar': string >-> expr.\n+Notation \"[[ e ]]\" := e\n+  (at level 0, e custom expr_entry at level 99).\n+Notation \"( x )\" := x\n+  (in custom expr_entry, x custom expr_entry at level 99).\n+Notation \"x\" := x\n+  (in custom expr_entry at level 0, x constr at level 0).\n+Notation \"f x\" := (f x)\n+  (in custom expr_entry at level 1, only parsing,\n+   f custom expr_entry,\n+   x custom expr_entry at level 0).\n+Notation \"x + y\" := (EBinop OPlus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x - y\" := (EBinop OMinus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x * y\" := (EBinop OMul x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x / y\" := (EBinop ODiv x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x % y\" := (EBinop OMod x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x <= y\" := (EBinop OLe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x < y\" := (EBinop OLt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x >= y\" := (EBinop OGe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x > y\" := (EBinop OGt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x == y\" := (EBinop OEq x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x != y\" := (EBinop ONe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x && y\" := (EBinop OAnd x y)\n+  (in custom expr_entry at level 14, left associativity).\n+Notation \"x || y\" := (EBinop OOr x y)\n+  (in custom expr_entry at level 15, left associativity).\n+Notation \"! x\" := (EUnop ONot x)\n+  (in custom expr_entry at level 10).\n+Notation \"- x\" := (EUnop ONeg x)\n+  (in custom expr_entry at level 10).\n+Notation \"c1 ; c2\" := (CSeq c1 c2)\n+  (in custom expr_entry at level 20, right associativity).\n+Notation \"'skip'\" := (CSkip)\n+  (in custom expr_entry at level 10).\n+Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99,\n+   c2 custom expr_entry at level 99,\n+   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n+Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99).\n+\n+Notation \"⟦ e ⟧\" := (eval_expr e)\n+  (at level 0, only printing, e custom expr_entry at level 99).\n+Notation \"⟦ c ⟧\" := (eval_com c)\n+  (at level 0, only printing, c custom expr_entry at level 99).\n+\n+Ltac any_eval x :=\n+  match goal with\n+  | |- EDenote => exact (eval_expr x)\n+  | |- CDenote => exact (eval_com x)\n+  | _ => match type of x with\n+         | expr => exact (eval_expr x)\n+         | com => exact (eval_com x)\n+         end\n+  end.\n+\n+Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n+  (at level 0, only parsing, x custom expr_entry at level 99).\n+\n+Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n+  (no associativity, at level 61): sets_scope.\n+\n+(** 表达式语义等价 *)\n+\n+Record eequiv (e1 e2: expr): Prop := {\n+  nrm_eequiv:\n+    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n+  err_eequiv:\n+    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 表达式精化关系 *)\n+\n+Record erefine (e1 e2: expr): Prop := {\n+  nrm_erefine:\n+    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n+  err_erefine:\n+    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 程序语句语义等价 *)\n+\n+Record cequiv (c1 c2: com): Prop := {\n+  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n+  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n+  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n+}.\n+\n+(** 程序语句精化关系 *)\n+\n+Record crefine (c1 c2: com): Prop := {\n+  nrm_crefine:\n+    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n+  err_crefine:\n+    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n+  inf_crefine:\n+    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n+}.\n+\n+Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n+  (at level 69, only printing, no associativity).\n+\n+Ltac any_equiv x y :=\n+  match type of x with\n+  | expr => exact (eequiv x y)\n+  | com => exact (cequiv x y)\n+  | _ => match type of y with\n+         | expr => exact (eequiv x y)\n+         | com => exact (cequiv x y)\n+         end\n+  end.\n+\n+Ltac any_refine x y :=\n+  match type of x with\n+  | expr => exact (erefine x y)\n+  | com => exact (crefine x y)\n+  | _ => match type of y with\n+         | expr => exact (erefine x y)\n+         | com => exact (crefine x y)\n+         end\n+  end.\n+\n+Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n+  (at level 69, only parsing, no associativity).\n+Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n+  (at level 69, only parsing, no associativity).\n+\n+Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n+  (at level 1).\n+\n+(** 精化的例子 *)\n+\n+Lemma const_plus_const_refine: forall n m: Z,\n+  EConst (n + m) <<= [[n + m]].\n+(** 证明见Coq代码。*)\n+Proof.\n+  intros.\n+  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n+          n < Int64.min_signed \\/\n+          n > Int64.max_signed) as Hn by lia.\n+  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n+          m < Int64.min_signed \\/\n+          m > Int64.max_signed) as Hm by lia.\n+  split.\n+  + sets_unfold; intros s i ?.\n+    simpl in H.\n+    destruct H.\n+    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n+    - unfold arith_sem1_nrm, arith_compute1_nrm.\n+      exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H1.\n+      pose proof Int64.signed_repr _ H2.\n+      rewrite H3, H4.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+  + sets_unfold; intros s ?.\n+    simpl in H.\n+    simpl; sets_unfold.\n+    unfold arith_sem1_err, arith_compute1_err.\n+    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n+    - exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H0.\n+      pose proof Int64.signed_repr _ H1.\n+      rewrite H2, H3.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+Qed.\n+\n+(** 语义等价的例子：顺序执行有结合律 *)\n+\n+Theorem CSeq_assoc: forall (c1 c2 c3: com),\n+  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+Qed.\n+\n+\n+Theorem CIf_CSeq: forall e c1 c2 c3,\n+  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n+  [[ if e then { c1; c3 } else { c2; c3 } ]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite <- ! Rels_concat_assoc.\n+    apply Rels_concat_union_distr_r.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+\n+\n+\n+(** * 语义等价与精化的性质 *)\n+\n+\n+(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n+\n+\n+    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n+    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n+    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n+    将稍后再解释_[Instance]_关键字的特殊作用。*)\n+\n+Instance eequiv_refl: Reflexive eequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance eequiv_sym: Symmetric eequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_trans: Transitive eequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv), H0.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_equiv: Equivalence eequiv.\n+Proof.\n+  split.\n+  + apply eequiv_refl.\n+  + apply eequiv_sym.\n+  + apply eequiv_trans.\n+Qed.\n+\n+(** 下面还可以证明精化关系也具有自反性和传递性。*)\n+\n+Instance erefine_refl: Reflexive erefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+Qed.\n+\n+Instance erefine_trans: Transitive erefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_erefine).\n+    rewrite H0.(nrm_erefine).\n+    rewrite H0.(err_erefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_erefine).\n+    rewrite H0.(err_erefine).\n+    reflexivity.\n+Qed.\n+\n+(** 并且精化关系在语义等价变换下不变。*)\n+\n+Instance erefine_well_defined:\n+  Proper (eequiv ==> eequiv ==> iff) erefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_eequiv).\n+      rewrite <- H0.(nrm_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite <- H.(err_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+  + split.\n+    - rewrite H.(nrm_eequiv).\n+      rewrite H0.(nrm_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite H.(err_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+Qed.\n+\n+(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n+    性。*)\n+\n+Instance cequiv_refl: Reflexive cequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance cequiv_sym: Symmetric cequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_trans: Transitive cequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv), H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_equiv: Equivalence cequiv.\n+Proof.\n+  split.\n+  + apply cequiv_refl.\n+  + apply cequiv_sym.\n+  + apply cequiv_trans.\n+Qed.\n+\n+Instance crefine_refl: Reflexive crefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+  + apply Sets_included_union1.\n+Qed.\n+\n+Instance crefine_trans: Transitive crefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H0.(err_crefine).\n+    reflexivity.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance crefine_well_defined:\n+  Proper (cequiv ==> cequiv ==> iff) crefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_cequiv).\n+      rewrite <- H0.(nrm_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite <- H.(err_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite <- H.(inf_cequiv).\n+      rewrite <- H0.(inf_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+  + split.\n+    - rewrite H.(nrm_cequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite H.(err_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite H.(inf_cequiv).\n+      rewrite H0.(inf_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+Qed.\n+\n+\n+\n+(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持\n+    精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n+\n+Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem1_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s.\n+  unfold arith_sem1_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem1_nrm, arith_sem1_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem1_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+(** 很多其它情况的证明是类似的。*)\n+\n+Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem2_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold arith_sem2_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem2_nrm, arith_sem2_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem2_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold cmp_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  apply or_iff_morphism.\n+  + apply H.(err_eequiv).\n+  + apply H0.(err_eequiv).\n+Qed.\n+\n+Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold cmp_sem_nrm.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  intros [? | ?].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+Qed.\n+\n+Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold and_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold and_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold and_sem_nrm, and_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold and_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold or_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold or_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold or_sem_nrm, or_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold or_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+(** 下面把二元运算的情况汇总起来。*)\n+(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n+\n+Instance EBinop_congr: forall op,\n+  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - apply or_sem_nrm_congr; tauto.\n+    - apply or_sem_err_congr; tauto.\n+  + split.\n+    - apply and_sem_nrm_congr; tauto.\n+    - apply and_sem_err_congr; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+Qed.\n+\n+Instance EBinop_mono: forall op,\n+  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - simpl.\n+      apply (or_sem_nrm_mono x y x0 y0); tauto.\n+    - apply or_sem_err_mono; tauto.\n+  + split.\n+    - apply and_sem_nrm_mono; tauto.\n+    - apply and_sem_err_mono; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+Qed.\n+\n+(** 一元运算的情况是类似的。*)\n+\n+Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  not_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma not_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_eequiv).\n+Qed.\n+\n+Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma not_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_erefine).\n+Qed.\n+\n+Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  intros.\n+  unfold neg_sem_err; sets_unfold.\n+  intros s.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n+  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n+Proof.\n+  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma neg_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_err; sets_unfold.\n+  intros ? ? ? s ?.\n+  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n+  destruct H0 as [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  right; exists i1.\n+  tauto.\n+Qed.\n+\n+Instance EUnop_congr: forall op,\n+  Proper (eequiv ==> eequiv) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - apply not_sem_nrm_congr; tauto.\n+    - simpl. apply not_sem_err_congr; tauto.\n+  + split.\n+    - apply neg_sem_nrm_congr; tauto.\n+    - apply neg_sem_err_congr; tauto.\n+Qed.\n+\n+Instance EUnop_mono: forall op,\n+  Proper (erefine ==> erefine) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - simpl. apply not_sem_nrm_mono; tauto.\n+    - simpl. apply not_sem_err_mono; tauto.\n+  + split.\n+    - apply neg_sem_nrm_mono; tauto.\n+    - apply neg_sem_err_mono; tauto.\n+Qed.\n+\n+(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n+    性是比较显然的。*)\n+\n+Instance CSeq_congr:\n+  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(err_cequiv).\n+    rewrite H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(inf_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n+\n+Lemma Rels_times_full_concat2:\n+  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n+    (X × B) ∘ Y ⊆ X × C.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a c.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+Lemma Rels_times_full_concat1:\n+  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n+    (X × B) ∘ Y ⊆ X.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+(** 下面证明顺序执行能保持精化关系。*)\n+\n+Instance CSeq_mono:\n+  Proper (crefine ==> crefine ==> crefine) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite Rels_concat_union_distr_r.\n+    rewrite Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n+    _[test_false]_的性质。*)\n+\n+Lemma test_true_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_true ⟦ e1 ⟧ ⊆\n+  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  intros [ [i [? ?] ] ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; split; [| tauto].\n+  exists i; tauto.\n+Qed.\n+\n+Lemma test_false_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_false ⟦ e1 ⟧ ⊆\n+  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  intros [? ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  tauto.\n+Qed.\n+\n+Lemma test_true_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply ex_iff_morphism; intros i.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+Lemma test_false_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n+\n+Instance CIf_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H1.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H.(err_eequiv).\n+    rewrite H0.(err_cequiv).\n+    rewrite H1.(err_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(inf_cequiv).\n+    rewrite H1.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance CIf_mono:\n+  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(err_crefine), H1.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(inf_crefine), H1.(inf_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n+    的次数进行归纳。*)\n+\n+Instance CWhile_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  (** 正常运行终止的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite (test_false_congr _ _ H).\n+      rewrite H0.(nrm_cequiv).\n+      reflexivity.\n+  (** 运行出错的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite H.(err_eequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      reflexivity.\n+  (** 运行不终止的情况。*)\n+  + apply Sets_general_union_congr.\n+    intros X.\n+    unfold_CL_defs.\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    rewrite (test_true_congr _ _ H).\n+    reflexivity.\n+Qed.\n+\n+(** 要证明while语句保持精化关系就更复杂一些了。*)\n+\n+Definition boundedLB_nrm\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n+    ∅.\n+\n+Definition boundedLB_err\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n+    ∅.\n+\n+Definition is_inf\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (X: state -> Prop): Prop :=\n+  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n+      test_true D0 ∘ D1.(inf).\n+\n+Lemma boundedLB_nrm_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n+    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite (test_false_mono _ _ H).\n+    rewrite H0.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+Qed.\n+\n+Lemma boundedLB_err_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Sets_complement_indexed_union:\n+  forall {A I: Type} (Xs: I -> A -> Prop),\n+    Sets.complement (⋃ Xs) ==\n+    ⋂ (fun n => Sets.complement (Xs n)).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  split.\n+  + apply not_ex_all_not.\n+  + apply all_not_not_ex.\n+Qed.\n+\n+Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n+  Sets.complement (⋃ (boundedLB_err D1 D2)).\n+\n+Lemma iter_err_fact:\n+  forall (D1: EDenote) (D2: CDenote),\n+    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n+    ⋃ (boundedLB_err D1 D2).\n+Proof.\n+  intros.\n+  rewrite ! Rels_concat_indexed_union_distr_l.\n+  apply Sets_indexed_union_included; intros n.\n+  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n+  simpl.\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Rels_concat_excluding_r:\n+  forall\n+    {A B: Type}\n+    (R: A -> B -> Prop)\n+    (S T: B -> Prop),\n+    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n+    R ∘ (S ∩ Sets.complement T).\n+Proof.\n+  intros.\n+  Sets_unfold; intros a.\n+  intros [ [b [? ?] ] ?].\n+  exists b.\n+  split; [tauto |].\n+  split; [tauto |].\n+  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n+  clear H1; intros.\n+  exists b; tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact1:\n+  forall (D1: EDenote) (D2: CDenote),\n+    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact2:\n+  forall (D1: EDenote) (D2: CDenote),\n+    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma inf_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) X,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n+    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+Proof.\n+  unfold is_inf.\n+  intros.\n+  rewrite H1 at 1.\n+  rewrite (test_true_mono _ _ H).\n+  rewrite H0.(nrm_crefine).\n+  rewrite H0.(inf_crefine).\n+  rewrite ! Rels_concat_union_distr_r.\n+  rewrite ! Rels_concat_union_distr_l.\n+  rewrite ! Rels_times_full_concat1.\n+  rewrite ! Sets_intersect_union_distr_r.\n+  rewrite noerrorLB_fact1.\n+  rewrite noerrorLB_fact2.\n+  rewrite ! Sets_union_empty.\n+  unfold noerrorLB at 1.\n+  rewrite <- iter_err_fact at 1.\n+  rewrite ! Rels_concat_excluding_r.\n+  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance CWhile_mono:\n+  Proper (erefine ==> crefine ==> crefine) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- ! (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_nrm_mono_aux; tauto.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_err_mono_aux; tauto.\n+  + apply Sets_general_union_included. unfold_CL_defs.\n+    intros X ?.\n+    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n+    unfold KT_GFix; unfold_CL_defs.\n+    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n+      by (exact H2).\n+    unfold noerrorLB.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n+\n+Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n+  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n+  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n+Proof.\n+  intros.\n+  rewrite CSeq_assoc.\n+  rewrite CIf_CSeq.\n+  reflexivity.\n+Qed.\n+\n"
                },
                {
                    "date": 1699337791177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -946,8 +946,9 @@\n     - apply arith_sem2_nrm_congr; tauto.\n     - apply arith_sem2_err_congr; tauto.\n Qed.\n \n+(** e1 + e2 => e1' + e2, e1'是e1的精化*)\n Instance EBinop_mono: forall op,\n   Proper (erefine ==> erefine ==> erefine) (EBinop op).\n Proof.\n   unfold Proper, respectful.\n@@ -1565,1575 +1566,4 @@\n   rewrite CIf_CSeq.\n   reflexivity.\n Qed.\n \n-Require Import Coq.ZArith.ZArith.\n-Require Import Coq.micromega.Psatz.\n-Require Import Coq.Strings.String.\n-Require Import Coq.Classes.Morphisms.\n-Require Import Coq.Classes.Morphisms_Prop.\n-Require Import Coq.Classes.RelationClasses.\n-Require Import Coq.Logic.Classical_Pred_Type.\n-Require Import Coq.Logic.Classical_Prop.\n-Require Import SetsClass.SetsClass. Import SetsNotation.\n-Require Import compcert.lib.Integers.\n-Require Import PL.SyntaxInCoq.\n-Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n-Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n-Import Lang_While DntSem_While1 DntSem_While2.\n-Import EDenote CDenote.\n-Local Open Scope string.\n-Local Open Scope Z.\n-Local Open Scope sets.\n-\n-(** * 定义与例子 *)\n-\n-Definition EVar': string -> expr := EVar.\n-Coercion EConst: Z >-> expr.\n-Coercion EVar: var_name >-> expr.\n-Coercion EVar': string >-> expr.\n-Notation \"[[ e ]]\" := e\n-  (at level 0, e custom expr_entry at level 99).\n-Notation \"( x )\" := x\n-  (in custom expr_entry, x custom expr_entry at level 99).\n-Notation \"x\" := x\n-  (in custom expr_entry at level 0, x constr at level 0).\n-Notation \"f x\" := (f x)\n-  (in custom expr_entry at level 1, only parsing,\n-   f custom expr_entry,\n-   x custom expr_entry at level 0).\n-Notation \"x + y\" := (EBinop OPlus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x - y\" := (EBinop OMinus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x * y\" := (EBinop OMul x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x / y\" := (EBinop ODiv x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x % y\" := (EBinop OMod x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x <= y\" := (EBinop OLe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x < y\" := (EBinop OLt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x >= y\" := (EBinop OGe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x > y\" := (EBinop OGt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x == y\" := (EBinop OEq x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x != y\" := (EBinop ONe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x && y\" := (EBinop OAnd x y)\n-  (in custom expr_entry at level 14, left associativity).\n-Notation \"x || y\" := (EBinop OOr x y)\n-  (in custom expr_entry at level 15, left associativity).\n-Notation \"! x\" := (EUnop ONot x)\n-  (in custom expr_entry at level 10).\n-Notation \"- x\" := (EUnop ONeg x)\n-  (in custom expr_entry at level 10).\n-Notation \"c1 ; c2\" := (CSeq c1 c2)\n-  (in custom expr_entry at level 20, right associativity).\n-Notation \"'skip'\" := (CSkip)\n-  (in custom expr_entry at level 10).\n-Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99,\n-   c2 custom expr_entry at level 99,\n-   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n-Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99).\n-\n-Notation \"⟦ e ⟧\" := (eval_expr e)\n-  (at level 0, only printing, e custom expr_entry at level 99).\n-Notation \"⟦ c ⟧\" := (eval_com c)\n-  (at level 0, only printing, c custom expr_entry at level 99).\n-\n-Ltac any_eval x :=\n-  match goal with\n-  | |- EDenote => exact (eval_expr x)\n-  | |- CDenote => exact (eval_com x)\n-  | _ => match type of x with\n-         | expr => exact (eval_expr x)\n-         | com => exact (eval_com x)\n-         end\n-  end.\n-\n-Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n-  (at level 0, only parsing, x custom expr_entry at level 99).\n-\n-Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n-  (no associativity, at level 61): sets_scope.\n-\n-(** 表达式语义等价 *)\n-\n-Record eequiv (e1 e2: expr): Prop := {\n-  nrm_eequiv:\n-    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n-  err_eequiv:\n-    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 表达式精化关系 *)\n-\n-Record erefine (e1 e2: expr): Prop := {\n-  nrm_erefine:\n-    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n-  err_erefine:\n-    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 程序语句语义等价 *)\n-\n-Record cequiv (c1 c2: com): Prop := {\n-  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n-  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n-  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n-}.\n-\n-(** 程序语句精化关系 *)\n-\n-Record crefine (c1 c2: com): Prop := {\n-  nrm_crefine:\n-    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n-  err_crefine:\n-    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n-  inf_crefine:\n-    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n-}.\n-\n-Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n-  (at level 69, only printing, no associativity).\n-\n-Ltac any_equiv x y :=\n-  match type of x with\n-  | expr => exact (eequiv x y)\n-  | com => exact (cequiv x y)\n-  | _ => match type of y with\n-         | expr => exact (eequiv x y)\n-         | com => exact (cequiv x y)\n-         end\n-  end.\n-\n-Ltac any_refine x y :=\n-  match type of x with\n-  | expr => exact (erefine x y)\n-  | com => exact (crefine x y)\n-  | _ => match type of y with\n-         | expr => exact (erefine x y)\n-         | com => exact (crefine x y)\n-         end\n-  end.\n-\n-Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n-  (at level 69, only parsing, no associativity).\n-Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n-  (at level 69, only parsing, no associativity).\n-\n-Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n-  (at level 1).\n-\n-(** 精化的例子 *)\n-\n-Lemma const_plus_const_refine: forall n m: Z,\n-  EConst (n + m) <<= [[n + m]].\n-(** 证明见Coq代码。*)\n-Proof.\n-  intros.\n-  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n-          n < Int64.min_signed \\/\n-          n > Int64.max_signed) as Hn by lia.\n-  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n-          m < Int64.min_signed \\/\n-          m > Int64.max_signed) as Hm by lia.\n-  split.\n-  + sets_unfold; intros s i ?.\n-    simpl in H.\n-    destruct H.\n-    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n-    - unfold arith_sem1_nrm, arith_compute1_nrm.\n-      exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H1.\n-      pose proof Int64.signed_repr _ H2.\n-      rewrite H3, H4.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-  + sets_unfold; intros s ?.\n-    simpl in H.\n-    simpl; sets_unfold.\n-    unfold arith_sem1_err, arith_compute1_err.\n-    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n-    - exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H0.\n-      pose proof Int64.signed_repr _ H1.\n-      rewrite H2, H3.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-Qed.\n-\n-(** 语义等价的例子：顺序执行有结合律 *)\n-\n-Theorem CSeq_assoc: forall (c1 c2 c3: com),\n-  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-Qed.\n-\n-\n-Theorem CIf_CSeq: forall e c1 c2 c3,\n-  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n-  [[ if e then { c1; c3 } else { c2; c3 } ]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite <- ! Rels_concat_assoc.\n-    apply Rels_concat_union_distr_r.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-\n-\n-\n-(** * 语义等价与精化的性质 *)\n-\n-\n-(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n-\n-\n-    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n-    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n-    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n-    将稍后再解释_[Instance]_关键字的特殊作用。*)\n-\n-Instance eequiv_refl: Reflexive eequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance eequiv_sym: Symmetric eequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_trans: Transitive eequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv), H0.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_equiv: Equivalence eequiv.\n-Proof.\n-  split.\n-  + apply eequiv_refl.\n-  + apply eequiv_sym.\n-  + apply eequiv_trans.\n-Qed.\n-\n-(** 下面还可以证明精化关系也具有自反性和传递性。*)\n-\n-Instance erefine_refl: Reflexive erefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-Qed.\n-\n-Instance erefine_trans: Transitive erefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_erefine).\n-    rewrite H0.(nrm_erefine).\n-    rewrite H0.(err_erefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_erefine).\n-    rewrite H0.(err_erefine).\n-    reflexivity.\n-Qed.\n-\n-(** 并且精化关系在语义等价变换下不变。*)\n-\n-Instance erefine_well_defined:\n-  Proper (eequiv ==> eequiv ==> iff) erefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_eequiv).\n-      rewrite <- H0.(nrm_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite <- H.(err_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-  + split.\n-    - rewrite H.(nrm_eequiv).\n-      rewrite H0.(nrm_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite H.(err_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-Qed.\n-\n-(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n-    性。*)\n-\n-Instance cequiv_refl: Reflexive cequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance cequiv_sym: Symmetric cequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_trans: Transitive cequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv), H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_equiv: Equivalence cequiv.\n-Proof.\n-  split.\n-  + apply cequiv_refl.\n-  + apply cequiv_sym.\n-  + apply cequiv_trans.\n-Qed.\n-\n-Instance crefine_refl: Reflexive crefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-  + apply Sets_included_union1.\n-Qed.\n-\n-Instance crefine_trans: Transitive crefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H0.(err_crefine).\n-    reflexivity.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance crefine_well_defined:\n-  Proper (cequiv ==> cequiv ==> iff) crefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_cequiv).\n-      rewrite <- H0.(nrm_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite <- H.(err_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite <- H.(inf_cequiv).\n-      rewrite <- H0.(inf_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-  + split.\n-    - rewrite H.(nrm_cequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite H.(err_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite H.(inf_cequiv).\n-      rewrite H0.(inf_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-Qed.\n-\n-\n-\n-(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持\n-    精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n-\n-Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem1_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s.\n-  unfold arith_sem1_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem1_nrm, arith_sem1_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem1_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-(** 很多其它情况的证明是类似的。*)\n-\n-Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem2_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold arith_sem2_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem2_nrm, arith_sem2_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem2_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold cmp_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  apply or_iff_morphism.\n-  + apply H.(err_eequiv).\n-  + apply H0.(err_eequiv).\n-Qed.\n-\n-Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold cmp_sem_nrm.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  intros [? | ?].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-Qed.\n-\n-Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold and_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold and_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold and_sem_nrm, and_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold and_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold or_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold or_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold or_sem_nrm, or_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold or_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-(** 下面把二元运算的情况汇总起来。*)\n-(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n-\n-Instance EBinop_congr: forall op,\n-  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - apply or_sem_nrm_congr; tauto.\n-    - apply or_sem_err_congr; tauto.\n-  + split.\n-    - apply and_sem_nrm_congr; tauto.\n-    - apply and_sem_err_congr; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-Qed.\n-\n-Instance EBinop_mono: forall op,\n-  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - simpl.\n-    Locate \"×\".\n-    Set Printing All.\n-\n-      apply (or_sem_nrm_mono x y x0 y0); tauto.\n-    - apply or_sem_err_mono; tauto.\n-  + split.\n-    - apply and_sem_nrm_mono; tauto.\n-    - apply and_sem_err_mono; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-Qed.\n-\n-(** 一元运算的情况是类似的。*)\n-\n-Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  not_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma not_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_eequiv).\n-Qed.\n-\n-Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma not_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_erefine).\n-Qed.\n-\n-Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  intros.\n-  unfold neg_sem_err; sets_unfold.\n-  intros s.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n-  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n-Proof.\n-  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma neg_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_err; sets_unfold.\n-  intros ? ? ? s ?.\n-  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n-  destruct H0 as [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  right; exists i1.\n-  tauto.\n-Qed.\n-\n-Instance EUnop_congr: forall op,\n-  Proper (eequiv ==> eequiv) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - apply not_sem_nrm_congr; tauto.\n-    - simpl. apply not_sem_err_congr; tauto.\n-  + split.\n-    - apply neg_sem_nrm_congr; tauto.\n-    - apply neg_sem_err_congr; tauto.\n-Qed.\n-\n-Instance EUnop_mono: forall op,\n-  Proper (erefine ==> erefine) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - simpl. apply not_sem_nrm_mono; tauto.\n-    - simpl. apply not_sem_err_mono; tauto.\n-  + split.\n-    - apply neg_sem_nrm_mono; tauto.\n-    - apply neg_sem_err_mono; tauto.\n-Qed.\n-\n-(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n-    性是比较显然的。*)\n-\n-Instance CSeq_congr:\n-  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(err_cequiv).\n-    rewrite H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(inf_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n-\n-Lemma Rels_times_full_concat2:\n-  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n-    (X × B) ∘ Y ⊆ X × C.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a c.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-Lemma Rels_times_full_concat1:\n-  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n-    (X × B) ∘ Y ⊆ X.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-(** 下面证明顺序执行能保持精化关系。*)\n-\n-Instance CSeq_mono:\n-  Proper (crefine ==> crefine ==> crefine) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite Rels_concat_union_distr_r.\n-    rewrite Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n-    _[test_false]_的性质。*)\n-\n-Lemma test_true_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_true ⟦ e1 ⟧ ⊆\n-  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  intros [ [i [? ?] ] ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; split; [| tauto].\n-  exists i; tauto.\n-Qed.\n-\n-Lemma test_false_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_false ⟦ e1 ⟧ ⊆\n-  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  intros [? ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  tauto.\n-Qed.\n-\n-Lemma test_true_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply ex_iff_morphism; intros i.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-Lemma test_false_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n-\n-Instance CIf_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H1.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H.(err_eequiv).\n-    rewrite H0.(err_cequiv).\n-    rewrite H1.(err_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(inf_cequiv).\n-    rewrite H1.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance CIf_mono:\n-  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(err_crefine), H1.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(inf_crefine), H1.(inf_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n-    的次数进行归纳。*)\n-\n-Instance CWhile_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  (** 正常运行终止的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite (test_false_congr _ _ H).\n-      rewrite H0.(nrm_cequiv).\n-      reflexivity.\n-  (** 运行出错的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite H.(err_eequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      reflexivity.\n-  (** 运行不终止的情况。*)\n-  + apply Sets_general_union_congr.\n-    intros X.\n-    unfold_CL_defs.\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    rewrite (test_true_congr _ _ H).\n-    reflexivity.\n-Qed.\n-\n-(** 要证明while语句保持精化关系就更复杂一些了。*)\n-\n-Definition boundedLB_nrm\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n-    ∅.\n-\n-Definition boundedLB_err\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n-    ∅.\n-\n-Definition is_inf\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (X: state -> Prop): Prop :=\n-  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n-      test_true D0 ∘ D1.(inf).\n-\n-Lemma boundedLB_nrm_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n-    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite (test_false_mono _ _ H).\n-    rewrite H0.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-Qed.\n-\n-Lemma boundedLB_err_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Sets_complement_indexed_union:\n-  forall {A I: Type} (Xs: I -> A -> Prop),\n-    Sets.complement (⋃ Xs) ==\n-    ⋂ (fun n => Sets.complement (Xs n)).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  split.\n-  + apply not_ex_all_not.\n-  + apply all_not_not_ex.\n-Qed.\n-\n-Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n-  Sets.complement (⋃ (boundedLB_err D1 D2)).\n-\n-Lemma iter_err_fact:\n-  forall (D1: EDenote) (D2: CDenote),\n-    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n-    ⋃ (boundedLB_err D1 D2).\n-Proof.\n-  intros.\n-  rewrite ! Rels_concat_indexed_union_distr_l.\n-  apply Sets_indexed_union_included; intros n.\n-  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n-  simpl.\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Rels_concat_excluding_r:\n-  forall\n-    {A B: Type}\n-    (R: A -> B -> Prop)\n-    (S T: B -> Prop),\n-    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n-    R ∘ (S ∩ Sets.complement T).\n-Proof.\n-  intros.\n-  Sets_unfold; intros a.\n-  intros [ [b [? ?] ] ?].\n-  exists b.\n-  split; [tauto |].\n-  split; [tauto |].\n-  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n-  clear H1; intros.\n-  exists b; tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact1:\n-  forall (D1: EDenote) (D2: CDenote),\n-    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact2:\n-  forall (D1: EDenote) (D2: CDenote),\n-    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma inf_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) X,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n-    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-Proof.\n-  unfold is_inf.\n-  intros.\n-  rewrite H1 at 1.\n-  rewrite (test_true_mono _ _ H).\n-  rewrite H0.(nrm_crefine).\n-  rewrite H0.(inf_crefine).\n-  rewrite ! Rels_concat_union_distr_r.\n-  rewrite ! Rels_concat_union_distr_l.\n-  rewrite ! Rels_times_full_concat1.\n-  rewrite ! Sets_intersect_union_distr_r.\n-  rewrite noerrorLB_fact1.\n-  rewrite noerrorLB_fact2.\n-  rewrite ! Sets_union_empty.\n-  unfold noerrorLB at 1.\n-  rewrite <- iter_err_fact at 1.\n-  rewrite ! Rels_concat_excluding_r.\n-  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance CWhile_mono:\n-  Proper (erefine ==> crefine ==> crefine) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_nrm_mono_aux; tauto.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_err_mono_aux; tauto.\n-  + apply Sets_general_union_included. unfold_CL_defs.\n-    intros X ?.\n-    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n-    unfold KT_GFix; unfold_CL_defs.\n-    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n-      by (exact H2).\n-    unfold noerrorLB.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n-\n-Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n-  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n-  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n-Proof.\n-  intros.\n-  rewrite CSeq_assoc.\n-  rewrite CIf_CSeq.\n-  reflexivity.\n-Qed.\n-\n"
                },
                {
                    "date": 1699337815131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -946,9 +946,9 @@\n     - apply arith_sem2_nrm_congr; tauto.\n     - apply arith_sem2_err_congr; tauto.\n Qed.\n \n-(** e1 + e2 => e1' + e2, e1'是e1的精化*)\n+(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n Instance EBinop_mono: forall op,\n   Proper (erefine ==> erefine ==> erefine) (EBinop op).\n Proof.\n   unfold Proper, respectful.\n"
                },
                {
                    "date": 1699337920675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -478,8 +478,12 @@\n \n (** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持\n     精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n \n+Lemma add_congr: forall Zfun (e11 e12 e21 e22: expr),\n+    e11 ~=~ e12 ->\n+    e21 ~=~ e22 ->\n+\n Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n   arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n"
                },
                {
                    "date": 1699337949379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -481,8 +481,9 @@\n \n Lemma add_congr: forall Zfun (e11 e12 e21 e22: expr),\n     e11 ~=~ e12 ->\n     e21 ~=~ e22 ->\n+    (EBinop OAdd e11 e21) ~=~ (EBinop OAdd e12 e22).\n \n Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n"
                },
                {
                    "date": 1699337974940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -475,10 +475,9 @@\n Qed.\n \n \n \n-(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持\n-    精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n+(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n \n Lemma add_congr: forall Zfun (e11 e12 e21 e22: expr),\n     e11 ~=~ e12 ->\n     e21 ~=~ e22 ->\n"
                },
                {
                    "date": 1699338013365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -480,9 +480,9 @@\n \n Lemma add_congr: forall Zfun (e11 e12 e21 e22: expr),\n     e11 ~=~ e12 ->\n     e21 ~=~ e22 ->\n-    (EBinop OAdd e11 e21) ~=~ (EBinop OAdd e12 e22).\n+    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n \n Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n"
                },
                {
                    "date": 1699338030433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -481,8 +481,9 @@\n Lemma add_congr: forall Zfun (e11 e12 e21 e22: expr),\n     e11 ~=~ e12 ->\n     e21 ~=~ e22 ->\n     (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n+Proof.\n \n Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n"
                },
                {
                    "date": 1699338049053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -477,9 +477,9 @@\n \n \n (** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n \n-Lemma add_congr: forall Zfun (e11 e12 e21 e22: expr),\n+Lemma add_congr: forall(e11 e12 e21 e22: expr),\n     e11 ~=~ e12 ->\n     e21 ~=~ e22 ->\n     (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n Proof.\n"
                },
                {
                    "date": 1699338106362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -477,13 +477,18 @@\n \n \n (** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n \n-Lemma add_congr: forall(e11 e12 e21 e22: expr),\n+Lemma add_congr: forall (e11 e12 e21 e22: expr),\n     e11 ~=~ e12 ->\n     e21 ~=~ e22 ->\n     (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n Proof.\n+  intros.\n+  split.\n+  + simpl. admit.\n+  + simpl.\n+Abort.\n \n Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n"
                },
                {
                    "date": 1699338130845,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -488,8 +488,9 @@\n   + simpl. admit.\n   + simpl.\n Abort.\n \n+(** Normal 对应相同 *)\n Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n   arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n@@ -504,8 +505,10 @@\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n   reflexivity.\n Qed.\n \n+\n+(** Error 对应相同 *)\n Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n   ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n"
                },
                {
                    "date": 1699338235636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -498,9 +498,9 @@\n Proof.\n   sets_unfold.\n   intros ? ? ? ? ? ? ? s i.\n   unfold arith_sem1_nrm.\n-  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n   apply ex_iff_morphism; intros i2.\n   apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n   reflexivity.\n"
                },
                {
                    "date": 1699338348967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n   intros ? ? ? ? ? ? ? s i.\n   unfold arith_sem1_nrm.\n   apply ex_iff_morphism; intros i1. (*脱掉i1*)\n   apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. （* [apply H |]\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n   reflexivity.\n Qed.\n \n"
                },
                {
                    "date": 1699338359186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n   intros ? ? ? ? ? ? ? s i.\n   unfold arith_sem1_nrm.\n   apply ex_iff_morphism; intros i1. (*脱掉i1*)\n   apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. （* [apply H |]\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n   reflexivity.\n Qed.\n \n"
                },
                {
                    "date": 1699338567210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -542,9 +542,9 @@\n   sets_unfold.\n   intros s i.\n   unfold arith_sem1_nrm, arith_sem1_err.\n   intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n+  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n   apply H0.(nrm_erefine) in H2.\n   sets_unfold in H1.\n   sets_unfold in H2.\n   destruct H1; [| tauto].\n"
                },
                {
                    "date": 1699338630057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -548,9 +548,9 @@\n   sets_unfold in H1.\n   sets_unfold in H2.\n   destruct H1; [| tauto].\n   destruct H2; [| tauto].\n-  left.\n+  left. (** 只剩下最后一种求值都成功的情况 *)\n   exists i1, i2.\n   tauto.\n Qed.\n \n"
                },
                {
                    "date": 1699338694041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1582 @@\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.micromega.Psatz.\n+Require Import Coq.Strings.String.\n+Require Import Coq.Classes.Morphisms.\n+Require Import Coq.Classes.Morphisms_Prop.\n+Require Import Coq.Classes.RelationClasses.\n+Require Import Coq.Logic.Classical_Pred_Type.\n+Require Import Coq.Logic.Classical_Prop.\n+Require Import SetsClass.SetsClass. Import SetsNotation.\n+Require Import compcert.lib.Integers.\n+Require Import PL.SyntaxInCoq.\n+Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n+Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n+Import Lang_While DntSem_While1 DntSem_While2.\n+Import EDenote CDenote.\n+Local Open Scope string.\n+Local Open Scope Z.\n+Local Open Scope sets.\n+\n+(** * 定义与例子 *)\n+\n+Definition EVar': string -> expr := EVar.\n+Coercion EConst: Z >-> expr.\n+Coercion EVar: var_name >-> expr.\n+Coercion EVar': string >-> expr.\n+Notation \"[[ e ]]\" := e\n+  (at level 0, e custom expr_entry at level 99).\n+Notation \"( x )\" := x\n+  (in custom expr_entry, x custom expr_entry at level 99).\n+Notation \"x\" := x\n+  (in custom expr_entry at level 0, x constr at level 0).\n+Notation \"f x\" := (f x)\n+  (in custom expr_entry at level 1, only parsing,\n+   f custom expr_entry,\n+   x custom expr_entry at level 0).\n+Notation \"x + y\" := (EBinop OPlus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x - y\" := (EBinop OMinus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x * y\" := (EBinop OMul x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x / y\" := (EBinop ODiv x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x % y\" := (EBinop OMod x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x <= y\" := (EBinop OLe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x < y\" := (EBinop OLt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x >= y\" := (EBinop OGe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x > y\" := (EBinop OGt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x == y\" := (EBinop OEq x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x != y\" := (EBinop ONe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x && y\" := (EBinop OAnd x y)\n+  (in custom expr_entry at level 14, left associativity).\n+Notation \"x || y\" := (EBinop OOr x y)\n+  (in custom expr_entry at level 15, left associativity).\n+Notation \"! x\" := (EUnop ONot x)\n+  (in custom expr_entry at level 10).\n+Notation \"- x\" := (EUnop ONeg x)\n+  (in custom expr_entry at level 10).\n+Notation \"c1 ; c2\" := (CSeq c1 c2)\n+  (in custom expr_entry at level 20, right associativity).\n+Notation \"'skip'\" := (CSkip)\n+  (in custom expr_entry at level 10).\n+Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99,\n+   c2 custom expr_entry at level 99,\n+   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n+Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99).\n+\n+Notation \"⟦ e ⟧\" := (eval_expr e)\n+  (at level 0, only printing, e custom expr_entry at level 99).\n+Notation \"⟦ c ⟧\" := (eval_com c)\n+  (at level 0, only printing, c custom expr_entry at level 99).\n+\n+Ltac any_eval x :=\n+  match goal with\n+  | |- EDenote => exact (eval_expr x)\n+  | |- CDenote => exact (eval_com x)\n+  | _ => match type of x with\n+         | expr => exact (eval_expr x)\n+         | com => exact (eval_com x)\n+         end\n+  end.\n+\n+Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n+  (at level 0, only parsing, x custom expr_entry at level 99).\n+\n+Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n+  (no associativity, at level 61): sets_scope.\n+\n+(** 表达式语义等价 *)\n+\n+Record eequiv (e1 e2: expr): Prop := {\n+  nrm_eequiv:\n+    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n+  err_eequiv:\n+    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 表达式精化关系 *)\n+\n+Record erefine (e1 e2: expr): Prop := {\n+  nrm_erefine:\n+    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n+  err_erefine:\n+    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 程序语句语义等价 *)\n+\n+Record cequiv (c1 c2: com): Prop := {\n+  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n+  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n+  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n+}.\n+\n+(** 程序语句精化关系 *)\n+\n+Record crefine (c1 c2: com): Prop := {\n+  nrm_crefine:\n+    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n+  err_crefine:\n+    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n+  inf_crefine:\n+    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n+}.\n+\n+Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n+  (at level 69, only printing, no associativity).\n+\n+Ltac any_equiv x y :=\n+  match type of x with\n+  | expr => exact (eequiv x y)\n+  | com => exact (cequiv x y)\n+  | _ => match type of y with\n+         | expr => exact (eequiv x y)\n+         | com => exact (cequiv x y)\n+         end\n+  end.\n+\n+Ltac any_refine x y :=\n+  match type of x with\n+  | expr => exact (erefine x y)\n+  | com => exact (crefine x y)\n+  | _ => match type of y with\n+         | expr => exact (erefine x y)\n+         | com => exact (crefine x y)\n+         end\n+  end.\n+\n+Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n+  (at level 69, only parsing, no associativity).\n+Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n+  (at level 69, only parsing, no associativity).\n+\n+Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n+  (at level 1).\n+\n+(** 精化的例子 *)\n+\n+Lemma const_plus_const_refine: forall n m: Z,\n+  EConst (n + m) <<= [[n + m]].\n+(** 证明见Coq代码。*)\n+Proof.\n+  intros.\n+  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n+          n < Int64.min_signed \\/\n+          n > Int64.max_signed) as Hn by lia.\n+  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n+          m < Int64.min_signed \\/\n+          m > Int64.max_signed) as Hm by lia.\n+  split.\n+  + sets_unfold; intros s i ?.\n+    simpl in H.\n+    destruct H.\n+    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n+    - unfold arith_sem1_nrm, arith_compute1_nrm.\n+      exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H1.\n+      pose proof Int64.signed_repr _ H2.\n+      rewrite H3, H4.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+  + sets_unfold; intros s ?.\n+    simpl in H.\n+    simpl; sets_unfold.\n+    unfold arith_sem1_err, arith_compute1_err.\n+    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n+    - exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H0.\n+      pose proof Int64.signed_repr _ H1.\n+      rewrite H2, H3.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+Qed.\n+\n+(** 语义等价的例子：顺序执行有结合律 *)\n+\n+Theorem CSeq_assoc: forall (c1 c2 c3: com),\n+  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+Qed.\n+\n+\n+Theorem CIf_CSeq: forall e c1 c2 c3,\n+  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n+  [[ if e then { c1; c3 } else { c2; c3 } ]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite <- ! Rels_concat_assoc.\n+    apply Rels_concat_union_distr_r.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+\n+\n+\n+(** * 语义等价与精化的性质 *)\n+\n+\n+(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n+\n+\n+    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n+    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n+    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n+    将稍后再解释_[Instance]_关键字的特殊作用。*)\n+\n+Instance eequiv_refl: Reflexive eequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance eequiv_sym: Symmetric eequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_trans: Transitive eequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv), H0.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_equiv: Equivalence eequiv.\n+Proof.\n+  split.\n+  + apply eequiv_refl.\n+  + apply eequiv_sym.\n+  + apply eequiv_trans.\n+Qed.\n+\n+(** 下面还可以证明精化关系也具有自反性和传递性。*)\n+\n+Instance erefine_refl: Reflexive erefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+Qed.\n+\n+Instance erefine_trans: Transitive erefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_erefine).\n+    rewrite H0.(nrm_erefine).\n+    rewrite H0.(err_erefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_erefine).\n+    rewrite H0.(err_erefine).\n+    reflexivity.\n+Qed.\n+\n+(** 并且精化关系在语义等价变换下不变。*)\n+\n+Instance erefine_well_defined:\n+  Proper (eequiv ==> eequiv ==> iff) erefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_eequiv).\n+      rewrite <- H0.(nrm_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite <- H.(err_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+  + split.\n+    - rewrite H.(nrm_eequiv).\n+      rewrite H0.(nrm_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite H.(err_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+Qed.\n+\n+(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n+    性。*)\n+\n+Instance cequiv_refl: Reflexive cequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance cequiv_sym: Symmetric cequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_trans: Transitive cequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv), H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_equiv: Equivalence cequiv.\n+Proof.\n+  split.\n+  + apply cequiv_refl.\n+  + apply cequiv_sym.\n+  + apply cequiv_trans.\n+Qed.\n+\n+Instance crefine_refl: Reflexive crefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+  + apply Sets_included_union1.\n+Qed.\n+\n+Instance crefine_trans: Transitive crefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H0.(err_crefine).\n+    reflexivity.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance crefine_well_defined:\n+  Proper (cequiv ==> cequiv ==> iff) crefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_cequiv).\n+      rewrite <- H0.(nrm_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite <- H.(err_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite <- H.(inf_cequiv).\n+      rewrite <- H0.(inf_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+  + split.\n+    - rewrite H.(nrm_cequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite H.(err_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite H.(inf_cequiv).\n+      rewrite H0.(inf_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+Qed.\n+\n+\n+\n+(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n+\n+Lemma add_congr: forall (e11 e12 e21 e22: expr),\n+    e11 ~=~ e12 ->\n+    e21 ~=~ e22 ->\n+    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n+Proof.\n+  intros.\n+  split.\n+  + simpl. admit.\n+  + simpl.\n+Abort.\n+\n+(** Normal 对应相同 *)\n+Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem1_nrm.\n+  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+\n+(** Error 对应相同 *)\n+Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s.\n+  unfold arith_sem1_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem1_nrm, arith_sem1_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left. (** 只剩下最后一种求值都成功的情况 *)\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem1_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+(** 很多其它情况的证明是类似的。*)\n+\n+Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem2_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold arith_sem2_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem2_nrm, arith_sem2_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem2_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold cmp_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  apply or_iff_morphism.\n+  + apply H.(err_eequiv).\n+  + apply H0.(err_eequiv).\n+Qed.\n+\n+Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold cmp_sem_nrm.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  intros [? | ?].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+Qed.\n+\n+Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold and_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold and_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold and_sem_nrm, and_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold and_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold or_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold or_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold or_sem_nrm, or_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold or_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+(** 下面把二元运算的情况汇总起来。*)\n+(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n+\n+Instance EBinop_congr: forall op,\n+  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - apply or_sem_nrm_congr; tauto.\n+    - apply or_sem_err_congr; tauto.\n+  + split.\n+    - apply and_sem_nrm_congr; tauto.\n+    - apply and_sem_err_congr; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+Qed.\n+\n+(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n+Instance EBinop_mono: forall op,\n+  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - simpl.\n+      apply (or_sem_nrm_mono x y x0 y0); tauto.\n+    - apply or_sem_err_mono; tauto.\n+  + split.\n+    - apply and_sem_nrm_mono; tauto.\n+    - apply and_sem_err_mono; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+Qed.\n+\n+(** 一元运算的情况是类似的。*)\n+\n+Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  not_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma not_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_eequiv).\n+Qed.\n+\n+Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma not_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_erefine).\n+Qed.\n+\n+Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  intros.\n+  unfold neg_sem_err; sets_unfold.\n+  intros s.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n+  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n+Proof.\n+  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma neg_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_err; sets_unfold.\n+  intros ? ? ? s ?.\n+  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n+  destruct H0 as [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  right; exists i1.\n+  tauto.\n+Qed.\n+\n+Instance EUnop_congr: forall op,\n+  Proper (eequiv ==> eequiv) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - apply not_sem_nrm_congr; tauto.\n+    - simpl. apply not_sem_err_congr; tauto.\n+  + split.\n+    - apply neg_sem_nrm_congr; tauto.\n+    - apply neg_sem_err_congr; tauto.\n+Qed.\n+\n+Instance EUnop_mono: forall op,\n+  Proper (erefine ==> erefine) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - simpl. apply not_sem_nrm_mono; tauto.\n+    - simpl. apply not_sem_err_mono; tauto.\n+  + split.\n+    - apply neg_sem_nrm_mono; tauto.\n+    - apply neg_sem_err_mono; tauto.\n+Qed.\n+\n+(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n+    性是比较显然的。*)\n+\n+Instance CSeq_congr:\n+  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(err_cequiv).\n+    rewrite H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(inf_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n+\n+Lemma Rels_times_full_concat2:\n+  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n+    (X × B) ∘ Y ⊆ X × C.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a c.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+Lemma Rels_times_full_concat1:\n+  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n+    (X × B) ∘ Y ⊆ X.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+(** 下面证明顺序执行能保持精化关系。*)\n+\n+Instance CSeq_mono:\n+  Proper (crefine ==> crefine ==> crefine) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite Rels_concat_union_distr_r.\n+    rewrite Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n+    _[test_false]_的性质。*)\n+\n+Lemma test_true_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_true ⟦ e1 ⟧ ⊆\n+  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  intros [ [i [? ?] ] ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; split; [| tauto].\n+  exists i; tauto.\n+Qed.\n+\n+Lemma test_false_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_false ⟦ e1 ⟧ ⊆\n+  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  intros [? ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  tauto.\n+Qed.\n+\n+Lemma test_true_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply ex_iff_morphism; intros i.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+Lemma test_false_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n+\n+Instance CIf_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H1.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H.(err_eequiv).\n+    rewrite H0.(err_cequiv).\n+    rewrite H1.(err_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(inf_cequiv).\n+    rewrite H1.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance CIf_mono:\n+  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(err_crefine), H1.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(inf_crefine), H1.(inf_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n+    的次数进行归纳。*)\n+\n+Instance CWhile_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  (** 正常运行终止的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite (test_false_congr _ _ H).\n+      rewrite H0.(nrm_cequiv).\n+      reflexivity.\n+  (** 运行出错的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite H.(err_eequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      reflexivity.\n+  (** 运行不终止的情况。*)\n+  + apply Sets_general_union_congr.\n+    intros X.\n+    unfold_CL_defs.\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    rewrite (test_true_congr _ _ H).\n+    reflexivity.\n+Qed.\n+\n+(** 要证明while语句保持精化关系就更复杂一些了。*)\n+\n+Definition boundedLB_nrm\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n+    ∅.\n+\n+Definition boundedLB_err\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n+    ∅.\n+\n+Definition is_inf\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (X: state -> Prop): Prop :=\n+  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n+      test_true D0 ∘ D1.(inf).\n+\n+Lemma boundedLB_nrm_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n+    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite (test_false_mono _ _ H).\n+    rewrite H0.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+Qed.\n+\n+Lemma boundedLB_err_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Sets_complement_indexed_union:\n+  forall {A I: Type} (Xs: I -> A -> Prop),\n+    Sets.complement (⋃ Xs) ==\n+    ⋂ (fun n => Sets.complement (Xs n)).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  split.\n+  + apply not_ex_all_not.\n+  + apply all_not_not_ex.\n+Qed.\n+\n+Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n+  Sets.complement (⋃ (boundedLB_err D1 D2)).\n+\n+Lemma iter_err_fact:\n+  forall (D1: EDenote) (D2: CDenote),\n+    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n+    ⋃ (boundedLB_err D1 D2).\n+Proof.\n+  intros.\n+  rewrite ! Rels_concat_indexed_union_distr_l.\n+  apply Sets_indexed_union_included; intros n.\n+  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n+  simpl.\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Rels_concat_excluding_r:\n+  forall\n+    {A B: Type}\n+    (R: A -> B -> Prop)\n+    (S T: B -> Prop),\n+    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n+    R ∘ (S ∩ Sets.complement T).\n+Proof.\n+  intros.\n+  Sets_unfold; intros a.\n+  intros [ [b [? ?] ] ?].\n+  exists b.\n+  split; [tauto |].\n+  split; [tauto |].\n+  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n+  clear H1; intros.\n+  exists b; tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact1:\n+  forall (D1: EDenote) (D2: CDenote),\n+    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact2:\n+  forall (D1: EDenote) (D2: CDenote),\n+    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma inf_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) X,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n+    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+Proof.\n+  unfold is_inf.\n+  intros.\n+  rewrite H1 at 1.\n+  rewrite (test_true_mono _ _ H).\n+  rewrite H0.(nrm_crefine).\n+  rewrite H0.(inf_crefine).\n+  rewrite ! Rels_concat_union_distr_r.\n+  rewrite ! Rels_concat_union_distr_l.\n+  rewrite ! Rels_times_full_concat1.\n+  rewrite ! Sets_intersect_union_distr_r.\n+  rewrite noerrorLB_fact1.\n+  rewrite noerrorLB_fact2.\n+  rewrite ! Sets_union_empty.\n+  unfold noerrorLB at 1.\n+  rewrite <- iter_err_fact at 1.\n+  rewrite ! Rels_concat_excluding_r.\n+  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance CWhile_mono:\n+  Proper (erefine ==> crefine ==> crefine) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- ! (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_nrm_mono_aux; tauto.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_err_mono_aux; tauto.\n+  + apply Sets_general_union_included. unfold_CL_defs.\n+    intros X ?.\n+    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n+    unfold KT_GFix; unfold_CL_defs.\n+    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n+      by (exact H2).\n+    unfold noerrorLB.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n+\n+Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n+  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n+  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n+Proof.\n+  intros.\n+  rewrite CSeq_assoc.\n+  rewrite CIf_CSeq.\n+  reflexivity.\n+Qed.\n+\n"
                },
                {
                    "date": 1699338735393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1583 @@\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.micromega.Psatz.\n+Require Import Coq.Strings.String.\n+Require Import Coq.Classes.Morphisms.\n+Require Import Coq.Classes.Morphisms_Prop.\n+Require Import Coq.Classes.RelationClasses.\n+Require Import Coq.Logic.Classical_Pred_Type.\n+Require Import Coq.Logic.Classical_Prop.\n+Require Import SetsClass.SetsClass. Import SetsNotation.\n+Require Import compcert.lib.Integers.\n+Require Import PL.SyntaxInCoq.\n+Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n+Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n+Import Lang_While DntSem_While1 DntSem_While2.\n+Import EDenote CDenote.\n+Local Open Scope string.\n+Local Open Scope Z.\n+Local Open Scope sets.\n+\n+(** * 定义与例子 *)\n+\n+Definition EVar': string -> expr := EVar.\n+Coercion EConst: Z >-> expr.\n+Coercion EVar: var_name >-> expr.\n+Coercion EVar': string >-> expr.\n+Notation \"[[ e ]]\" := e\n+  (at level 0, e custom expr_entry at level 99).\n+Notation \"( x )\" := x\n+  (in custom expr_entry, x custom expr_entry at level 99).\n+Notation \"x\" := x\n+  (in custom expr_entry at level 0, x constr at level 0).\n+Notation \"f x\" := (f x)\n+  (in custom expr_entry at level 1, only parsing,\n+   f custom expr_entry,\n+   x custom expr_entry at level 0).\n+Notation \"x + y\" := (EBinop OPlus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x - y\" := (EBinop OMinus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x * y\" := (EBinop OMul x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x / y\" := (EBinop ODiv x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x % y\" := (EBinop OMod x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x <= y\" := (EBinop OLe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x < y\" := (EBinop OLt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x >= y\" := (EBinop OGe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x > y\" := (EBinop OGt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x == y\" := (EBinop OEq x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x != y\" := (EBinop ONe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x && y\" := (EBinop OAnd x y)\n+  (in custom expr_entry at level 14, left associativity).\n+Notation \"x || y\" := (EBinop OOr x y)\n+  (in custom expr_entry at level 15, left associativity).\n+Notation \"! x\" := (EUnop ONot x)\n+  (in custom expr_entry at level 10).\n+Notation \"- x\" := (EUnop ONeg x)\n+  (in custom expr_entry at level 10).\n+Notation \"c1 ; c2\" := (CSeq c1 c2)\n+  (in custom expr_entry at level 20, right associativity).\n+Notation \"'skip'\" := (CSkip)\n+  (in custom expr_entry at level 10).\n+Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99,\n+   c2 custom expr_entry at level 99,\n+   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n+Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99).\n+\n+Notation \"⟦ e ⟧\" := (eval_expr e)\n+  (at level 0, only printing, e custom expr_entry at level 99).\n+Notation \"⟦ c ⟧\" := (eval_com c)\n+  (at level 0, only printing, c custom expr_entry at level 99).\n+\n+Ltac any_eval x :=\n+  match goal with\n+  | |- EDenote => exact (eval_expr x)\n+  | |- CDenote => exact (eval_com x)\n+  | _ => match type of x with\n+         | expr => exact (eval_expr x)\n+         | com => exact (eval_com x)\n+         end\n+  end.\n+\n+Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n+  (at level 0, only parsing, x custom expr_entry at level 99).\n+\n+Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n+  (no associativity, at level 61): sets_scope.\n+\n+(** 表达式语义等价 *)\n+\n+Record eequiv (e1 e2: expr): Prop := {\n+  nrm_eequiv:\n+    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n+  err_eequiv:\n+    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 表达式精化关系 *)\n+\n+Record erefine (e1 e2: expr): Prop := {\n+  nrm_erefine:\n+    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n+  err_erefine:\n+    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 程序语句语义等价 *)\n+\n+Record cequiv (c1 c2: com): Prop := {\n+  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n+  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n+  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n+}.\n+\n+(** 程序语句精化关系 *)\n+\n+Record crefine (c1 c2: com): Prop := {\n+  nrm_crefine:\n+    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n+  err_crefine:\n+    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n+  inf_crefine:\n+    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n+}.\n+\n+Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n+  (at level 69, only printing, no associativity).\n+\n+Ltac any_equiv x y :=\n+  match type of x with\n+  | expr => exact (eequiv x y)\n+  | com => exact (cequiv x y)\n+  | _ => match type of y with\n+         | expr => exact (eequiv x y)\n+         | com => exact (cequiv x y)\n+         end\n+  end.\n+\n+Ltac any_refine x y :=\n+  match type of x with\n+  | expr => exact (erefine x y)\n+  | com => exact (crefine x y)\n+  | _ => match type of y with\n+         | expr => exact (erefine x y)\n+         | com => exact (crefine x y)\n+         end\n+  end.\n+\n+Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n+  (at level 69, only parsing, no associativity).\n+Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n+  (at level 69, only parsing, no associativity).\n+\n+Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n+  (at level 1).\n+\n+(** 精化的例子 *)\n+\n+Lemma const_plus_const_refine: forall n m: Z,\n+  EConst (n + m) <<= [[n + m]].\n+(** 证明见Coq代码。*)\n+Proof.\n+  intros.\n+  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n+          n < Int64.min_signed \\/\n+          n > Int64.max_signed) as Hn by lia.\n+  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n+          m < Int64.min_signed \\/\n+          m > Int64.max_signed) as Hm by lia.\n+  split.\n+  + sets_unfold; intros s i ?.\n+    simpl in H.\n+    destruct H.\n+    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n+    - unfold arith_sem1_nrm, arith_compute1_nrm.\n+      exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H1.\n+      pose proof Int64.signed_repr _ H2.\n+      rewrite H3, H4.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+  + sets_unfold; intros s ?.\n+    simpl in H.\n+    simpl; sets_unfold.\n+    unfold arith_sem1_err, arith_compute1_err.\n+    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n+    - exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H0.\n+      pose proof Int64.signed_repr _ H1.\n+      rewrite H2, H3.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+Qed.\n+\n+(** 语义等价的例子：顺序执行有结合律 *)\n+\n+Theorem CSeq_assoc: forall (c1 c2 c3: com),\n+  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+Qed.\n+\n+\n+Theorem CIf_CSeq: forall e c1 c2 c3,\n+  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n+  [[ if e then { c1; c3 } else { c2; c3 } ]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite <- ! Rels_concat_assoc.\n+    apply Rels_concat_union_distr_r.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+\n+\n+\n+(** * 语义等价与精化的性质 *)\n+\n+\n+(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n+\n+\n+    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n+    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n+    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n+    将稍后再解释_[Instance]_关键字的特殊作用。*)\n+\n+Instance eequiv_refl: Reflexive eequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance eequiv_sym: Symmetric eequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_trans: Transitive eequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv), H0.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_equiv: Equivalence eequiv.\n+Proof.\n+  split.\n+  + apply eequiv_refl.\n+  + apply eequiv_sym.\n+  + apply eequiv_trans.\n+Qed.\n+\n+(** 下面还可以证明精化关系也具有自反性和传递性。*)\n+\n+Instance erefine_refl: Reflexive erefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+Qed.\n+\n+Instance erefine_trans: Transitive erefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_erefine).\n+    rewrite H0.(nrm_erefine).\n+    rewrite H0.(err_erefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_erefine).\n+    rewrite H0.(err_erefine).\n+    reflexivity.\n+Qed.\n+\n+(** 并且精化关系在语义等价变换下不变。*)\n+\n+Instance erefine_well_defined:\n+  Proper (eequiv ==> eequiv ==> iff) erefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_eequiv).\n+      rewrite <- H0.(nrm_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite <- H.(err_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+  + split.\n+    - rewrite H.(nrm_eequiv).\n+      rewrite H0.(nrm_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite H.(err_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+Qed.\n+\n+(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n+    性。*)\n+\n+Instance cequiv_refl: Reflexive cequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance cequiv_sym: Symmetric cequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_trans: Transitive cequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv), H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_equiv: Equivalence cequiv.\n+Proof.\n+  split.\n+  + apply cequiv_refl.\n+  + apply cequiv_sym.\n+  + apply cequiv_trans.\n+Qed.\n+\n+Instance crefine_refl: Reflexive crefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+  + apply Sets_included_union1.\n+Qed.\n+\n+Instance crefine_trans: Transitive crefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H0.(err_crefine).\n+    reflexivity.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance crefine_well_defined:\n+  Proper (cequiv ==> cequiv ==> iff) crefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_cequiv).\n+      rewrite <- H0.(nrm_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite <- H.(err_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite <- H.(inf_cequiv).\n+      rewrite <- H0.(inf_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+  + split.\n+    - rewrite H.(nrm_cequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite H.(err_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite H.(inf_cequiv).\n+      rewrite H0.(inf_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+Qed.\n+\n+\n+\n+(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n+\n+Lemma add_congr: forall (e11 e12 e21 e22: expr),\n+    e11 ~=~ e12 ->\n+    e21 ~=~ e22 ->\n+    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n+Proof.\n+  intros.\n+  split.\n+  + simpl. admit.\n+  + simpl.\n+Abort.\n+\n+(** Normal 对应相同 *)\n+Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem1_nrm.\n+  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+\n+(** Error 对应相同 *)\n+Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s.\n+  unfold arith_sem1_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem1_nrm, arith_sem1_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left. (** 只剩下最后一种求值都成功的情况 *)\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+(**证明精化后出错变少*)\n+Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem1_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+(** 很多其它情况的证明是类似的。*)\n+\n+Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem2_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold arith_sem2_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem2_nrm, arith_sem2_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem2_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold cmp_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  apply or_iff_morphism.\n+  + apply H.(err_eequiv).\n+  + apply H0.(err_eequiv).\n+Qed.\n+\n+Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold cmp_sem_nrm.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  intros [? | ?].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+Qed.\n+\n+Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold and_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold and_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold and_sem_nrm, and_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold and_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold or_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold or_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold or_sem_nrm, or_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold or_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+(** 下面把二元运算的情况汇总起来。*)\n+(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n+\n+Instance EBinop_congr: forall op,\n+  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - apply or_sem_nrm_congr; tauto.\n+    - apply or_sem_err_congr; tauto.\n+  + split.\n+    - apply and_sem_nrm_congr; tauto.\n+    - apply and_sem_err_congr; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+Qed.\n+\n+(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n+Instance EBinop_mono: forall op,\n+  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - simpl.\n+      apply (or_sem_nrm_mono x y x0 y0); tauto.\n+    - apply or_sem_err_mono; tauto.\n+  + split.\n+    - apply and_sem_nrm_mono; tauto.\n+    - apply and_sem_err_mono; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+Qed.\n+\n+(** 一元运算的情况是类似的。*)\n+\n+Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  not_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma not_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_eequiv).\n+Qed.\n+\n+Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma not_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_erefine).\n+Qed.\n+\n+Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  intros.\n+  unfold neg_sem_err; sets_unfold.\n+  intros s.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n+  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n+Proof.\n+  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma neg_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_err; sets_unfold.\n+  intros ? ? ? s ?.\n+  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n+  destruct H0 as [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  right; exists i1.\n+  tauto.\n+Qed.\n+\n+Instance EUnop_congr: forall op,\n+  Proper (eequiv ==> eequiv) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - apply not_sem_nrm_congr; tauto.\n+    - simpl. apply not_sem_err_congr; tauto.\n+  + split.\n+    - apply neg_sem_nrm_congr; tauto.\n+    - apply neg_sem_err_congr; tauto.\n+Qed.\n+\n+Instance EUnop_mono: forall op,\n+  Proper (erefine ==> erefine) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - simpl. apply not_sem_nrm_mono; tauto.\n+    - simpl. apply not_sem_err_mono; tauto.\n+  + split.\n+    - apply neg_sem_nrm_mono; tauto.\n+    - apply neg_sem_err_mono; tauto.\n+Qed.\n+\n+(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n+    性是比较显然的。*)\n+\n+Instance CSeq_congr:\n+  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(err_cequiv).\n+    rewrite H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(inf_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n+\n+Lemma Rels_times_full_concat2:\n+  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n+    (X × B) ∘ Y ⊆ X × C.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a c.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+Lemma Rels_times_full_concat1:\n+  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n+    (X × B) ∘ Y ⊆ X.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+(** 下面证明顺序执行能保持精化关系。*)\n+\n+Instance CSeq_mono:\n+  Proper (crefine ==> crefine ==> crefine) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite Rels_concat_union_distr_r.\n+    rewrite Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n+    _[test_false]_的性质。*)\n+\n+Lemma test_true_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_true ⟦ e1 ⟧ ⊆\n+  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  intros [ [i [? ?] ] ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; split; [| tauto].\n+  exists i; tauto.\n+Qed.\n+\n+Lemma test_false_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_false ⟦ e1 ⟧ ⊆\n+  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  intros [? ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  tauto.\n+Qed.\n+\n+Lemma test_true_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply ex_iff_morphism; intros i.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+Lemma test_false_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n+\n+Instance CIf_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H1.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H.(err_eequiv).\n+    rewrite H0.(err_cequiv).\n+    rewrite H1.(err_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(inf_cequiv).\n+    rewrite H1.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance CIf_mono:\n+  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(err_crefine), H1.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(inf_crefine), H1.(inf_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n+    的次数进行归纳。*)\n+\n+Instance CWhile_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  (** 正常运行终止的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite (test_false_congr _ _ H).\n+      rewrite H0.(nrm_cequiv).\n+      reflexivity.\n+  (** 运行出错的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite H.(err_eequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      reflexivity.\n+  (** 运行不终止的情况。*)\n+  + apply Sets_general_union_congr.\n+    intros X.\n+    unfold_CL_defs.\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    rewrite (test_true_congr _ _ H).\n+    reflexivity.\n+Qed.\n+\n+(** 要证明while语句保持精化关系就更复杂一些了。*)\n+\n+Definition boundedLB_nrm\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n+    ∅.\n+\n+Definition boundedLB_err\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n+    ∅.\n+\n+Definition is_inf\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (X: state -> Prop): Prop :=\n+  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n+      test_true D0 ∘ D1.(inf).\n+\n+Lemma boundedLB_nrm_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n+    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite (test_false_mono _ _ H).\n+    rewrite H0.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+Qed.\n+\n+Lemma boundedLB_err_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Sets_complement_indexed_union:\n+  forall {A I: Type} (Xs: I -> A -> Prop),\n+    Sets.complement (⋃ Xs) ==\n+    ⋂ (fun n => Sets.complement (Xs n)).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  split.\n+  + apply not_ex_all_not.\n+  + apply all_not_not_ex.\n+Qed.\n+\n+Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n+  Sets.complement (⋃ (boundedLB_err D1 D2)).\n+\n+Lemma iter_err_fact:\n+  forall (D1: EDenote) (D2: CDenote),\n+    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n+    ⋃ (boundedLB_err D1 D2).\n+Proof.\n+  intros.\n+  rewrite ! Rels_concat_indexed_union_distr_l.\n+  apply Sets_indexed_union_included; intros n.\n+  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n+  simpl.\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Rels_concat_excluding_r:\n+  forall\n+    {A B: Type}\n+    (R: A -> B -> Prop)\n+    (S T: B -> Prop),\n+    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n+    R ∘ (S ∩ Sets.complement T).\n+Proof.\n+  intros.\n+  Sets_unfold; intros a.\n+  intros [ [b [? ?] ] ?].\n+  exists b.\n+  split; [tauto |].\n+  split; [tauto |].\n+  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n+  clear H1; intros.\n+  exists b; tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact1:\n+  forall (D1: EDenote) (D2: CDenote),\n+    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact2:\n+  forall (D1: EDenote) (D2: CDenote),\n+    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma inf_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) X,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n+    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+Proof.\n+  unfold is_inf.\n+  intros.\n+  rewrite H1 at 1.\n+  rewrite (test_true_mono _ _ H).\n+  rewrite H0.(nrm_crefine).\n+  rewrite H0.(inf_crefine).\n+  rewrite ! Rels_concat_union_distr_r.\n+  rewrite ! Rels_concat_union_distr_l.\n+  rewrite ! Rels_times_full_concat1.\n+  rewrite ! Sets_intersect_union_distr_r.\n+  rewrite noerrorLB_fact1.\n+  rewrite noerrorLB_fact2.\n+  rewrite ! Sets_union_empty.\n+  unfold noerrorLB at 1.\n+  rewrite <- iter_err_fact at 1.\n+  rewrite ! Rels_concat_excluding_r.\n+  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance CWhile_mono:\n+  Proper (erefine ==> crefine ==> crefine) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- ! (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_nrm_mono_aux; tauto.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_err_mono_aux; tauto.\n+  + apply Sets_general_union_included. unfold_CL_defs.\n+    intros X ?.\n+    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n+    unfold KT_GFix; unfold_CL_defs.\n+    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n+      by (exact H2).\n+    unfold noerrorLB.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n+\n+Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n+  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n+  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n+Proof.\n+  intros.\n+  rewrite CSeq_assoc.\n+  rewrite CIf_CSeq.\n+  reflexivity.\n+Qed.\n+\n"
                },
                {
                    "date": 1699338902124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -577,9 +577,9 @@\n     sets_unfold in H1.\n     sets_unfold in H2.\n     destruct H1; [| tauto].\n     destruct H2; [| tauto].\n-    right.\n+    right. (** 选择最右边的那一种*)\n     exists i1, i2.\n     tauto.\n Qed.\n \n@@ -1580,3168 +1580,4 @@\n   rewrite CIf_CSeq.\n   reflexivity.\n Qed.\n \n-Require Import Coq.ZArith.ZArith.\n-Require Import Coq.micromega.Psatz.\n-Require Import Coq.Strings.String.\n-Require Import Coq.Classes.Morphisms.\n-Require Import Coq.Classes.Morphisms_Prop.\n-Require Import Coq.Classes.RelationClasses.\n-Require Import Coq.Logic.Classical_Pred_Type.\n-Require Import Coq.Logic.Classical_Prop.\n-Require Import SetsClass.SetsClass. Import SetsNotation.\n-Require Import compcert.lib.Integers.\n-Require Import PL.SyntaxInCoq.\n-Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n-Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n-Import Lang_While DntSem_While1 DntSem_While2.\n-Import EDenote CDenote.\n-Local Open Scope string.\n-Local Open Scope Z.\n-Local Open Scope sets.\n-\n-(** * 定义与例子 *)\n-\n-Definition EVar': string -> expr := EVar.\n-Coercion EConst: Z >-> expr.\n-Coercion EVar: var_name >-> expr.\n-Coercion EVar': string >-> expr.\n-Notation \"[[ e ]]\" := e\n-  (at level 0, e custom expr_entry at level 99).\n-Notation \"( x )\" := x\n-  (in custom expr_entry, x custom expr_entry at level 99).\n-Notation \"x\" := x\n-  (in custom expr_entry at level 0, x constr at level 0).\n-Notation \"f x\" := (f x)\n-  (in custom expr_entry at level 1, only parsing,\n-   f custom expr_entry,\n-   x custom expr_entry at level 0).\n-Notation \"x + y\" := (EBinop OPlus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x - y\" := (EBinop OMinus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x * y\" := (EBinop OMul x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x / y\" := (EBinop ODiv x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x % y\" := (EBinop OMod x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x <= y\" := (EBinop OLe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x < y\" := (EBinop OLt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x >= y\" := (EBinop OGe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x > y\" := (EBinop OGt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x == y\" := (EBinop OEq x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x != y\" := (EBinop ONe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x && y\" := (EBinop OAnd x y)\n-  (in custom expr_entry at level 14, left associativity).\n-Notation \"x || y\" := (EBinop OOr x y)\n-  (in custom expr_entry at level 15, left associativity).\n-Notation \"! x\" := (EUnop ONot x)\n-  (in custom expr_entry at level 10).\n-Notation \"- x\" := (EUnop ONeg x)\n-  (in custom expr_entry at level 10).\n-Notation \"c1 ; c2\" := (CSeq c1 c2)\n-  (in custom expr_entry at level 20, right associativity).\n-Notation \"'skip'\" := (CSkip)\n-  (in custom expr_entry at level 10).\n-Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99,\n-   c2 custom expr_entry at level 99,\n-   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n-Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99).\n-\n-Notation \"⟦ e ⟧\" := (eval_expr e)\n-  (at level 0, only printing, e custom expr_entry at level 99).\n-Notation \"⟦ c ⟧\" := (eval_com c)\n-  (at level 0, only printing, c custom expr_entry at level 99).\n-\n-Ltac any_eval x :=\n-  match goal with\n-  | |- EDenote => exact (eval_expr x)\n-  | |- CDenote => exact (eval_com x)\n-  | _ => match type of x with\n-         | expr => exact (eval_expr x)\n-         | com => exact (eval_com x)\n-         end\n-  end.\n-\n-Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n-  (at level 0, only parsing, x custom expr_entry at level 99).\n-\n-Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n-  (no associativity, at level 61): sets_scope.\n-\n-(** 表达式语义等价 *)\n-\n-Record eequiv (e1 e2: expr): Prop := {\n-  nrm_eequiv:\n-    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n-  err_eequiv:\n-    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 表达式精化关系 *)\n-\n-Record erefine (e1 e2: expr): Prop := {\n-  nrm_erefine:\n-    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n-  err_erefine:\n-    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 程序语句语义等价 *)\n-\n-Record cequiv (c1 c2: com): Prop := {\n-  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n-  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n-  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n-}.\n-\n-(** 程序语句精化关系 *)\n-\n-Record crefine (c1 c2: com): Prop := {\n-  nrm_crefine:\n-    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n-  err_crefine:\n-    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n-  inf_crefine:\n-    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n-}.\n-\n-Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n-  (at level 69, only printing, no associativity).\n-\n-Ltac any_equiv x y :=\n-  match type of x with\n-  | expr => exact (eequiv x y)\n-  | com => exact (cequiv x y)\n-  | _ => match type of y with\n-         | expr => exact (eequiv x y)\n-         | com => exact (cequiv x y)\n-         end\n-  end.\n-\n-Ltac any_refine x y :=\n-  match type of x with\n-  | expr => exact (erefine x y)\n-  | com => exact (crefine x y)\n-  | _ => match type of y with\n-         | expr => exact (erefine x y)\n-         | com => exact (crefine x y)\n-         end\n-  end.\n-\n-Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n-  (at level 69, only parsing, no associativity).\n-Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n-  (at level 69, only parsing, no associativity).\n-\n-Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n-  (at level 1).\n-\n-(** 精化的例子 *)\n-\n-Lemma const_plus_const_refine: forall n m: Z,\n-  EConst (n + m) <<= [[n + m]].\n-(** 证明见Coq代码。*)\n-Proof.\n-  intros.\n-  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n-          n < Int64.min_signed \\/\n-          n > Int64.max_signed) as Hn by lia.\n-  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n-          m < Int64.min_signed \\/\n-          m > Int64.max_signed) as Hm by lia.\n-  split.\n-  + sets_unfold; intros s i ?.\n-    simpl in H.\n-    destruct H.\n-    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n-    - unfold arith_sem1_nrm, arith_compute1_nrm.\n-      exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H1.\n-      pose proof Int64.signed_repr _ H2.\n-      rewrite H3, H4.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-  + sets_unfold; intros s ?.\n-    simpl in H.\n-    simpl; sets_unfold.\n-    unfold arith_sem1_err, arith_compute1_err.\n-    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n-    - exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H0.\n-      pose proof Int64.signed_repr _ H1.\n-      rewrite H2, H3.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-Qed.\n-\n-(** 语义等价的例子：顺序执行有结合律 *)\n-\n-Theorem CSeq_assoc: forall (c1 c2 c3: com),\n-  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-Qed.\n-\n-\n-Theorem CIf_CSeq: forall e c1 c2 c3,\n-  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n-  [[ if e then { c1; c3 } else { c2; c3 } ]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite <- ! Rels_concat_assoc.\n-    apply Rels_concat_union_distr_r.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-\n-\n-\n-(** * 语义等价与精化的性质 *)\n-\n-\n-(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n-\n-\n-    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n-    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n-    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n-    将稍后再解释_[Instance]_关键字的特殊作用。*)\n-\n-Instance eequiv_refl: Reflexive eequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance eequiv_sym: Symmetric eequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_trans: Transitive eequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv), H0.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_equiv: Equivalence eequiv.\n-Proof.\n-  split.\n-  + apply eequiv_refl.\n-  + apply eequiv_sym.\n-  + apply eequiv_trans.\n-Qed.\n-\n-(** 下面还可以证明精化关系也具有自反性和传递性。*)\n-\n-Instance erefine_refl: Reflexive erefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-Qed.\n-\n-Instance erefine_trans: Transitive erefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_erefine).\n-    rewrite H0.(nrm_erefine).\n-    rewrite H0.(err_erefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_erefine).\n-    rewrite H0.(err_erefine).\n-    reflexivity.\n-Qed.\n-\n-(** 并且精化关系在语义等价变换下不变。*)\n-\n-Instance erefine_well_defined:\n-  Proper (eequiv ==> eequiv ==> iff) erefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_eequiv).\n-      rewrite <- H0.(nrm_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite <- H.(err_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-  + split.\n-    - rewrite H.(nrm_eequiv).\n-      rewrite H0.(nrm_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite H.(err_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-Qed.\n-\n-(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n-    性。*)\n-\n-Instance cequiv_refl: Reflexive cequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance cequiv_sym: Symmetric cequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_trans: Transitive cequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv), H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_equiv: Equivalence cequiv.\n-Proof.\n-  split.\n-  + apply cequiv_refl.\n-  + apply cequiv_sym.\n-  + apply cequiv_trans.\n-Qed.\n-\n-Instance crefine_refl: Reflexive crefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-  + apply Sets_included_union1.\n-Qed.\n-\n-Instance crefine_trans: Transitive crefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H0.(err_crefine).\n-    reflexivity.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance crefine_well_defined:\n-  Proper (cequiv ==> cequiv ==> iff) crefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_cequiv).\n-      rewrite <- H0.(nrm_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite <- H.(err_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite <- H.(inf_cequiv).\n-      rewrite <- H0.(inf_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-  + split.\n-    - rewrite H.(nrm_cequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite H.(err_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite H.(inf_cequiv).\n-      rewrite H0.(inf_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-Qed.\n-\n-\n-\n-(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n-\n-Lemma add_congr: forall (e11 e12 e21 e22: expr),\n-    e11 ~=~ e12 ->\n-    e21 ~=~ e22 ->\n-    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n-Proof.\n-  intros.\n-  split.\n-  + simpl. admit.\n-  + simpl.\n-Abort.\n-\n-(** Normal 对应相同 *)\n-Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem1_nrm.\n-  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-\n-(** Error 对应相同 *)\n-Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s.\n-  unfold arith_sem1_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem1_nrm, arith_sem1_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left. (** 只剩下最后一种求值都成功的情况 *)\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem1_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-(** 很多其它情况的证明是类似的。*)\n-\n-Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem2_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold arith_sem2_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem2_nrm, arith_sem2_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem2_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold cmp_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  apply or_iff_morphism.\n-  + apply H.(err_eequiv).\n-  + apply H0.(err_eequiv).\n-Qed.\n-\n-Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold cmp_sem_nrm.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  intros [? | ?].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-Qed.\n-\n-Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold and_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold and_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold and_sem_nrm, and_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold and_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold or_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold or_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold or_sem_nrm, or_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold or_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-(** 下面把二元运算的情况汇总起来。*)\n-(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n-\n-Instance EBinop_congr: forall op,\n-  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - apply or_sem_nrm_congr; tauto.\n-    - apply or_sem_err_congr; tauto.\n-  + split.\n-    - apply and_sem_nrm_congr; tauto.\n-    - apply and_sem_err_congr; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-Qed.\n-\n-(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n-Instance EBinop_mono: forall op,\n-  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - simpl.\n-      apply (or_sem_nrm_mono x y x0 y0); tauto.\n-    - apply or_sem_err_mono; tauto.\n-  + split.\n-    - apply and_sem_nrm_mono; tauto.\n-    - apply and_sem_err_mono; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-Qed.\n-\n-(** 一元运算的情况是类似的。*)\n-\n-Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  not_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma not_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_eequiv).\n-Qed.\n-\n-Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma not_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_erefine).\n-Qed.\n-\n-Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  intros.\n-  unfold neg_sem_err; sets_unfold.\n-  intros s.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n-  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n-Proof.\n-  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma neg_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_err; sets_unfold.\n-  intros ? ? ? s ?.\n-  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n-  destruct H0 as [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  right; exists i1.\n-  tauto.\n-Qed.\n-\n-Instance EUnop_congr: forall op,\n-  Proper (eequiv ==> eequiv) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - apply not_sem_nrm_congr; tauto.\n-    - simpl. apply not_sem_err_congr; tauto.\n-  + split.\n-    - apply neg_sem_nrm_congr; tauto.\n-    - apply neg_sem_err_congr; tauto.\n-Qed.\n-\n-Instance EUnop_mono: forall op,\n-  Proper (erefine ==> erefine) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - simpl. apply not_sem_nrm_mono; tauto.\n-    - simpl. apply not_sem_err_mono; tauto.\n-  + split.\n-    - apply neg_sem_nrm_mono; tauto.\n-    - apply neg_sem_err_mono; tauto.\n-Qed.\n-\n-(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n-    性是比较显然的。*)\n-\n-Instance CSeq_congr:\n-  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(err_cequiv).\n-    rewrite H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(inf_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n-\n-Lemma Rels_times_full_concat2:\n-  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n-    (X × B) ∘ Y ⊆ X × C.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a c.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-Lemma Rels_times_full_concat1:\n-  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n-    (X × B) ∘ Y ⊆ X.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-(** 下面证明顺序执行能保持精化关系。*)\n-\n-Instance CSeq_mono:\n-  Proper (crefine ==> crefine ==> crefine) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite Rels_concat_union_distr_r.\n-    rewrite Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n-    _[test_false]_的性质。*)\n-\n-Lemma test_true_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_true ⟦ e1 ⟧ ⊆\n-  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  intros [ [i [? ?] ] ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; split; [| tauto].\n-  exists i; tauto.\n-Qed.\n-\n-Lemma test_false_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_false ⟦ e1 ⟧ ⊆\n-  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  intros [? ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  tauto.\n-Qed.\n-\n-Lemma test_true_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply ex_iff_morphism; intros i.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-Lemma test_false_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n-\n-Instance CIf_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H1.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H.(err_eequiv).\n-    rewrite H0.(err_cequiv).\n-    rewrite H1.(err_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(inf_cequiv).\n-    rewrite H1.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance CIf_mono:\n-  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(err_crefine), H1.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(inf_crefine), H1.(inf_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n-    的次数进行归纳。*)\n-\n-Instance CWhile_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  (** 正常运行终止的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite (test_false_congr _ _ H).\n-      rewrite H0.(nrm_cequiv).\n-      reflexivity.\n-  (** 运行出错的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite H.(err_eequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      reflexivity.\n-  (** 运行不终止的情况。*)\n-  + apply Sets_general_union_congr.\n-    intros X.\n-    unfold_CL_defs.\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    rewrite (test_true_congr _ _ H).\n-    reflexivity.\n-Qed.\n-\n-(** 要证明while语句保持精化关系就更复杂一些了。*)\n-\n-Definition boundedLB_nrm\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n-    ∅.\n-\n-Definition boundedLB_err\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n-    ∅.\n-\n-Definition is_inf\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (X: state -> Prop): Prop :=\n-  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n-      test_true D0 ∘ D1.(inf).\n-\n-Lemma boundedLB_nrm_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n-    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite (test_false_mono _ _ H).\n-    rewrite H0.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-Qed.\n-\n-Lemma boundedLB_err_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Sets_complement_indexed_union:\n-  forall {A I: Type} (Xs: I -> A -> Prop),\n-    Sets.complement (⋃ Xs) ==\n-    ⋂ (fun n => Sets.complement (Xs n)).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  split.\n-  + apply not_ex_all_not.\n-  + apply all_not_not_ex.\n-Qed.\n-\n-Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n-  Sets.complement (⋃ (boundedLB_err D1 D2)).\n-\n-Lemma iter_err_fact:\n-  forall (D1: EDenote) (D2: CDenote),\n-    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n-    ⋃ (boundedLB_err D1 D2).\n-Proof.\n-  intros.\n-  rewrite ! Rels_concat_indexed_union_distr_l.\n-  apply Sets_indexed_union_included; intros n.\n-  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n-  simpl.\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Rels_concat_excluding_r:\n-  forall\n-    {A B: Type}\n-    (R: A -> B -> Prop)\n-    (S T: B -> Prop),\n-    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n-    R ∘ (S ∩ Sets.complement T).\n-Proof.\n-  intros.\n-  Sets_unfold; intros a.\n-  intros [ [b [? ?] ] ?].\n-  exists b.\n-  split; [tauto |].\n-  split; [tauto |].\n-  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n-  clear H1; intros.\n-  exists b; tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact1:\n-  forall (D1: EDenote) (D2: CDenote),\n-    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact2:\n-  forall (D1: EDenote) (D2: CDenote),\n-    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma inf_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) X,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n-    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-Proof.\n-  unfold is_inf.\n-  intros.\n-  rewrite H1 at 1.\n-  rewrite (test_true_mono _ _ H).\n-  rewrite H0.(nrm_crefine).\n-  rewrite H0.(inf_crefine).\n-  rewrite ! Rels_concat_union_distr_r.\n-  rewrite ! Rels_concat_union_distr_l.\n-  rewrite ! Rels_times_full_concat1.\n-  rewrite ! Sets_intersect_union_distr_r.\n-  rewrite noerrorLB_fact1.\n-  rewrite noerrorLB_fact2.\n-  rewrite ! Sets_union_empty.\n-  unfold noerrorLB at 1.\n-  rewrite <- iter_err_fact at 1.\n-  rewrite ! Rels_concat_excluding_r.\n-  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance CWhile_mono:\n-  Proper (erefine ==> crefine ==> crefine) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_nrm_mono_aux; tauto.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_err_mono_aux; tauto.\n-  + apply Sets_general_union_included. unfold_CL_defs.\n-    intros X ?.\n-    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n-    unfold KT_GFix; unfold_CL_defs.\n-    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n-      by (exact H2).\n-    unfold noerrorLB.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n-\n-Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n-  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n-  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n-Proof.\n-  intros.\n-  rewrite CSeq_assoc.\n-  rewrite CIf_CSeq.\n-  reflexivity.\n-Qed.\n-\n-Require Import Coq.ZArith.ZArith.\n-Require Import Coq.micromega.Psatz.\n-Require Import Coq.Strings.String.\n-Require Import Coq.Classes.Morphisms.\n-Require Import Coq.Classes.Morphisms_Prop.\n-Require Import Coq.Classes.RelationClasses.\n-Require Import Coq.Logic.Classical_Pred_Type.\n-Require Import Coq.Logic.Classical_Prop.\n-Require Import SetsClass.SetsClass. Import SetsNotation.\n-Require Import compcert.lib.Integers.\n-Require Import PL.SyntaxInCoq.\n-Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n-Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n-Import Lang_While DntSem_While1 DntSem_While2.\n-Import EDenote CDenote.\n-Local Open Scope string.\n-Local Open Scope Z.\n-Local Open Scope sets.\n-\n-(** * 定义与例子 *)\n-\n-Definition EVar': string -> expr := EVar.\n-Coercion EConst: Z >-> expr.\n-Coercion EVar: var_name >-> expr.\n-Coercion EVar': string >-> expr.\n-Notation \"[[ e ]]\" := e\n-  (at level 0, e custom expr_entry at level 99).\n-Notation \"( x )\" := x\n-  (in custom expr_entry, x custom expr_entry at level 99).\n-Notation \"x\" := x\n-  (in custom expr_entry at level 0, x constr at level 0).\n-Notation \"f x\" := (f x)\n-  (in custom expr_entry at level 1, only parsing,\n-   f custom expr_entry,\n-   x custom expr_entry at level 0).\n-Notation \"x + y\" := (EBinop OPlus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x - y\" := (EBinop OMinus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x * y\" := (EBinop OMul x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x / y\" := (EBinop ODiv x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x % y\" := (EBinop OMod x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x <= y\" := (EBinop OLe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x < y\" := (EBinop OLt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x >= y\" := (EBinop OGe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x > y\" := (EBinop OGt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x == y\" := (EBinop OEq x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x != y\" := (EBinop ONe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x && y\" := (EBinop OAnd x y)\n-  (in custom expr_entry at level 14, left associativity).\n-Notation \"x || y\" := (EBinop OOr x y)\n-  (in custom expr_entry at level 15, left associativity).\n-Notation \"! x\" := (EUnop ONot x)\n-  (in custom expr_entry at level 10).\n-Notation \"- x\" := (EUnop ONeg x)\n-  (in custom expr_entry at level 10).\n-Notation \"c1 ; c2\" := (CSeq c1 c2)\n-  (in custom expr_entry at level 20, right associativity).\n-Notation \"'skip'\" := (CSkip)\n-  (in custom expr_entry at level 10).\n-Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99,\n-   c2 custom expr_entry at level 99,\n-   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n-Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99).\n-\n-Notation \"⟦ e ⟧\" := (eval_expr e)\n-  (at level 0, only printing, e custom expr_entry at level 99).\n-Notation \"⟦ c ⟧\" := (eval_com c)\n-  (at level 0, only printing, c custom expr_entry at level 99).\n-\n-Ltac any_eval x :=\n-  match goal with\n-  | |- EDenote => exact (eval_expr x)\n-  | |- CDenote => exact (eval_com x)\n-  | _ => match type of x with\n-         | expr => exact (eval_expr x)\n-         | com => exact (eval_com x)\n-         end\n-  end.\n-\n-Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n-  (at level 0, only parsing, x custom expr_entry at level 99).\n-\n-Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n-  (no associativity, at level 61): sets_scope.\n-\n-(** 表达式语义等价 *)\n-\n-Record eequiv (e1 e2: expr): Prop := {\n-  nrm_eequiv:\n-    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n-  err_eequiv:\n-    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 表达式精化关系 *)\n-\n-Record erefine (e1 e2: expr): Prop := {\n-  nrm_erefine:\n-    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n-  err_erefine:\n-    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 程序语句语义等价 *)\n-\n-Record cequiv (c1 c2: com): Prop := {\n-  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n-  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n-  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n-}.\n-\n-(** 程序语句精化关系 *)\n-\n-Record crefine (c1 c2: com): Prop := {\n-  nrm_crefine:\n-    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n-  err_crefine:\n-    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n-  inf_crefine:\n-    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n-}.\n-\n-Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n-  (at level 69, only printing, no associativity).\n-\n-Ltac any_equiv x y :=\n-  match type of x with\n-  | expr => exact (eequiv x y)\n-  | com => exact (cequiv x y)\n-  | _ => match type of y with\n-         | expr => exact (eequiv x y)\n-         | com => exact (cequiv x y)\n-         end\n-  end.\n-\n-Ltac any_refine x y :=\n-  match type of x with\n-  | expr => exact (erefine x y)\n-  | com => exact (crefine x y)\n-  | _ => match type of y with\n-         | expr => exact (erefine x y)\n-         | com => exact (crefine x y)\n-         end\n-  end.\n-\n-Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n-  (at level 69, only parsing, no associativity).\n-Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n-  (at level 69, only parsing, no associativity).\n-\n-Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n-  (at level 1).\n-\n-(** 精化的例子 *)\n-\n-Lemma const_plus_const_refine: forall n m: Z,\n-  EConst (n + m) <<= [[n + m]].\n-(** 证明见Coq代码。*)\n-Proof.\n-  intros.\n-  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n-          n < Int64.min_signed \\/\n-          n > Int64.max_signed) as Hn by lia.\n-  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n-          m < Int64.min_signed \\/\n-          m > Int64.max_signed) as Hm by lia.\n-  split.\n-  + sets_unfold; intros s i ?.\n-    simpl in H.\n-    destruct H.\n-    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n-    - unfold arith_sem1_nrm, arith_compute1_nrm.\n-      exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H1.\n-      pose proof Int64.signed_repr _ H2.\n-      rewrite H3, H4.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-  + sets_unfold; intros s ?.\n-    simpl in H.\n-    simpl; sets_unfold.\n-    unfold arith_sem1_err, arith_compute1_err.\n-    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n-    - exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H0.\n-      pose proof Int64.signed_repr _ H1.\n-      rewrite H2, H3.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-Qed.\n-\n-(** 语义等价的例子：顺序执行有结合律 *)\n-\n-Theorem CSeq_assoc: forall (c1 c2 c3: com),\n-  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-Qed.\n-\n-\n-Theorem CIf_CSeq: forall e c1 c2 c3,\n-  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n-  [[ if e then { c1; c3 } else { c2; c3 } ]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite <- ! Rels_concat_assoc.\n-    apply Rels_concat_union_distr_r.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-\n-\n-\n-(** * 语义等价与精化的性质 *)\n-\n-\n-(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n-\n-\n-    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n-    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n-    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n-    将稍后再解释_[Instance]_关键字的特殊作用。*)\n-\n-Instance eequiv_refl: Reflexive eequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance eequiv_sym: Symmetric eequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_trans: Transitive eequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv), H0.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_equiv: Equivalence eequiv.\n-Proof.\n-  split.\n-  + apply eequiv_refl.\n-  + apply eequiv_sym.\n-  + apply eequiv_trans.\n-Qed.\n-\n-(** 下面还可以证明精化关系也具有自反性和传递性。*)\n-\n-Instance erefine_refl: Reflexive erefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-Qed.\n-\n-Instance erefine_trans: Transitive erefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_erefine).\n-    rewrite H0.(nrm_erefine).\n-    rewrite H0.(err_erefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_erefine).\n-    rewrite H0.(err_erefine).\n-    reflexivity.\n-Qed.\n-\n-(** 并且精化关系在语义等价变换下不变。*)\n-\n-Instance erefine_well_defined:\n-  Proper (eequiv ==> eequiv ==> iff) erefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_eequiv).\n-      rewrite <- H0.(nrm_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite <- H.(err_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-  + split.\n-    - rewrite H.(nrm_eequiv).\n-      rewrite H0.(nrm_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite H.(err_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-Qed.\n-\n-(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n-    性。*)\n-\n-Instance cequiv_refl: Reflexive cequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance cequiv_sym: Symmetric cequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_trans: Transitive cequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv), H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_equiv: Equivalence cequiv.\n-Proof.\n-  split.\n-  + apply cequiv_refl.\n-  + apply cequiv_sym.\n-  + apply cequiv_trans.\n-Qed.\n-\n-Instance crefine_refl: Reflexive crefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-  + apply Sets_included_union1.\n-Qed.\n-\n-Instance crefine_trans: Transitive crefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H0.(err_crefine).\n-    reflexivity.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance crefine_well_defined:\n-  Proper (cequiv ==> cequiv ==> iff) crefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_cequiv).\n-      rewrite <- H0.(nrm_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite <- H.(err_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite <- H.(inf_cequiv).\n-      rewrite <- H0.(inf_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-  + split.\n-    - rewrite H.(nrm_cequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite H.(err_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite H.(inf_cequiv).\n-      rewrite H0.(inf_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-Qed.\n-\n-\n-\n-(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n-\n-Lemma add_congr: forall (e11 e12 e21 e22: expr),\n-    e11 ~=~ e12 ->\n-    e21 ~=~ e22 ->\n-    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n-Proof.\n-  intros.\n-  split.\n-  + simpl. admit.\n-  + simpl.\n-Abort.\n-\n-(** Normal 对应相同 *)\n-Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem1_nrm.\n-  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-\n-(** Error 对应相同 *)\n-Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s.\n-  unfold arith_sem1_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem1_nrm, arith_sem1_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left. (** 只剩下最后一种求值都成功的情况 *)\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem1_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-(** 很多其它情况的证明是类似的。*)\n-\n-Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem2_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold arith_sem2_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem2_nrm, arith_sem2_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem2_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold cmp_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  apply or_iff_morphism.\n-  + apply H.(err_eequiv).\n-  + apply H0.(err_eequiv).\n-Qed.\n-\n-Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold cmp_sem_nrm.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  intros [? | ?].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-Qed.\n-\n-Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold and_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold and_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold and_sem_nrm, and_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold and_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold or_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold or_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold or_sem_nrm, or_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold or_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-(** 下面把二元运算的情况汇总起来。*)\n-(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n-\n-Instance EBinop_congr: forall op,\n-  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - apply or_sem_nrm_congr; tauto.\n-    - apply or_sem_err_congr; tauto.\n-  + split.\n-    - apply and_sem_nrm_congr; tauto.\n-    - apply and_sem_err_congr; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-Qed.\n-\n-(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n-Instance EBinop_mono: forall op,\n-  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - simpl.\n-      apply (or_sem_nrm_mono x y x0 y0); tauto.\n-    - apply or_sem_err_mono; tauto.\n-  + split.\n-    - apply and_sem_nrm_mono; tauto.\n-    - apply and_sem_err_mono; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-Qed.\n-\n-(** 一元运算的情况是类似的。*)\n-\n-Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  not_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma not_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_eequiv).\n-Qed.\n-\n-Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma not_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_erefine).\n-Qed.\n-\n-Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  intros.\n-  unfold neg_sem_err; sets_unfold.\n-  intros s.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n-  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n-Proof.\n-  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma neg_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_err; sets_unfold.\n-  intros ? ? ? s ?.\n-  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n-  destruct H0 as [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  right; exists i1.\n-  tauto.\n-Qed.\n-\n-Instance EUnop_congr: forall op,\n-  Proper (eequiv ==> eequiv) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - apply not_sem_nrm_congr; tauto.\n-    - simpl. apply not_sem_err_congr; tauto.\n-  + split.\n-    - apply neg_sem_nrm_congr; tauto.\n-    - apply neg_sem_err_congr; tauto.\n-Qed.\n-\n-Instance EUnop_mono: forall op,\n-  Proper (erefine ==> erefine) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - simpl. apply not_sem_nrm_mono; tauto.\n-    - simpl. apply not_sem_err_mono; tauto.\n-  + split.\n-    - apply neg_sem_nrm_mono; tauto.\n-    - apply neg_sem_err_mono; tauto.\n-Qed.\n-\n-(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n-    性是比较显然的。*)\n-\n-Instance CSeq_congr:\n-  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(err_cequiv).\n-    rewrite H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(inf_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n-\n-Lemma Rels_times_full_concat2:\n-  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n-    (X × B) ∘ Y ⊆ X × C.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a c.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-Lemma Rels_times_full_concat1:\n-  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n-    (X × B) ∘ Y ⊆ X.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-(** 下面证明顺序执行能保持精化关系。*)\n-\n-Instance CSeq_mono:\n-  Proper (crefine ==> crefine ==> crefine) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite Rels_concat_union_distr_r.\n-    rewrite Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n-    _[test_false]_的性质。*)\n-\n-Lemma test_true_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_true ⟦ e1 ⟧ ⊆\n-  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  intros [ [i [? ?] ] ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; split; [| tauto].\n-  exists i; tauto.\n-Qed.\n-\n-Lemma test_false_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_false ⟦ e1 ⟧ ⊆\n-  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  intros [? ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  tauto.\n-Qed.\n-\n-Lemma test_true_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply ex_iff_morphism; intros i.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-Lemma test_false_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n-\n-Instance CIf_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H1.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H.(err_eequiv).\n-    rewrite H0.(err_cequiv).\n-    rewrite H1.(err_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(inf_cequiv).\n-    rewrite H1.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance CIf_mono:\n-  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(err_crefine), H1.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(inf_crefine), H1.(inf_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n-    的次数进行归纳。*)\n-\n-Instance CWhile_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  (** 正常运行终止的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite (test_false_congr _ _ H).\n-      rewrite H0.(nrm_cequiv).\n-      reflexivity.\n-  (** 运行出错的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite H.(err_eequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      reflexivity.\n-  (** 运行不终止的情况。*)\n-  + apply Sets_general_union_congr.\n-    intros X.\n-    unfold_CL_defs.\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    rewrite (test_true_congr _ _ H).\n-    reflexivity.\n-Qed.\n-\n-(** 要证明while语句保持精化关系就更复杂一些了。*)\n-\n-Definition boundedLB_nrm\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n-    ∅.\n-\n-Definition boundedLB_err\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n-    ∅.\n-\n-Definition is_inf\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (X: state -> Prop): Prop :=\n-  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n-      test_true D0 ∘ D1.(inf).\n-\n-Lemma boundedLB_nrm_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n-    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite (test_false_mono _ _ H).\n-    rewrite H0.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-Qed.\n-\n-Lemma boundedLB_err_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Sets_complement_indexed_union:\n-  forall {A I: Type} (Xs: I -> A -> Prop),\n-    Sets.complement (⋃ Xs) ==\n-    ⋂ (fun n => Sets.complement (Xs n)).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  split.\n-  + apply not_ex_all_not.\n-  + apply all_not_not_ex.\n-Qed.\n-\n-Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n-  Sets.complement (⋃ (boundedLB_err D1 D2)).\n-\n-Lemma iter_err_fact:\n-  forall (D1: EDenote) (D2: CDenote),\n-    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n-    ⋃ (boundedLB_err D1 D2).\n-Proof.\n-  intros.\n-  rewrite ! Rels_concat_indexed_union_distr_l.\n-  apply Sets_indexed_union_included; intros n.\n-  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n-  simpl.\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Rels_concat_excluding_r:\n-  forall\n-    {A B: Type}\n-    (R: A -> B -> Prop)\n-    (S T: B -> Prop),\n-    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n-    R ∘ (S ∩ Sets.complement T).\n-Proof.\n-  intros.\n-  Sets_unfold; intros a.\n-  intros [ [b [? ?] ] ?].\n-  exists b.\n-  split; [tauto |].\n-  split; [tauto |].\n-  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n-  clear H1; intros.\n-  exists b; tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact1:\n-  forall (D1: EDenote) (D2: CDenote),\n-    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact2:\n-  forall (D1: EDenote) (D2: CDenote),\n-    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma inf_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) X,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n-    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-Proof.\n-  unfold is_inf.\n-  intros.\n-  rewrite H1 at 1.\n-  rewrite (test_true_mono _ _ H).\n-  rewrite H0.(nrm_crefine).\n-  rewrite H0.(inf_crefine).\n-  rewrite ! Rels_concat_union_distr_r.\n-  rewrite ! Rels_concat_union_distr_l.\n-  rewrite ! Rels_times_full_concat1.\n-  rewrite ! Sets_intersect_union_distr_r.\n-  rewrite noerrorLB_fact1.\n-  rewrite noerrorLB_fact2.\n-  rewrite ! Sets_union_empty.\n-  unfold noerrorLB at 1.\n-  rewrite <- iter_err_fact at 1.\n-  rewrite ! Rels_concat_excluding_r.\n-  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance CWhile_mono:\n-  Proper (erefine ==> crefine ==> crefine) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_nrm_mono_aux; tauto.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_err_mono_aux; tauto.\n-  + apply Sets_general_union_included. unfold_CL_defs.\n-    intros X ?.\n-    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n-    unfold KT_GFix; unfold_CL_defs.\n-    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n-      by (exact H2).\n-    unfold noerrorLB.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n-\n-Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n-  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n-  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n-Proof.\n-  intros.\n-  rewrite CSeq_assoc.\n-  rewrite CIf_CSeq.\n-  reflexivity.\n-Qed.\n-\n"
                },
                {
                    "date": 1699338912132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -577,9 +577,9 @@\n     sets_unfold in H1.\n     sets_unfold in H2.\n     destruct H1; [| tauto].\n     destruct H2; [| tauto].\n-    right. (** 选择最右边的那一种*)\n+    right. (** 选择最右边的那一种 *)\n     exists i1, i2.\n     tauto.\n Qed.\n \n"
                },
                {
                    "date": 1699338953201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1584 @@\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.micromega.Psatz.\n+Require Import Coq.Strings.String.\n+Require Import Coq.Classes.Morphisms.\n+Require Import Coq.Classes.Morphisms_Prop.\n+Require Import Coq.Classes.RelationClasses.\n+Require Import Coq.Logic.Classical_Pred_Type.\n+Require Import Coq.Logic.Classical_Prop.\n+Require Import SetsClass.SetsClass. Import SetsNotation.\n+Require Import compcert.lib.Integers.\n+Require Import PL.SyntaxInCoq.\n+Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n+Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n+Import Lang_While DntSem_While1 DntSem_While2.\n+Import EDenote CDenote.\n+Local Open Scope string.\n+Local Open Scope Z.\n+Local Open Scope sets.\n+\n+(** * 定义与例子 *)\n+\n+Definition EVar': string -> expr := EVar.\n+Coercion EConst: Z >-> expr.\n+Coercion EVar: var_name >-> expr.\n+Coercion EVar': string >-> expr.\n+Notation \"[[ e ]]\" := e\n+  (at level 0, e custom expr_entry at level 99).\n+Notation \"( x )\" := x\n+  (in custom expr_entry, x custom expr_entry at level 99).\n+Notation \"x\" := x\n+  (in custom expr_entry at level 0, x constr at level 0).\n+Notation \"f x\" := (f x)\n+  (in custom expr_entry at level 1, only parsing,\n+   f custom expr_entry,\n+   x custom expr_entry at level 0).\n+Notation \"x + y\" := (EBinop OPlus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x - y\" := (EBinop OMinus x y)\n+  (in custom expr_entry at level 12, left associativity).\n+Notation \"x * y\" := (EBinop OMul x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x / y\" := (EBinop ODiv x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x % y\" := (EBinop OMod x y)\n+  (in custom expr_entry at level 11, left associativity).\n+Notation \"x <= y\" := (EBinop OLe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x < y\" := (EBinop OLt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x >= y\" := (EBinop OGe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x > y\" := (EBinop OGt x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x == y\" := (EBinop OEq x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x != y\" := (EBinop ONe x y)\n+  (in custom expr_entry at level 13, no associativity).\n+Notation \"x && y\" := (EBinop OAnd x y)\n+  (in custom expr_entry at level 14, left associativity).\n+Notation \"x || y\" := (EBinop OOr x y)\n+  (in custom expr_entry at level 15, left associativity).\n+Notation \"! x\" := (EUnop ONot x)\n+  (in custom expr_entry at level 10).\n+Notation \"- x\" := (EUnop ONeg x)\n+  (in custom expr_entry at level 10).\n+Notation \"c1 ; c2\" := (CSeq c1 c2)\n+  (in custom expr_entry at level 20, right associativity).\n+Notation \"'skip'\" := (CSkip)\n+  (in custom expr_entry at level 10).\n+Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99,\n+   c2 custom expr_entry at level 99,\n+   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n+Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n+  (in custom expr_entry at level 19,\n+   e custom expr_entry at level 5,\n+   c1 custom expr_entry at level 99).\n+\n+Notation \"⟦ e ⟧\" := (eval_expr e)\n+  (at level 0, only printing, e custom expr_entry at level 99).\n+Notation \"⟦ c ⟧\" := (eval_com c)\n+  (at level 0, only printing, c custom expr_entry at level 99).\n+\n+Ltac any_eval x :=\n+  match goal with\n+  | |- EDenote => exact (eval_expr x)\n+  | |- CDenote => exact (eval_com x)\n+  | _ => match type of x with\n+         | expr => exact (eval_expr x)\n+         | com => exact (eval_com x)\n+         end\n+  end.\n+\n+Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n+  (at level 0, only parsing, x custom expr_entry at level 99).\n+\n+Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n+  (no associativity, at level 61): sets_scope.\n+\n+(** 表达式语义等价 *)\n+\n+Record eequiv (e1 e2: expr): Prop := {\n+  nrm_eequiv:\n+    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n+  err_eequiv:\n+    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 表达式精化关系 *)\n+\n+Record erefine (e1 e2: expr): Prop := {\n+  nrm_erefine:\n+    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n+  err_erefine:\n+    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n+}.\n+\n+(** 程序语句语义等价 *)\n+\n+Record cequiv (c1 c2: com): Prop := {\n+  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n+  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n+  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n+}.\n+\n+(** 程序语句精化关系 *)\n+\n+Record crefine (c1 c2: com): Prop := {\n+  nrm_crefine:\n+    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n+  err_crefine:\n+    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n+  inf_crefine:\n+    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n+}.\n+\n+Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n+  (at level 69, only printing, no associativity).\n+Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n+  (at level 69, only printing, no associativity).\n+\n+Ltac any_equiv x y :=\n+  match type of x with\n+  | expr => exact (eequiv x y)\n+  | com => exact (cequiv x y)\n+  | _ => match type of y with\n+         | expr => exact (eequiv x y)\n+         | com => exact (cequiv x y)\n+         end\n+  end.\n+\n+Ltac any_refine x y :=\n+  match type of x with\n+  | expr => exact (erefine x y)\n+  | com => exact (crefine x y)\n+  | _ => match type of y with\n+         | expr => exact (erefine x y)\n+         | com => exact (crefine x y)\n+         end\n+  end.\n+\n+Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n+  (at level 69, only parsing, no associativity).\n+Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n+  (at level 69, only parsing, no associativity).\n+\n+Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n+  (at level 1).\n+Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n+  (at level 1).\n+Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n+  (at level 1).\n+\n+(** 精化的例子 *)\n+\n+Lemma const_plus_const_refine: forall n m: Z,\n+  EConst (n + m) <<= [[n + m]].\n+(** 证明见Coq代码。*)\n+Proof.\n+  intros.\n+  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n+          n < Int64.min_signed \\/\n+          n > Int64.max_signed) as Hn by lia.\n+  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n+          m < Int64.min_signed \\/\n+          m > Int64.max_signed) as Hm by lia.\n+  split.\n+  + sets_unfold; intros s i ?.\n+    simpl in H.\n+    destruct H.\n+    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n+    - unfold arith_sem1_nrm, arith_compute1_nrm.\n+      exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H1.\n+      pose proof Int64.signed_repr _ H2.\n+      rewrite H3, H4.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+  + sets_unfold; intros s ?.\n+    simpl in H.\n+    simpl; sets_unfold.\n+    unfold arith_sem1_err, arith_compute1_err.\n+    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n+    - exists (Int64.repr n), (Int64.repr m).\n+      pose proof Int64.signed_repr _ H0.\n+      pose proof Int64.signed_repr _ H1.\n+      rewrite H2, H3.\n+      tauto.\n+    - tauto.\n+    - tauto.\n+Qed.\n+\n+(** 语义等价的例子：顺序执行有结合律 *)\n+\n+Theorem CSeq_assoc: forall (c1 c2 c3: com),\n+  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+  + simpl.\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite Sets_union_assoc.\n+    rewrite Rels_concat_assoc.\n+    reflexivity.\n+Qed.\n+\n+\n+Theorem CIf_CSeq: forall e c1 c2 c3,\n+  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n+  [[ if e then { c1; c3 } else { c2; c3 } ]].\n+Proof.\n+  intros.\n+  split.\n+  + simpl.\n+    rewrite <- ! Rels_concat_assoc.\n+    apply Rels_concat_union_distr_r.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+  + simpl.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite <- ! Rels_concat_assoc.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+\n+\n+\n+(** * 语义等价与精化的性质 *)\n+\n+\n+(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n+\n+\n+    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n+    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n+    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n+    将稍后再解释_[Instance]_关键字的特殊作用。*)\n+\n+Instance eequiv_refl: Reflexive eequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance eequiv_sym: Symmetric eequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_trans: Transitive eequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n+    reflexivity.\n+  + rewrite H.(err_eequiv), H0.(err_eequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance eequiv_equiv: Equivalence eequiv.\n+Proof.\n+  split.\n+  + apply eequiv_refl.\n+  + apply eequiv_sym.\n+  + apply eequiv_trans.\n+Qed.\n+\n+(** 下面还可以证明精化关系也具有自反性和传递性。*)\n+\n+Instance erefine_refl: Reflexive erefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+Qed.\n+\n+Instance erefine_trans: Transitive erefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_erefine).\n+    rewrite H0.(nrm_erefine).\n+    rewrite H0.(err_erefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_erefine).\n+    rewrite H0.(err_erefine).\n+    reflexivity.\n+Qed.\n+\n+(** 并且精化关系在语义等价变换下不变。*)\n+\n+Instance erefine_well_defined:\n+  Proper (eequiv ==> eequiv ==> iff) erefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_eequiv).\n+      rewrite <- H0.(nrm_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite <- H.(err_eequiv).\n+      rewrite <- H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+  + split.\n+    - rewrite H.(nrm_eequiv).\n+      rewrite H0.(nrm_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(nrm_erefine).\n+    - rewrite H.(err_eequiv).\n+      rewrite H0.(err_eequiv).\n+      apply H1.(err_erefine).\n+Qed.\n+\n+(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n+    性。*)\n+\n+Instance cequiv_refl: Reflexive cequiv.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + reflexivity.\n+  + reflexivity.\n+  + reflexivity.\n+Qed.\n+\n+Instance cequiv_sym: Symmetric cequiv.\n+Proof.\n+  unfold Symmetric; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_trans: Transitive cequiv.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(err_cequiv), H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance cequiv_equiv: Equivalence cequiv.\n+Proof.\n+  split.\n+  + apply cequiv_refl.\n+  + apply cequiv_sym.\n+  + apply cequiv_trans.\n+Qed.\n+\n+Instance crefine_refl: Reflexive crefine.\n+Proof.\n+  unfold Reflexive; intros.\n+  split.\n+  + apply Sets_included_union1.\n+  + reflexivity.\n+  + apply Sets_included_union1.\n+Qed.\n+\n+Instance crefine_trans: Transitive crefine.\n+Proof.\n+  unfold Transitive; intros.\n+  split.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H0.(err_crefine).\n+    reflexivity.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H0.(err_crefine).\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance crefine_well_defined:\n+  Proper (cequiv ==> cequiv ==> iff) crefine.\n+Proof.\n+  unfold Proper, respectful; intros.\n+  split; intros.\n+  + split.\n+    - rewrite <- H.(nrm_cequiv).\n+      rewrite <- H0.(nrm_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite <- H.(err_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite <- H.(inf_cequiv).\n+      rewrite <- H0.(inf_cequiv).\n+      rewrite <- H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+  + split.\n+    - rewrite H.(nrm_cequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(nrm_crefine).\n+    - rewrite H.(err_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(err_crefine).\n+    - rewrite H.(inf_cequiv).\n+      rewrite H0.(inf_cequiv).\n+      rewrite H0.(err_cequiv).\n+      apply H1.(inf_crefine).\n+Qed.\n+\n+\n+\n+(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n+\n+Lemma add_congr: forall (e11 e12 e21 e22: expr),\n+    e11 ~=~ e12 ->\n+    e21 ~=~ e22 ->\n+    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n+Proof.\n+  intros.\n+  split.\n+  + simpl. admit.\n+  + simpl.\n+Abort.\n+\n+(** Normal 对应相同 *)\n+Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem1_nrm.\n+  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+\n+(** Error 对应相同 *)\n+Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s.\n+  unfold arith_sem1_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem1_nrm, arith_sem1_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left. (** 只剩下最后一种求值都成功的情况 *)\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+(**证明精化后出错变少*)\n+Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem1_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1;\n+    (* destruct H1; [| tauto]. *)\n+    destruct H2; [| tauto].\n+    right. (** 选择最右边的那一种 *)\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+(** 很多其它情况的证明是类似的。*)\n+\n+Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold arith_sem2_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold arith_sem2_err.\n+  apply or_iff_morphism.\n+  + apply or_iff_morphism.\n+    - apply H.(err_eequiv).\n+    - apply H0.(err_eequiv).\n+  + apply ex_iff_morphism; intros i1.\n+    apply ex_iff_morphism; intros i2.\n+    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+    reflexivity.\n+Qed.\n+\n+Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold arith_sem2_nrm, arith_sem2_err.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n+  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold arith_sem2_err.\n+  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+  + apply H.(nrm_erefine) in H1.\n+    apply H0.(nrm_erefine) in H2.\n+    sets_unfold in H1.\n+    sets_unfold in H2.\n+    destruct H1; [| tauto].\n+    destruct H2; [| tauto].\n+    right.\n+    exists i1, i2.\n+    tauto.\n+Qed.\n+\n+Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? ? s i.\n+  unfold cmp_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  apply or_iff_morphism.\n+  + apply H.(err_eequiv).\n+  + apply H0.(err_eequiv).\n+Qed.\n+\n+Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold cmp_sem_nrm.\n+  intros [i1 [i2 [? [? ?] ] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  apply H0.(nrm_erefine) in H2.\n+  sets_unfold in H1.\n+  sets_unfold in H2.\n+  destruct H1; [| tauto].\n+  destruct H2; [| tauto].\n+  left.\n+  exists i1, i2.\n+  tauto.\n+Qed.\n+\n+Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  intros [? | ?].\n+  + apply H.(err_erefine) in H1.\n+    tauto.\n+  + apply H0.(err_erefine) in H1.\n+    tauto.\n+Qed.\n+\n+Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold and_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold and_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold and_sem_nrm, and_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold and_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s i.\n+  unfold or_sem_nrm.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply or_iff_morphism; [reflexivity |].\n+  apply and_iff_morphism; [reflexivity |].\n+  apply ex_iff_morphism; intros i2.\n+  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n+  e11 ~=~ e12 ->\n+  e21 ~=~ e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  sets_unfold.\n+  intros ? ? ? ? ? ? s.\n+  unfold or_sem_err.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n+  reflexivity.\n+Qed.\n+\n+Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n+  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n+  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s i.\n+  unfold or_sem_nrm, or_sem_err.\n+  intros [i1 ?].\n+  destruct H1.\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  destruct H2; [left; exists i1; tauto |].\n+  destruct H2 as [? [i2 [? ?] ] ].\n+  apply H0.(nrm_erefine) in H3.\n+  sets_unfold in H3.\n+  destruct H3; [| right; right; exists i1; tauto].\n+  left; exists i1.\n+  split; [tauto |].\n+  right.\n+  split; [tauto |].\n+  exists i2; tauto.\n+Qed.\n+\n+Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n+  e11 <<= e12 ->\n+  e21 <<= e22 ->\n+  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n+  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros s.\n+  unfold or_sem_err.\n+  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n+  destruct H1 as [i1 [? [? ?] ] ].\n+  apply H.(nrm_erefine) in H1.\n+  sets_unfold in H1.\n+  destruct H1; [| tauto].\n+  right; exists i1.\n+  apply H0.(err_erefine) in H3.\n+  tauto.\n+Qed.\n+\n+(** 下面把二元运算的情况汇总起来。*)\n+(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n+\n+Instance EBinop_congr: forall op,\n+  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - apply or_sem_nrm_congr; tauto.\n+    - apply or_sem_err_congr; tauto.\n+  + split.\n+    - apply and_sem_nrm_congr; tauto.\n+    - apply and_sem_err_congr; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_congr; tauto.\n+    - apply cmp_sem_err_congr; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_congr; tauto.\n+    - apply arith_sem1_err_congr; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_congr; tauto.\n+    - apply arith_sem2_err_congr; tauto.\n+Qed.\n+\n+(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n+Instance EBinop_mono: forall op,\n+  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  (** 布尔二元运算的情况 *)\n+  + split.\n+    - simpl.\n+      apply (or_sem_nrm_mono x y x0 y0); tauto.\n+    - apply or_sem_err_mono; tauto.\n+  + split.\n+    - apply and_sem_nrm_mono; tauto.\n+    - apply and_sem_err_mono; tauto.\n+  (** 大小比较的情况 *)\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  + split.\n+    - apply cmp_sem_nrm_mono; tauto.\n+    - apply cmp_sem_err_mono; tauto.\n+  (** 加减乘运算的情况 *)\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  + split.\n+    - apply arith_sem1_nrm_mono; tauto.\n+    - apply arith_sem1_err_mono; tauto.\n+  (** 除法与取余的情况 *)\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+  + split.\n+    - apply arith_sem2_nrm_mono; tauto.\n+    - apply arith_sem2_err_mono; tauto.\n+Qed.\n+\n+(** 一元运算的情况是类似的。*)\n+\n+Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  not_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma not_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_eequiv).\n+Qed.\n+\n+Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n+Proof.\n+  unfold not_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma not_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n+Proof.\n+  intros.\n+  apply H.(err_erefine).\n+Qed.\n+\n+Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_nrm.\n+  sets_unfold.\n+  intros ? ? ? s i.\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_err_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  intros.\n+  unfold neg_sem_err; sets_unfold.\n+  intros s.\n+  apply or_iff_morphism; [apply H.(err_eequiv) |].\n+  apply ex_iff_morphism; intros i1.\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  reflexivity.\n+Qed.\n+\n+Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n+  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n+  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n+Proof.\n+  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n+  intros ? ? ? s i.\n+  intros [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; exists i1.\n+  tauto.\n+Qed.\n+\n+Lemma neg_sem_err_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n+  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n+Proof.\n+  unfold neg_sem_err; sets_unfold.\n+  intros ? ? ? s ?.\n+  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n+  destruct H0 as [i1 [? ?] ].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  right; exists i1.\n+  tauto.\n+Qed.\n+\n+Instance EUnop_congr: forall op,\n+  Proper (eequiv ==> eequiv) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - apply not_sem_nrm_congr; tauto.\n+    - simpl. apply not_sem_err_congr; tauto.\n+  + split.\n+    - apply neg_sem_nrm_congr; tauto.\n+    - apply neg_sem_err_congr; tauto.\n+Qed.\n+\n+Instance EUnop_mono: forall op,\n+  Proper (erefine ==> erefine) (EUnop op).\n+Proof.\n+  unfold Proper, respectful.\n+  intros.\n+  destruct op.\n+  + split.\n+    - simpl. apply not_sem_nrm_mono; tauto.\n+    - simpl. apply not_sem_err_mono; tauto.\n+  + split.\n+    - apply neg_sem_nrm_mono; tauto.\n+    - apply neg_sem_err_mono; tauto.\n+Qed.\n+\n+(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n+    性是比较显然的。*)\n+\n+Instance CSeq_congr:\n+  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H0.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(err_cequiv).\n+    rewrite H0.(err_cequiv).\n+    reflexivity.\n+  + rewrite H.(nrm_cequiv).\n+    rewrite H.(inf_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n+\n+Lemma Rels_times_full_concat2:\n+  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n+    (X × B) ∘ Y ⊆ X × C.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a c.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+Lemma Rels_times_full_concat1:\n+  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n+    (X × B) ∘ Y ⊆ X.\n+Proof.\n+  intros.\n+  sets_unfold.\n+  intros a.\n+  intros [b [? ?] ].\n+  tauto.\n+Qed.\n+\n+(** 下面证明顺序执行能保持精化关系。*)\n+\n+Instance CSeq_mono:\n+  Proper (crefine ==> crefine ==> crefine) CSeq.\n+Proof.\n+  unfold Proper, respectful.\n+  intros c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite H.(nrm_crefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite H.(err_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite Rels_concat_union_distr_r.\n+    rewrite Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite H.(inf_crefine).\n+    rewrite H0.(inf_crefine).\n+    rewrite H.(nrm_crefine).\n+    rewrite Rels_concat_union_distr_l.\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n+    _[test_false]_的性质。*)\n+\n+Lemma test_true_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_true ⟦ e1 ⟧ ⊆\n+  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  intros [ [i [? ?] ] ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  left; split; [| tauto].\n+  exists i; tauto.\n+Qed.\n+\n+Lemma test_false_mono: forall (e1 e2: expr),\n+  e1 <<= e2 ->\n+  test_false ⟦ e1 ⟧ ⊆\n+  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  intros [? ?].\n+  apply H.(nrm_erefine) in H0.\n+  sets_unfold in H0.\n+  destruct H0; [| tauto].\n+  tauto.\n+Qed.\n+\n+Lemma test_true_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_true; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply ex_iff_morphism; intros i.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+Lemma test_false_congr: forall (e1 e2: expr),\n+  e1 ~=~ e2 ->\n+  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n+Proof.\n+  intros.\n+  unfold test_false; sets_unfold; intros s1 s2.\n+  apply and_iff_morphism; [| reflexivity].\n+  apply H.(nrm_eequiv).\n+Qed.\n+\n+(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n+\n+Instance CIf_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H1.(nrm_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H.(err_eequiv).\n+    rewrite H0.(err_cequiv).\n+    rewrite H1.(err_cequiv).\n+    reflexivity.\n+  + rewrite (test_true_congr _ _ H).\n+    rewrite (test_false_congr _ _ H).\n+    rewrite H0.(inf_cequiv).\n+    rewrite H1.(inf_cequiv).\n+    reflexivity.\n+Qed.\n+\n+Instance CIf_mono:\n+  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n+  split; simpl.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(err_crefine), H1.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+  + rewrite (test_true_mono e1 e2 H).\n+    rewrite (test_false_mono e1 e2 H).\n+    rewrite H0.(inf_crefine), H1.(inf_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n+    的次数进行归纳。*)\n+\n+Instance CWhile_congr:\n+  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  (** 正常运行终止的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite (test_false_congr _ _ H).\n+      rewrite H0.(nrm_cequiv).\n+      reflexivity.\n+  (** 运行出错的情况。*)\n+  + apply Sets_indexed_union_congr; intros n.\n+    induction n; simpl.\n+    - reflexivity.\n+    - rewrite IHn.\n+      rewrite (test_true_congr _ _ H).\n+      rewrite H.(err_eequiv).\n+      rewrite H0.(nrm_cequiv).\n+      rewrite H0.(err_cequiv).\n+      reflexivity.\n+  (** 运行不终止的情况。*)\n+  + apply Sets_general_union_congr.\n+    intros X.\n+    unfold_CL_defs.\n+    rewrite H0.(nrm_cequiv).\n+    rewrite H0.(inf_cequiv).\n+    rewrite (test_true_congr _ _ H).\n+    reflexivity.\n+Qed.\n+\n+(** 要证明while语句保持精化关系就更复杂一些了。*)\n+\n+Definition boundedLB_nrm\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n+    ∅.\n+\n+Definition boundedLB_err\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (n: nat):\n+  state -> Prop :=\n+  Nat.iter\n+    n\n+    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n+    ∅.\n+\n+Definition is_inf\n+             (D0: EDenote)\n+             (D1: CDenote)\n+             (X: state -> Prop): Prop :=\n+  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n+      test_true D0 ∘ D1.(inf).\n+\n+Lemma boundedLB_nrm_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n+    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite (test_false_mono _ _ H).\n+    rewrite H0.(nrm_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat2.\n+    sets_unfold; intros s1 s2; tauto.\n+Qed.\n+\n+Lemma boundedLB_err_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) n,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n+    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n+Proof.\n+  intros.\n+  induction n; simpl.\n+  + apply Sets_empty_included.\n+  + rewrite IHn.\n+    rewrite (test_true_mono _ _ H).\n+    rewrite H.(err_erefine).\n+    rewrite H0.(nrm_crefine).\n+    rewrite H0.(err_crefine).\n+    rewrite ! Rels_concat_union_distr_r.\n+    rewrite ! Rels_concat_union_distr_l.\n+    rewrite ! Rels_times_full_concat1.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Sets_complement_indexed_union:\n+  forall {A I: Type} (Xs: I -> A -> Prop),\n+    Sets.complement (⋃ Xs) ==\n+    ⋂ (fun n => Sets.complement (Xs n)).\n+Proof.\n+  intros.\n+  sets_unfold.\n+  split.\n+  + apply not_ex_all_not.\n+  + apply all_not_not_ex.\n+Qed.\n+\n+Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n+  Sets.complement (⋃ (boundedLB_err D1 D2)).\n+\n+Lemma iter_err_fact:\n+  forall (D1: EDenote) (D2: CDenote),\n+    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n+    ⋃ (boundedLB_err D1 D2).\n+Proof.\n+  intros.\n+  rewrite ! Rels_concat_indexed_union_distr_l.\n+  apply Sets_indexed_union_included; intros n.\n+  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n+  simpl.\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Lemma Rels_concat_excluding_r:\n+  forall\n+    {A B: Type}\n+    (R: A -> B -> Prop)\n+    (S T: B -> Prop),\n+    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n+    R ∘ (S ∩ Sets.complement T).\n+Proof.\n+  intros.\n+  Sets_unfold; intros a.\n+  intros [ [b [? ?] ] ?].\n+  exists b.\n+  split; [tauto |].\n+  split; [tauto |].\n+  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n+  clear H1; intros.\n+  exists b; tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact1:\n+  forall (D1: EDenote) (D2: CDenote),\n+    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma noerrorLB_fact2:\n+  forall (D1: EDenote) (D2: CDenote),\n+    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n+Proof.\n+  intros.\n+  unfold noerrorLB.\n+  rewrite Sets_complement_indexed_union.\n+  apply Sets_equiv_Sets_included.\n+  split; [| apply Sets_empty_included].\n+  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n+  simpl.\n+  sets_unfold; intros s.\n+  tauto.\n+Qed.\n+\n+Lemma inf_mono_aux:\n+  forall (e1 e2: expr) (c1 c2: com) X,\n+    e1 <<= e2 ->\n+    c1 <<= c2 ->\n+    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n+    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+Proof.\n+  unfold is_inf.\n+  intros.\n+  rewrite H1 at 1.\n+  rewrite (test_true_mono _ _ H).\n+  rewrite H0.(nrm_crefine).\n+  rewrite H0.(inf_crefine).\n+  rewrite ! Rels_concat_union_distr_r.\n+  rewrite ! Rels_concat_union_distr_l.\n+  rewrite ! Rels_times_full_concat1.\n+  rewrite ! Sets_intersect_union_distr_r.\n+  rewrite noerrorLB_fact1.\n+  rewrite noerrorLB_fact2.\n+  rewrite ! Sets_union_empty.\n+  unfold noerrorLB at 1.\n+  rewrite <- iter_err_fact at 1.\n+  rewrite ! Rels_concat_excluding_r.\n+  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+  sets_unfold; intros s; tauto.\n+Qed.\n+\n+Instance CWhile_mono:\n+  Proper (erefine ==> crefine ==> crefine) CWhile.\n+Proof.\n+  unfold Proper, respectful.\n+  intros e1 e2 ? c1 c2 ?.\n+  split; simpl.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- ! (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_nrm_mono_aux; tauto.\n+  + apply Sets_indexed_union_included; intros n.\n+    unfold BW_LFix. unfold_CPO_defs.\n+    rewrite <- (Sets_included_indexed_union _ _ n).\n+    apply boundedLB_err_mono_aux; tauto.\n+  + apply Sets_general_union_included. unfold_CL_defs.\n+    intros X ?.\n+    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n+    unfold KT_GFix; unfold_CL_defs.\n+    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n+      by (exact H2).\n+    unfold noerrorLB.\n+    sets_unfold; intros s; tauto.\n+Qed.\n+\n+(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n+\n+Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n+  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n+  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n+Proof.\n+  intros.\n+  rewrite CSeq_assoc.\n+  rewrite CIf_CSeq.\n+  reflexivity.\n+Qed.\n+\n"
                },
                {
                    "date": 1699338961393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,1594 +575,10 @@\n   + apply H.(nrm_erefine) in H1.\n     apply H0.(nrm_erefine) in H2.\n     sets_unfold in H1.\n     sets_unfold in H2.\n-    destruct H1;\n-    (* destruct H1; [| tauto]. *)\n-    destruct H2; [| tauto].\n-    right. (** 选择最右边的那一种 *)\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-(** 很多其它情况的证明是类似的。*)\n-\n-Lemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem2_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold arith_sem2_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem2_nrm, arith_sem2_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem2_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n     destruct H1; [| tauto].\n     destruct H2; [| tauto].\n-    right.\n-    exists i1, i2.\n-    tauto.\n-Qed.\n-\n-Lemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold cmp_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  apply or_iff_morphism.\n-  + apply H.(err_eequiv).\n-  + apply H0.(err_eequiv).\n-Qed.\n-\n-Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold cmp_sem_nrm.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left.\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-Lemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  intros [? | ?].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-Qed.\n-\n-Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold and_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold and_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold and_sem_nrm, and_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold and_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-Lemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s i.\n-  unfold or_sem_nrm.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply or_iff_morphism; [reflexivity |].\n-  apply and_iff_morphism; [reflexivity |].\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? s.\n-  unfold or_sem_err.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n-  reflexivity.\n-Qed.\n-\n-Lemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold or_sem_nrm, or_sem_err.\n-  intros [i1 ?].\n-  destruct H1.\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  destruct H2; [left; exists i1; tauto |].\n-  destruct H2 as [? [i2 [? ?] ] ].\n-  apply H0.(nrm_erefine) in H3.\n-  sets_unfold in H3.\n-  destruct H3; [| right; right; exists i1; tauto].\n-  left; exists i1.\n-  split; [tauto |].\n-  right.\n-  split; [tauto |].\n-  exists i2; tauto.\n-Qed.\n-\n-Lemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n-  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold or_sem_err.\n-  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n-  destruct H1 as [i1 [? [? ?] ] ].\n-  apply H.(nrm_erefine) in H1.\n-  sets_unfold in H1.\n-  destruct H1; [| tauto].\n-  right; exists i1.\n-  apply H0.(err_erefine) in H3.\n-  tauto.\n-Qed.\n-\n-(** 下面把二元运算的情况汇总起来。*)\n-(** Proper: 表达式语法树的一个二元函数，如果这个二元函数的第一个参数做表达式语义等价变换，第二个也。。。,得到的符合eequiv性质*)\n-\n-Instance EBinop_congr: forall op,\n-  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - apply or_sem_nrm_congr; tauto.\n-    - apply or_sem_err_congr; tauto.\n-  + split.\n-    - apply and_sem_nrm_congr; tauto.\n-    - apply and_sem_err_congr; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_congr; tauto.\n-    - apply cmp_sem_err_congr; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_congr; tauto.\n-    - apply arith_sem1_err_congr; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_congr; tauto.\n-    - apply arith_sem2_err_congr; tauto.\n-Qed.\n-\n-(** e1 + e2 => e1' + e2, e1'是e1的精化，精化有自反性，从而替换前后整体还是精化关系*)\n-Instance EBinop_mono: forall op,\n-  Proper (erefine ==> erefine ==> erefine) (EBinop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  (** 布尔二元运算的情况 *)\n-  + split.\n-    - simpl.\n-      apply (or_sem_nrm_mono x y x0 y0); tauto.\n-    - apply or_sem_err_mono; tauto.\n-  + split.\n-    - apply and_sem_nrm_mono; tauto.\n-    - apply and_sem_err_mono; tauto.\n-  (** 大小比较的情况 *)\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  + split.\n-    - apply cmp_sem_nrm_mono; tauto.\n-    - apply cmp_sem_err_mono; tauto.\n-  (** 加减乘运算的情况 *)\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  + split.\n-    - apply arith_sem1_nrm_mono; tauto.\n-    - apply arith_sem1_err_mono; tauto.\n-  (** 除法与取余的情况 *)\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-  + split.\n-    - apply arith_sem2_nrm_mono; tauto.\n-    - apply arith_sem2_err_mono; tauto.\n-Qed.\n-\n-(** 一元运算的情况是类似的。*)\n-\n-Lemma not_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  not_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma not_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_eequiv).\n-Qed.\n-\n-Lemma not_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\n-Proof.\n-  unfold not_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma not_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\n-Proof.\n-  intros.\n-  apply H.(err_erefine).\n-Qed.\n-\n-Lemma neg_sem_nrm_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_nrm.\n-  sets_unfold.\n-  intros ? ? ? s i.\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_err_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  intros.\n-  unfold neg_sem_err; sets_unfold.\n-  intros s.\n-  apply or_iff_morphism; [apply H.(err_eequiv) |].\n-  apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-Lemma neg_sem_nrm_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n-  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n-  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\n-Proof.\n-  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n-  intros ? ? ? s i.\n-  intros [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; exists i1.\n-  tauto.\n-Qed.\n-\n-Lemma neg_sem_err_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n-  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\n-Proof.\n-  unfold neg_sem_err; sets_unfold.\n-  intros ? ? ? s ?.\n-  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n-  destruct H0 as [i1 [? ?] ].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  right; exists i1.\n-  tauto.\n-Qed.\n-\n-Instance EUnop_congr: forall op,\n-  Proper (eequiv ==> eequiv) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - apply not_sem_nrm_congr; tauto.\n-    - simpl. apply not_sem_err_congr; tauto.\n-  + split.\n-    - apply neg_sem_nrm_congr; tauto.\n-    - apply neg_sem_err_congr; tauto.\n-Qed.\n-\n-Instance EUnop_mono: forall op,\n-  Proper (erefine ==> erefine) (EUnop op).\n-Proof.\n-  unfold Proper, respectful.\n-  intros.\n-  destruct op.\n-  + split.\n-    - simpl. apply not_sem_nrm_mono; tauto.\n-    - simpl. apply not_sem_err_mono; tauto.\n-  + split.\n-    - apply neg_sem_nrm_mono; tauto.\n-    - apply neg_sem_err_mono; tauto.\n-Qed.\n-\n-(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n-    性是比较显然的。*)\n-\n-Instance CSeq_congr:\n-  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(err_cequiv).\n-    rewrite H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(nrm_cequiv).\n-    rewrite H.(inf_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n-\n-Lemma Rels_times_full_concat2:\n-  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n-    (X × B) ∘ Y ⊆ X × C.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a c.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-Lemma Rels_times_full_concat1:\n-  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n-    (X × B) ∘ Y ⊆ X.\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros a.\n-  intros [b [? ?] ].\n-  tauto.\n-Qed.\n-\n-(** 下面证明顺序执行能保持精化关系。*)\n-\n-Instance CSeq_mono:\n-  Proper (crefine ==> crefine ==> crefine) CSeq.\n-Proof.\n-  unfold Proper, respectful.\n-  intros c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite Rels_concat_union_distr_r.\n-    rewrite Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H.(nrm_crefine).\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n-    _[test_false]_的性质。*)\n-\n-Lemma test_true_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_true ⟦ e1 ⟧ ⊆\n-  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  intros [ [i [? ?] ] ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  left; split; [| tauto].\n-  exists i; tauto.\n-Qed.\n-\n-Lemma test_false_mono: forall (e1 e2: expr),\n-  e1 <<= e2 ->\n-  test_false ⟦ e1 ⟧ ⊆\n-  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  intros [? ?].\n-  apply H.(nrm_erefine) in H0.\n-  sets_unfold in H0.\n-  destruct H0; [| tauto].\n-  tauto.\n-Qed.\n-\n-Lemma test_true_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_true; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply ex_iff_morphism; intros i.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-Lemma test_false_congr: forall (e1 e2: expr),\n-  e1 ~=~ e2 ->\n-  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\n-Proof.\n-  intros.\n-  unfold test_false; sets_unfold; intros s1 s2.\n-  apply and_iff_morphism; [| reflexivity].\n-  apply H.(nrm_eequiv).\n-Qed.\n-\n-(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n-\n-Instance CIf_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H1.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H.(err_eequiv).\n-    rewrite H0.(err_cequiv).\n-    rewrite H1.(err_cequiv).\n-    reflexivity.\n-  + rewrite (test_true_congr _ _ H).\n-    rewrite (test_false_congr _ _ H).\n-    rewrite H0.(inf_cequiv).\n-    rewrite H1.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance CIf_mono:\n-  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n-  split; simpl.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(err_crefine), H1.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-  + rewrite (test_true_mono e1 e2 H).\n-    rewrite (test_false_mono e1 e2 H).\n-    rewrite H0.(inf_crefine), H1.(inf_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n-    的次数进行归纳。*)\n-\n-Instance CWhile_congr:\n-  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  (** 正常运行终止的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite (test_false_congr _ _ H).\n-      rewrite H0.(nrm_cequiv).\n-      reflexivity.\n-  (** 运行出错的情况。*)\n-  + apply Sets_indexed_union_congr; intros n.\n-    induction n; simpl.\n-    - reflexivity.\n-    - rewrite IHn.\n-      rewrite (test_true_congr _ _ H).\n-      rewrite H.(err_eequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      reflexivity.\n-  (** 运行不终止的情况。*)\n-  + apply Sets_general_union_congr.\n-    intros X.\n-    unfold_CL_defs.\n-    rewrite H0.(nrm_cequiv).\n-    rewrite H0.(inf_cequiv).\n-    rewrite (test_true_congr _ _ H).\n-    reflexivity.\n-Qed.\n-\n-(** 要证明while语句保持精化关系就更复杂一些了。*)\n-\n-Definition boundedLB_nrm\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n-    ∅.\n-\n-Definition boundedLB_err\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (n: nat):\n-  state -> Prop :=\n-  Nat.iter\n-    n\n-    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n-    ∅.\n-\n-Definition is_inf\n-             (D0: EDenote)\n-             (D1: CDenote)\n-             (X: state -> Prop): Prop :=\n-  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n-      test_true D0 ∘ D1.(inf).\n-\n-Lemma boundedLB_nrm_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n-    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite (test_false_mono _ _ H).\n-    rewrite H0.(nrm_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat2.\n-    sets_unfold; intros s1 s2; tauto.\n-Qed.\n-\n-Lemma boundedLB_err_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) n,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n-    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\n-Proof.\n-  intros.\n-  induction n; simpl.\n-  + apply Sets_empty_included.\n-  + rewrite IHn.\n-    rewrite (test_true_mono _ _ H).\n-    rewrite H.(err_erefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite ! Rels_times_full_concat1.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Sets_complement_indexed_union:\n-  forall {A I: Type} (Xs: I -> A -> Prop),\n-    Sets.complement (⋃ Xs) ==\n-    ⋂ (fun n => Sets.complement (Xs n)).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  split.\n-  + apply not_ex_all_not.\n-  + apply all_not_not_ex.\n-Qed.\n-\n-Definition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n-  Sets.complement (⋃ (boundedLB_err D1 D2)).\n-\n-Lemma iter_err_fact:\n-  forall (D1: EDenote) (D2: CDenote),\n-    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n-    ⋃ (boundedLB_err D1 D2).\n-Proof.\n-  intros.\n-  rewrite ! Rels_concat_indexed_union_distr_l.\n-  apply Sets_indexed_union_included; intros n.\n-  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n-  simpl.\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Lemma Rels_concat_excluding_r:\n-  forall\n-    {A B: Type}\n-    (R: A -> B -> Prop)\n-    (S T: B -> Prop),\n-    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n-    R ∘ (S ∩ Sets.complement T).\n-Proof.\n-  intros.\n-  Sets_unfold; intros a.\n-  intros [ [b [? ?] ] ?].\n-  exists b.\n-  split; [tauto |].\n-  split; [tauto |].\n-  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n-  clear H1; intros.\n-  exists b; tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact1:\n-  forall (D1: EDenote) (D2: CDenote),\n-    D1.(err) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma noerrorLB_fact2:\n-  forall (D1: EDenote) (D2: CDenote),\n-    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\n-Proof.\n-  intros.\n-  unfold noerrorLB.\n-  rewrite Sets_complement_indexed_union.\n-  apply Sets_equiv_Sets_included.\n-  split; [| apply Sets_empty_included].\n-  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n-  simpl.\n-  sets_unfold; intros s.\n-  tauto.\n-Qed.\n-\n-Lemma inf_mono_aux:\n-  forall (e1 e2: expr) (c1 c2: com) X,\n-    e1 <<= e2 ->\n-    c1 <<= c2 ->\n-    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n-    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-Proof.\n-  unfold is_inf.\n-  intros.\n-  rewrite H1 at 1.\n-  rewrite (test_true_mono _ _ H).\n-  rewrite H0.(nrm_crefine).\n-  rewrite H0.(inf_crefine).\n-  rewrite ! Rels_concat_union_distr_r.\n-  rewrite ! Rels_concat_union_distr_l.\n-  rewrite ! Rels_times_full_concat1.\n-  rewrite ! Sets_intersect_union_distr_r.\n-  rewrite noerrorLB_fact1.\n-  rewrite noerrorLB_fact2.\n-  rewrite ! Sets_union_empty.\n-  unfold noerrorLB at 1.\n-  rewrite <- iter_err_fact at 1.\n-  rewrite ! Rels_concat_excluding_r.\n-  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n-  sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance CWhile_mono:\n-  Proper (erefine ==> crefine ==> crefine) CWhile.\n-Proof.\n-  unfold Proper, respectful.\n-  intros e1 e2 ? c1 c2 ?.\n-  split; simpl.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_nrm_mono_aux; tauto.\n-  + apply Sets_indexed_union_included; intros n.\n-    unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- (Sets_included_indexed_union _ _ n).\n-    apply boundedLB_err_mono_aux; tauto.\n-  + apply Sets_general_union_included. unfold_CL_defs.\n-    intros X ?.\n-    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n-    unfold KT_GFix; unfold_CL_defs.\n-    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n-      by (exact H2).\n-    unfold noerrorLB.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n-\n-Example cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n-  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n-  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\n-Proof.\n-  intros.\n-  rewrite CSeq_assoc.\n-  rewrite CIf_CSeq.\n-  reflexivity.\n-Qed.\n-\n-Require Import Coq.ZArith.ZArith.\n-Require Import Coq.micromega.Psatz.\n-Require Import Coq.Strings.String.\n-Require Import Coq.Classes.Morphisms.\n-Require Import Coq.Classes.Morphisms_Prop.\n-Require Import Coq.Classes.RelationClasses.\n-Require Import Coq.Logic.Classical_Pred_Type.\n-Require Import Coq.Logic.Classical_Prop.\n-Require Import SetsClass.SetsClass. Import SetsNotation.\n-Require Import compcert.lib.Integers.\n-Require Import PL.SyntaxInCoq.\n-Require Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\n-Require Import PL.PracticalDenotations. Import KTFix Sets_CL.\n-Import Lang_While DntSem_While1 DntSem_While2.\n-Import EDenote CDenote.\n-Local Open Scope string.\n-Local Open Scope Z.\n-Local Open Scope sets.\n-\n-(** * 定义与例子 *)\n-\n-Definition EVar': string -> expr := EVar.\n-Coercion EConst: Z >-> expr.\n-Coercion EVar: var_name >-> expr.\n-Coercion EVar': string >-> expr.\n-Notation \"[[ e ]]\" := e\n-  (at level 0, e custom expr_entry at level 99).\n-Notation \"( x )\" := x\n-  (in custom expr_entry, x custom expr_entry at level 99).\n-Notation \"x\" := x\n-  (in custom expr_entry at level 0, x constr at level 0).\n-Notation \"f x\" := (f x)\n-  (in custom expr_entry at level 1, only parsing,\n-   f custom expr_entry,\n-   x custom expr_entry at level 0).\n-Notation \"x + y\" := (EBinop OPlus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x - y\" := (EBinop OMinus x y)\n-  (in custom expr_entry at level 12, left associativity).\n-Notation \"x * y\" := (EBinop OMul x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x / y\" := (EBinop ODiv x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x % y\" := (EBinop OMod x y)\n-  (in custom expr_entry at level 11, left associativity).\n-Notation \"x <= y\" := (EBinop OLe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x < y\" := (EBinop OLt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x >= y\" := (EBinop OGe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x > y\" := (EBinop OGt x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x == y\" := (EBinop OEq x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x != y\" := (EBinop ONe x y)\n-  (in custom expr_entry at level 13, no associativity).\n-Notation \"x && y\" := (EBinop OAnd x y)\n-  (in custom expr_entry at level 14, left associativity).\n-Notation \"x || y\" := (EBinop OOr x y)\n-  (in custom expr_entry at level 15, left associativity).\n-Notation \"! x\" := (EUnop ONot x)\n-  (in custom expr_entry at level 10).\n-Notation \"- x\" := (EUnop ONeg x)\n-  (in custom expr_entry at level 10).\n-Notation \"c1 ; c2\" := (CSeq c1 c2)\n-  (in custom expr_entry at level 20, right associativity).\n-Notation \"'skip'\" := (CSkip)\n-  (in custom expr_entry at level 10).\n-Notation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99,\n-   c2 custom expr_entry at level 99,\n-   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\n-Notation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n-  (in custom expr_entry at level 19,\n-   e custom expr_entry at level 5,\n-   c1 custom expr_entry at level 99).\n-\n-Notation \"⟦ e ⟧\" := (eval_expr e)\n-  (at level 0, only printing, e custom expr_entry at level 99).\n-Notation \"⟦ c ⟧\" := (eval_com c)\n-  (at level 0, only printing, c custom expr_entry at level 99).\n-\n-Ltac any_eval x :=\n-  match goal with\n-  | |- EDenote => exact (eval_expr x)\n-  | |- CDenote => exact (eval_com x)\n-  | _ => match type of x with\n-         | expr => exact (eval_expr x)\n-         | com => exact (eval_com x)\n-         end\n-  end.\n-\n-Notation \"⟦ x ⟧\" := (ltac:(any_eval x))\n-  (at level 0, only parsing, x custom expr_entry at level 99).\n-\n-Notation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n-  (no associativity, at level 61): sets_scope.\n-\n-(** 表达式语义等价 *)\n-\n-Record eequiv (e1 e2: expr): Prop := {\n-  nrm_eequiv:\n-    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n-  err_eequiv:\n-    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 表达式精化关系 *)\n-\n-Record erefine (e1 e2: expr): Prop := {\n-  nrm_erefine:\n-    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n-  err_erefine:\n-    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n-}.\n-\n-(** 程序语句语义等价 *)\n-\n-Record cequiv (c1 c2: com): Prop := {\n-  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n-  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n-  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n-}.\n-\n-(** 程序语句精化关系 *)\n-\n-Record crefine (c1 c2: com): Prop := {\n-  nrm_crefine:\n-    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n-  err_crefine:\n-    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n-  inf_crefine:\n-    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n-}.\n-\n-Notation \"e1 '~=~' e2\" := (eequiv e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"e1 '<<=' e2\" := (erefine e1 e2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '~=~' c2\" := (cequiv c1 c2)\n-  (at level 69, only printing, no associativity).\n-Notation \"c1 '<<=' c2\" := (crefine c1 c2)\n-  (at level 69, only printing, no associativity).\n-\n-Ltac any_equiv x y :=\n-  match type of x with\n-  | expr => exact (eequiv x y)\n-  | com => exact (cequiv x y)\n-  | _ => match type of y with\n-         | expr => exact (eequiv x y)\n-         | com => exact (cequiv x y)\n-         end\n-  end.\n-\n-Ltac any_refine x y :=\n-  match type of x with\n-  | expr => exact (erefine x y)\n-  | com => exact (crefine x y)\n-  | _ => match type of y with\n-         | expr => exact (erefine x y)\n-         | com => exact (crefine x y)\n-         end\n-  end.\n-\n-Notation \"x '~=~' y\" := (ltac:(any_equiv x y))\n-  (at level 69, only parsing, no associativity).\n-Notation \"x '<<=' y\" := (ltac:(any_refine x y))\n-  (at level 69, only parsing, no associativity).\n-\n-Notation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n-  (at level 1).\n-Notation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n-  (at level 1).\n-Notation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n-  (at level 1).\n-\n-(** 精化的例子 *)\n-\n-Lemma const_plus_const_refine: forall n m: Z,\n-  EConst (n + m) <<= [[n + m]].\n-(** 证明见Coq代码。*)\n-Proof.\n-  intros.\n-  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n-          n < Int64.min_signed \\/\n-          n > Int64.max_signed) as Hn by lia.\n-  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n-          m < Int64.min_signed \\/\n-          m > Int64.max_signed) as Hm by lia.\n-  split.\n-  + sets_unfold; intros s i ?.\n-    simpl in H.\n-    destruct H.\n-    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n-    - unfold arith_sem1_nrm, arith_compute1_nrm.\n-      exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H1.\n-      pose proof Int64.signed_repr _ H2.\n-      rewrite H3, H4.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-  + sets_unfold; intros s ?.\n-    simpl in H.\n-    simpl; sets_unfold.\n-    unfold arith_sem1_err, arith_compute1_err.\n-    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n-    - exists (Int64.repr n), (Int64.repr m).\n-      pose proof Int64.signed_repr _ H0.\n-      pose proof Int64.signed_repr _ H1.\n-      rewrite H2, H3.\n-      tauto.\n-    - tauto.\n-    - tauto.\n-Qed.\n-\n-(** 语义等价的例子：顺序执行有结合律 *)\n-\n-Theorem CSeq_assoc: forall (c1 c2 c3: com),\n-  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-  + simpl.\n-    rewrite Rels_concat_union_distr_l.\n-    rewrite Sets_union_assoc.\n-    rewrite Rels_concat_assoc.\n-    reflexivity.\n-Qed.\n-\n-\n-Theorem CIf_CSeq: forall e c1 c2 c3,\n-  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n-  [[ if e then { c1; c3 } else { c2; c3 } ]].\n-Proof.\n-  intros.\n-  split.\n-  + simpl.\n-    rewrite <- ! Rels_concat_assoc.\n-    apply Rels_concat_union_distr_r.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-  + simpl.\n-    rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_concat_union_distr_l.\n-    rewrite <- ! Rels_concat_assoc.\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-\n-\n-\n-(** * 语义等价与精化的性质 *)\n-\n-\n-(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n-\n-\n-    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n-    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n-    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n-    将稍后再解释_[Instance]_关键字的特殊作用。*)\n-\n-Instance eequiv_refl: Reflexive eequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance eequiv_sym: Symmetric eequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_trans: Transitive eequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n-    reflexivity.\n-  + rewrite H.(err_eequiv), H0.(err_eequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance eequiv_equiv: Equivalence eequiv.\n-Proof.\n-  split.\n-  + apply eequiv_refl.\n-  + apply eequiv_sym.\n-  + apply eequiv_trans.\n-Qed.\n-\n-(** 下面还可以证明精化关系也具有自反性和传递性。*)\n-\n-Instance erefine_refl: Reflexive erefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-Qed.\n-\n-Instance erefine_trans: Transitive erefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_erefine).\n-    rewrite H0.(nrm_erefine).\n-    rewrite H0.(err_erefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_erefine).\n-    rewrite H0.(err_erefine).\n-    reflexivity.\n-Qed.\n-\n-(** 并且精化关系在语义等价变换下不变。*)\n-\n-Instance erefine_well_defined:\n-  Proper (eequiv ==> eequiv ==> iff) erefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_eequiv).\n-      rewrite <- H0.(nrm_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite <- H.(err_eequiv).\n-      rewrite <- H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-  + split.\n-    - rewrite H.(nrm_eequiv).\n-      rewrite H0.(nrm_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(nrm_erefine).\n-    - rewrite H.(err_eequiv).\n-      rewrite H0.(err_eequiv).\n-      apply H1.(err_erefine).\n-Qed.\n-\n-(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n-    性。*)\n-\n-Instance cequiv_refl: Reflexive cequiv.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + reflexivity.\n-  + reflexivity.\n-  + reflexivity.\n-Qed.\n-\n-Instance cequiv_sym: Symmetric cequiv.\n-Proof.\n-  unfold Symmetric; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_trans: Transitive cequiv.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n-    reflexivity.\n-  + rewrite H.(err_cequiv), H0.(err_cequiv).\n-    reflexivity.\n-  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n-    reflexivity.\n-Qed.\n-\n-Instance cequiv_equiv: Equivalence cequiv.\n-Proof.\n-  split.\n-  + apply cequiv_refl.\n-  + apply cequiv_sym.\n-  + apply cequiv_trans.\n-Qed.\n-\n-Instance crefine_refl: Reflexive crefine.\n-Proof.\n-  unfold Reflexive; intros.\n-  split.\n-  + apply Sets_included_union1.\n-  + reflexivity.\n-  + apply Sets_included_union1.\n-Qed.\n-\n-Instance crefine_trans: Transitive crefine.\n-Proof.\n-  unfold Transitive; intros.\n-  split.\n-  + rewrite H.(nrm_crefine).\n-    rewrite H0.(nrm_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n-    rewrite H0.(err_crefine).\n-    reflexivity.\n-  + rewrite H.(inf_crefine).\n-    rewrite H0.(inf_crefine).\n-    rewrite H0.(err_crefine).\n-    sets_unfold; intros s; tauto.\n-Qed.\n-\n-Instance crefine_well_defined:\n-  Proper (cequiv ==> cequiv ==> iff) crefine.\n-Proof.\n-  unfold Proper, respectful; intros.\n-  split; intros.\n-  + split.\n-    - rewrite <- H.(nrm_cequiv).\n-      rewrite <- H0.(nrm_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite <- H.(err_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite <- H.(inf_cequiv).\n-      rewrite <- H0.(inf_cequiv).\n-      rewrite <- H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-  + split.\n-    - rewrite H.(nrm_cequiv).\n-      rewrite H0.(nrm_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(nrm_crefine).\n-    - rewrite H.(err_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(err_crefine).\n-    - rewrite H.(inf_cequiv).\n-      rewrite H0.(inf_cequiv).\n-      rewrite H0.(err_cequiv).\n-      apply H1.(inf_crefine).\n-Qed.\n-\n-\n-\n-(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n-\n-Lemma add_congr: forall (e11 e12 e21 e22: expr),\n-    e11 ~=~ e12 ->\n-    e21 ~=~ e22 ->\n-    (EBinop OPlus e11 e21) ~=~ (EBinop OPlus e12 e22).\n-Proof.\n-  intros.\n-  split.\n-  + simpl. admit.\n-  + simpl.\n-Abort.\n-\n-(** Normal 对应相同 *)\n-Lemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s i.\n-  unfold arith_sem1_nrm.\n-  apply ex_iff_morphism; intros i1. (*脱掉i1*)\n-  apply ex_iff_morphism; intros i2.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** [apply H |] *)\n-  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-  reflexivity.\n-Qed.\n-\n-\n-(** Error 对应相同 *)\n-Lemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 ~=~ e12 ->\n-  e21 ~=~ e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  sets_unfold.\n-  intros ? ? ? ? ? ? ? s.\n-  unfold arith_sem1_err.\n-  apply or_iff_morphism.\n-  + apply or_iff_morphism.\n-    - apply H.(err_eequiv).\n-    - apply H0.(err_eequiv).\n-  + apply ex_iff_morphism; intros i1.\n-    apply ex_iff_morphism; intros i2.\n-    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n-    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n-    reflexivity.\n-Qed.\n-\n-Lemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n-  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s i.\n-  unfold arith_sem1_nrm, arith_sem1_err.\n-  intros [i1 [i2 [? [? ?] ] ] ].\n-  apply H.(nrm_erefine) in H1. (**根据精化关系*)\n-  apply H0.(nrm_erefine) in H2.\n-  sets_unfold in H1.\n-  sets_unfold in H2.\n-  destruct H1; [| tauto].\n-  destruct H2; [| tauto].\n-  left. (** 只剩下最后一种求值都成功的情况 *)\n-  exists i1, i2.\n-  tauto.\n-Qed.\n-\n-(**证明精化后出错变少*)\n-Lemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n-  e11 <<= e12 ->\n-  e21 <<= e22 ->\n-  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n-  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n-  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\n-Proof.\n-  intros.\n-  sets_unfold.\n-  intros s.\n-  unfold arith_sem1_err.\n-  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n-  + apply H.(err_erefine) in H1.\n-    tauto.\n-  + apply H0.(err_erefine) in H1.\n-    tauto.\n-  + apply H.(nrm_erefine) in H1.\n-    apply H0.(nrm_erefine) in H2.\n-    sets_unfold in H1.\n-    sets_unfold in H2.\n-    destruct H1; [| tauto].\n-    destruct H2; [| tauto].\n     right. (** 选择最右边的那一种 *)\n     exists i1, i2.\n     tauto.\n Qed.\n"
                },
                {
                    "date": 1699338992139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -577,9 +577,9 @@\n     sets_unfold in H1.\n     sets_unfold in H2.\n     destruct H1; [| tauto].\n     destruct H2; [| tauto].\n-    right. (** 选择最右边的那一种 *)\n+    middle. (** 选择最右边的那一种 *)\n     exists i1, i2.\n     tauto.\n Qed.\n \n"
                },
                {
                    "date": 1699338998719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -577,9 +577,9 @@\n     sets_unfold in H1.\n     sets_unfold in H2.\n     destruct H1; [| tauto].\n     destruct H2; [| tauto].\n-    middle. (** 选择最右边的那一种 *)\n+    right. (** 选择最右边的那一种 *)\n     exists i1, i2.\n     tauto.\n Qed.\n \n"
                },
                {
                    "date": 1699339109453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -703,8 +703,9 @@\n   + apply H.(err_eequiv).\n   + apply H0.(err_eequiv).\n Qed.\n \n+(** comparison 本身不会出错 *)\n Lemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n   e11 <<= e12 ->\n   e21 <<= e22 ->\n   cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n"
                },
                {
                    "date": 1699339295567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -743,8 +743,9 @@\n   + apply H0.(err_erefine) in H1.\n     tauto.\n Qed.\n \n+(** 短路求值  *)\n Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n   and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n"
                },
                {
                    "date": 1699339333722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -743,9 +743,9 @@\n   + apply H0.(err_erefine) in H1.\n     tauto.\n Qed.\n \n-(** 短路求值  *)\n+(** 短路求值，求值成功的情况  *)\n Lemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n   e11 ~=~ e12 ->\n   e21 ~=~ e22 ->\n   and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n"
                },
                {
                    "date": 1699339506213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -754,9 +754,9 @@\n   sets_unfold.\n   intros ? ? ? ? ? ? s i.\n   unfold and_sem_nrm.\n   apply ex_iff_morphism; intros i1.\n-  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n+  apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** 左半边*)\n   apply or_iff_morphism; [reflexivity |].\n   apply and_iff_morphism; [reflexivity |].\n   apply ex_iff_morphism; intros i2.\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n"
                },
                {
                    "date": 1699339547453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -755,8 +755,9 @@\n   intros ? ? ? ? ? ? s i.\n   unfold and_sem_nrm.\n   apply ex_iff_morphism; intros i1.\n   apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** 左半边*)\n+  Print and_iff_morphism.\n   apply or_iff_morphism; [reflexivity |].\n   apply and_iff_morphism; [reflexivity |].\n   apply ex_iff_morphism; intros i2.\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n"
                },
                {
                    "date": 1699340158105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -755,9 +755,8 @@\n   intros ? ? ? ? ? ? s i.\n   unfold and_sem_nrm.\n   apply ex_iff_morphism; intros i1.\n   apply and_iff_morphism; [apply H.(nrm_eequiv) |]. (** 左半边*)\n-  Print and_iff_morphism.\n   apply or_iff_morphism; [reflexivity |].\n   apply and_iff_morphism; [reflexivity |].\n   apply ex_iff_morphism; intros i2.\n   apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n"
                },
                {
                    "date": 1699340610192,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1121,9 +1121,9 @@\n   right; exists i1.\n   tauto.\n Qed.\n \n-Instance EUnop_congr: forall op,\n+Instance EUnop_congr: forall op, (** 一元运算符保持等价关系*)\n   Proper (eequiv ==> eequiv) (EUnop op).\n Proof.\n   unfold Proper, respectful.\n   intros.\n@@ -1135,9 +1135,9 @@\n     - apply neg_sem_nrm_congr; tauto.\n     - apply neg_sem_err_congr; tauto.\n Qed.\n \n-Instance EUnop_mono: forall op,\n+Instance EUnop_mono: forall op, (** 一元运算符保持精化关系*)\n   Proper (erefine ==> erefine) (EUnop op).\n Proof.\n   unfold Proper, respectful.\n   intros.\n"
                },
                {
                    "date": 1699341320664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1207,9 +1207,9 @@\n   + rewrite H.(nrm_crefine).\n     rewrite H0.(nrm_crefine).\n     rewrite Rels_concat_union_distr_l.\n     rewrite ! Rels_concat_union_distr_r.\n-    rewrite ! Rels_times_full_concat2.\n+    rewrite ! Rels_times_full_concat2. (**  ⟦ c12 ⟧.(err) × state ∘ ⟦ c22 ⟧.(err) × state) 属于  ⟦ c12 ⟧.(err) × state*)\n     sets_unfold; intros s1 s2; tauto.\n   + rewrite H.(err_crefine).\n     rewrite H.(nrm_crefine).\n     rewrite H0.(err_crefine).\n"
                },
                {
                    "date": 1699341475042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1209,15 +1209,15 @@\n     rewrite Rels_concat_union_distr_l.\n     rewrite ! Rels_concat_union_distr_r.\n     rewrite ! Rels_times_full_concat2. (**  ⟦ c12 ⟧.(err) × state ∘ ⟦ c22 ⟧.(err) × state) 属于  ⟦ c12 ⟧.(err) × state*)\n     sets_unfold; intros s1 s2; tauto.\n-  + rewrite H.(err_crefine).\n+  + rewrite H.(err_crefine). (**出错的情况*)\n     rewrite H.(nrm_crefine).\n     rewrite H0.(err_crefine).\n     rewrite Rels_concat_union_distr_r.\n     rewrite Rels_times_full_concat1.\n     sets_unfold; intros s; tauto.\n-  + rewrite H.(inf_crefine).\n+  + rewrite H.(inf_crefine). (**无穷的情况*)\n     rewrite H0.(inf_crefine).\n     rewrite H.(nrm_crefine).\n     rewrite Rels_concat_union_distr_l.\n     rewrite ! Rels_concat_union_distr_r.\n"
                },
                {
                    "date": 1699342226821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1552,9 +1552,9 @@\n Proof.\n   unfold Proper, respectful.\n   intros e1 e2 ? c1 c2 ?.\n   split; simpl.\n-  + apply Sets_indexed_union_included; intros n.\n+  + apply Sets_indexed_union_included; intros n. (**左边无穷并的每一项都是有右边的子集*)\n     unfold BW_LFix. unfold_CPO_defs.\n     rewrite <- ! (Sets_included_indexed_union _ _ n).\n     apply boundedLB_nrm_mono_aux; tauto.\n   + apply Sets_indexed_union_included; intros n.\n"
                },
                {
                    "date": 1699342335962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1554,9 +1554,9 @@\n   intros e1 e2 ? c1 c2 ?.\n   split; simpl.\n   + apply Sets_indexed_union_included; intros n. (**左边无穷并的每一项都是有右边的子集*)\n     unfold BW_LFix. unfold_CPO_defs.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n).\n+    rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n     apply boundedLB_nrm_mono_aux; tauto.\n   + apply Sets_indexed_union_included; intros n.\n     unfold BW_LFix. unfold_CPO_defs.\n     rewrite <- (Sets_included_indexed_union _ _ n).\n"
                },
                {
                    "date": 1699342624329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1554,8 +1554,9 @@\n   intros e1 e2 ? c1 c2 ?.\n   split; simpl.\n   + apply Sets_indexed_union_included; intros n. (**左边无穷并的每一项都是有右边的子集*)\n     unfold BW_LFix. unfold_CPO_defs.\n+    admit.\n     rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n     apply boundedLB_nrm_mono_aux; tauto.\n   + apply Sets_indexed_union_included; intros n.\n     unfold BW_LFix. unfold_CPO_defs.\n"
                },
                {
                    "date": 1699342629648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1555,10 +1555,10 @@\n   split; simpl.\n   + apply Sets_indexed_union_included; intros n. (**左边无穷并的每一项都是有右边的子集*)\n     unfold BW_LFix. unfold_CPO_defs.\n     admit.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n-    apply boundedLB_nrm_mono_aux; tauto.\n+    (* rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n+    apply boundedLB_nrm_mono_aux; tauto. *)\n   + apply Sets_indexed_union_included; intros n.\n     unfold BW_LFix. unfold_CPO_defs.\n     rewrite <- (Sets_included_indexed_union _ _ n).\n     apply boundedLB_err_mono_aux; tauto.\n"
                },
                {
                    "date": 1699342640368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1555,10 +1555,10 @@\n   split; simpl.\n   + apply Sets_indexed_union_included; intros n. (**左边无穷并的每一项都是有右边的子集*)\n     unfold BW_LFix. unfold_CPO_defs.\n     admit.\n-    (* rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n-    apply boundedLB_nrm_mono_aux; tauto. *)\n+    rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n+    apply boundedLB_nrm_mono_aux; tauto.\n   + apply Sets_indexed_union_included; intros n.\n     unfold BW_LFix. unfold_CPO_defs.\n     rewrite <- (Sets_included_indexed_union _ _ n).\n     apply boundedLB_err_mono_aux; tauto.\n"
                },
                {
                    "date": 1699342646167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1552,12 +1552,11 @@\n Proof.\n   unfold Proper, respectful.\n   intros e1 e2 ? c1 c2 ?.\n   split; simpl.\n-  + apply Sets_indexed_union_included; intros n. (**左边无穷并的每一项都是有右边的子集*)\n+  + apply Sets_indexed_union_included; intros n. (**无穷并的每一项都是有*)\n     unfold BW_LFix. unfold_CPO_defs.\n-    admit.\n-    rewrite <- ! (Sets_included_indexed_union _ _ n). (**第n项*)\n+    rewrite <- ! (Sets_included_indexed_union _ _ n).\n     apply boundedLB_nrm_mono_aux; tauto.\n   + apply Sets_indexed_union_included; intros n.\n     unfold BW_LFix. unfold_CPO_defs.\n     rewrite <- (Sets_included_indexed_union _ _ n).\n"
                },
                {
                    "date": 1699596937987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1524,9 +1524,9 @@\n   forall (e1 e2: expr) (c1 c2: com) X,\n     e1 <<= e2 ->\n     c1 <<= c2 ->\n     is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n-    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n+    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧). (**x集合中会执行while e2 do c2出错的情况排除*)\n Proof.\n   unfold is_inf.\n   intros.\n   rewrite H1 at 1.\n"
                },
                {
                    "date": 1699597277792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1535,9 +1535,9 @@\n   rewrite H0.(inf_crefine).\n   rewrite ! Rels_concat_union_distr_r.\n   rewrite ! Rels_concat_union_distr_l.\n   rewrite ! Rels_times_full_concat1.\n-  rewrite ! Sets_intersect_union_distr_r.\n+  rewrite ! Sets_intersect_union_distr_r. (**交集对于bingji的分配律*)\n   rewrite noerrorLB_fact1.\n   rewrite noerrorLB_fact2.\n   rewrite ! Sets_union_empty.\n   unfold noerrorLB at 1.\n"
                }
            ],
            "date": 1699336983325,
            "name": "Commit-0",
            "content": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Psatz.\nRequire Import Coq.Strings.String.\nRequire Import Coq.Classes.Morphisms.\nRequire Import Coq.Classes.Morphisms_Prop.\nRequire Import Coq.Classes.RelationClasses.\nRequire Import Coq.Logic.Classical_Pred_Type.\nRequire Import Coq.Logic.Classical_Prop.\nRequire Import SetsClass.SetsClass. Import SetsNotation.\nRequire Import compcert.lib.Integers.\nRequire Import PL.SyntaxInCoq.\nRequire Import PL.DenotationalSemantics. Import BWFix Sets_CPO.\nRequire Import PL.PracticalDenotations. Import KTFix Sets_CL.\nImport Lang_While DntSem_While1 DntSem_While2.\nImport EDenote CDenote.\nLocal Open Scope string.\nLocal Open Scope Z.\nLocal Open Scope sets.\n\n(** * 定义与例子 *)\n\nDefinition EVar': string -> expr := EVar.\nCoercion EConst: Z >-> expr.\nCoercion EVar: var_name >-> expr.\nCoercion EVar': string >-> expr.\nNotation \"[[ e ]]\" := e\n  (at level 0, e custom expr_entry at level 99).\nNotation \"( x )\" := x\n  (in custom expr_entry, x custom expr_entry at level 99).\nNotation \"x\" := x\n  (in custom expr_entry at level 0, x constr at level 0).\nNotation \"f x\" := (f x)\n  (in custom expr_entry at level 1, only parsing,\n   f custom expr_entry,\n   x custom expr_entry at level 0).\nNotation \"x + y\" := (EBinop OPlus x y)\n  (in custom expr_entry at level 12, left associativity).\nNotation \"x - y\" := (EBinop OMinus x y)\n  (in custom expr_entry at level 12, left associativity).\nNotation \"x * y\" := (EBinop OMul x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x / y\" := (EBinop ODiv x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x % y\" := (EBinop OMod x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x <= y\" := (EBinop OLe x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x < y\" := (EBinop OLt x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x >= y\" := (EBinop OGe x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x > y\" := (EBinop OGt x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x == y\" := (EBinop OEq x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x != y\" := (EBinop ONe x y)\n  (in custom expr_entry at level 13, no associativity).\nNotation \"x && y\" := (EBinop OAnd x y)\n  (in custom expr_entry at level 14, left associativity).\nNotation \"x || y\" := (EBinop OOr x y)\n  (in custom expr_entry at level 15, left associativity).\nNotation \"! x\" := (EUnop ONot x)\n  (in custom expr_entry at level 10).\nNotation \"- x\" := (EUnop ONeg x)\n  (in custom expr_entry at level 10).\nNotation \"c1 ; c2\" := (CSeq c1 c2)\n  (in custom expr_entry at level 20, right associativity).\nNotation \"'skip'\" := (CSkip)\n  (in custom expr_entry at level 10).\nNotation \"'if' e 'then' '{' c1 '}' 'else' '{' c2 '}'\" := (CIf e c1 c2)\n  (in custom expr_entry at level 19,\n   e custom expr_entry at level 5,\n   c1 custom expr_entry at level 99,\n   c2 custom expr_entry at level 99,\n   format  \"'if'  e  'then'  '{'  c1  '}'  'else'  '{'  c2  '}'\").\nNotation \"'while' e 'do' '{' c1 '}'\" := (CWhile e c1)\n  (in custom expr_entry at level 19,\n   e custom expr_entry at level 5,\n   c1 custom expr_entry at level 99).\n\nNotation \"⟦ e ⟧\" := (eval_expr e)\n  (at level 0, only printing, e custom expr_entry at level 99).\nNotation \"⟦ c ⟧\" := (eval_com c)\n  (at level 0, only printing, c custom expr_entry at level 99).\n\nLtac any_eval x :=\n  match goal with\n  | |- EDenote => exact (eval_expr x)\n  | |- CDenote => exact (eval_com x)\n  | _ => match type of x with\n         | expr => exact (eval_expr x)\n         | com => exact (eval_com x)\n         end\n  end.\n\nNotation \"⟦ x ⟧\" := (ltac:(any_eval x))\n  (at level 0, only parsing, x custom expr_entry at level 99).\n\nNotation \"x × y\" := (@Sets.test1 _ (y -> Prop) _ x)\n  (no associativity, at level 61): sets_scope.\n\n(** 表达式语义等价 *)\n\nRecord eequiv (e1 e2: expr): Prop := {\n  nrm_eequiv:\n    ⟦ e1 ⟧.(nrm) == ⟦ e2 ⟧.(nrm);\n  err_eequiv:\n    ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err);\n}.\n\n(** 表达式精化关系 *)\n\nRecord erefine (e1 e2: expr): Prop := {\n  nrm_erefine:\n    ⟦ e1 ⟧.(nrm) ⊆ ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64);\n  err_erefine:\n    ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err);\n}.\n\n(** 程序语句语义等价 *)\n\nRecord cequiv (c1 c2: com): Prop := {\n  nrm_cequiv: ⟦ c1 ⟧.(nrm) == ⟦ c2 ⟧.(nrm);\n  err_cequiv: ⟦ c1 ⟧.(err) == ⟦ c2 ⟧.(err);\n  inf_cequiv: ⟦ c1 ⟧.(inf) == ⟦ c2 ⟧.(inf);\n}.\n\n(** 程序语句精化关系 *)\n\nRecord crefine (c1 c2: com): Prop := {\n  nrm_crefine:\n    ⟦ c1 ⟧.(nrm) ⊆ ⟦ c2 ⟧.(nrm) ∪ (⟦ c2 ⟧.(err) × state);\n  err_crefine:\n    ⟦ c1 ⟧.(err) ⊆ ⟦ c2 ⟧.(err);\n  inf_crefine:\n    ⟦ c1 ⟧.(inf) ⊆ ⟦ c2 ⟧.(inf) ∪ ⟦ c2 ⟧.(err);\n}.\n\nNotation \"e1 '~=~' e2\" := (eequiv e1 e2)\n  (at level 69, only printing, no associativity).\nNotation \"e1 '<<=' e2\" := (erefine e1 e2)\n  (at level 69, only printing, no associativity).\nNotation \"c1 '~=~' c2\" := (cequiv c1 c2)\n  (at level 69, only printing, no associativity).\nNotation \"c1 '<<=' c2\" := (crefine c1 c2)\n  (at level 69, only printing, no associativity).\n\nLtac any_equiv x y :=\n  match type of x with\n  | expr => exact (eequiv x y)\n  | com => exact (cequiv x y)\n  | _ => match type of y with\n         | expr => exact (eequiv x y)\n         | com => exact (cequiv x y)\n         end\n  end.\n\nLtac any_refine x y :=\n  match type of x with\n  | expr => exact (erefine x y)\n  | com => exact (crefine x y)\n  | _ => match type of y with\n         | expr => exact (erefine x y)\n         | com => exact (crefine x y)\n         end\n  end.\n\nNotation \"x '~=~' y\" := (ltac:(any_equiv x y))\n  (at level 69, only parsing, no associativity).\nNotation \"x '<<=' y\" := (ltac:(any_refine x y))\n  (at level 69, only parsing, no associativity).\n\nNotation \"H '.(nrm_eequiv)'\" := (nrm_eequiv _ _ H)\n  (at level 1).\nNotation \"H '.(err_eequiv)'\" := (err_eequiv _ _ H)\n  (at level 1).\nNotation \"H '.(nrm_erefine)'\" := (nrm_erefine _ _ H)\nNotation \"H '.(err_erefine)'\" := (err_erefine _ _ H)\n(at level 1).\n  (at level 1).\nNotation \"H '.(nrm_cequiv)'\" := (nrm_cequiv _ _ H)\n  (at level 1).\nNotation \"H '.(err_cequiv)'\" := (err_cequiv _ _ H)\n  (at level 1).\nNotation \"H '.(inf_cequiv)'\" := (inf_cequiv _ _ H)\n  (at level 1).\nNotation \"H '.(nrm_crefine)'\" := (nrm_crefine _ _ H)\n  (at level 1).\nNotation \"H '.(err_crefine)'\" := (err_crefine _ _ H)\n  (at level 1).\nNotation \"H '.(inf_crefine)'\" := (inf_crefine _ _ H)\n  (at level 1).\n\n(** 精化的例子 *)\n\nLemma const_plus_const_refine: forall n m: Z,\n  EConst (n + m) <<= [[n + m]].\n(** 证明见Coq代码。*)\nProof.\n  intros.\n  assert (Int64.min_signed <= n <= Int64.max_signed \\/\n          n < Int64.min_signed \\/\n          n > Int64.max_signed) as Hn by lia.\n  assert (Int64.min_signed <= m <= Int64.max_signed \\/\n          m < Int64.min_signed \\/\n          m > Int64.max_signed) as Hm by lia.\n  split.\n  + sets_unfold; intros s i ?.\n    simpl in H.\n    destruct H.\n    destruct Hn; [destruct Hm |]; [left | right | right]; simpl; sets_unfold.\n    - unfold arith_sem1_nrm, arith_compute1_nrm.\n      exists (Int64.repr n), (Int64.repr m).\n      pose proof Int64.signed_repr _ H1.\n      pose proof Int64.signed_repr _ H2.\n      rewrite H3, H4.\n      tauto.\n    - tauto.\n    - tauto.\n  + sets_unfold; intros s ?.\n    simpl in H.\n    simpl; sets_unfold.\n    unfold arith_sem1_err, arith_compute1_err.\n    destruct Hn; [destruct Hm |]; [right | left | left]; simpl; sets_unfold.\n    - exists (Int64.repr n), (Int64.repr m).\n      pose proof Int64.signed_repr _ H0.\n      pose proof Int64.signed_repr _ H1.\n      rewrite H2, H3.\n      tauto.\n    - tauto.\n    - tauto.\nQed.\n\n(** 语义等价的例子：顺序执行有结合律 *)\n\nTheorem CSeq_assoc: forall (c1 c2 c3: com),\n  [[c1; (c2; c3)]] ~=~ [[(c1; c2); c3]].\nProof.\n  intros.\n  split.\n  + simpl.\n    rewrite Rels_concat_assoc.\n    reflexivity.\n  + simpl.\n    rewrite Rels_concat_union_distr_l.\n    rewrite Sets_union_assoc.\n    rewrite Rels_concat_assoc.\n    reflexivity.\n  + simpl.\n    rewrite Rels_concat_union_distr_l.\n    rewrite Sets_union_assoc.\n    rewrite Rels_concat_assoc.\n    reflexivity.\nQed.\n\n\nTheorem CIf_CSeq: forall e c1 c2 c3,\n  [[ if e then { c1 } else { c2 }; c3 ]] ~=~\n  [[ if e then { c1; c3 } else { c2; c3 } ]].\nProof.\n  intros.\n  split.\n  + simpl.\n    rewrite <- ! Rels_concat_assoc.\n    apply Rels_concat_union_distr_r.\n  + simpl.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite <- ! Rels_concat_assoc.\n    sets_unfold; intros s; tauto.\n  + simpl.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite <- ! Rels_concat_assoc.\n    sets_unfold; intros s; tauto.\nQed.\n\n\n\n\n(** * 语义等价与精化的性质 *)\n\n\n(** 接下去，我们介绍语义等价的两条重要性质。其一：语义等价是一种等价关系。  \n\n\n    在Coq标准库中，_[Reflexive]_、_[Symmetric]_、_[Transitive]_以及\n    _[Equivalence]_定义了自反性、对称性、传递性以及等价关系。下面证明中，我们统\n    一使用了_[Instance]_关键字，而非之前证明中常用的_[Theorem]_与_[Lemma]_，我们\n    将稍后再解释_[Instance]_关键字的特殊作用。*)\n\nInstance eequiv_refl: Reflexive eequiv.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + reflexivity.\n  + reflexivity.\nQed.\n\nInstance eequiv_sym: Symmetric eequiv.\nProof.\n  unfold Symmetric; intros.\n  split.\n  + rewrite H.(nrm_eequiv).\n    reflexivity.\n  + rewrite H.(err_eequiv).\n    reflexivity.\nQed.\n\nInstance eequiv_trans: Transitive eequiv.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_eequiv), H0.(nrm_eequiv).\n    reflexivity.\n  + rewrite H.(err_eequiv), H0.(err_eequiv).\n    reflexivity.\nQed.\n\nInstance eequiv_equiv: Equivalence eequiv.\nProof.\n  split.\n  + apply eequiv_refl.\n  + apply eequiv_sym.\n  + apply eequiv_trans.\nQed.\n\n(** 下面还可以证明精化关系也具有自反性和传递性。*)\n\nInstance erefine_refl: Reflexive erefine.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + apply Sets_included_union1.\n  + reflexivity.\nQed.\n\nInstance erefine_trans: Transitive erefine.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_erefine).\n    rewrite H0.(nrm_erefine).\n    rewrite H0.(err_erefine).\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite H.(err_erefine).\n    rewrite H0.(err_erefine).\n    reflexivity.\nQed.\n\n(** 并且精化关系在语义等价变换下不变。*)\n\nInstance erefine_well_defined:\n  Proper (eequiv ==> eequiv ==> iff) erefine.\nProof.\n  unfold Proper, respectful; intros.\n  split; intros.\n  + split.\n    - rewrite <- H.(nrm_eequiv).\n      rewrite <- H0.(nrm_eequiv).\n      rewrite <- H0.(err_eequiv).\n      apply H1.(nrm_erefine).\n    - rewrite <- H.(err_eequiv).\n      rewrite <- H0.(err_eequiv).\n      apply H1.(err_erefine).\n  + split.\n    - rewrite H.(nrm_eequiv).\n      rewrite H0.(nrm_eequiv).\n      rewrite H0.(err_eequiv).\n      apply H1.(nrm_erefine).\n    - rewrite H.(err_eequiv).\n      rewrite H0.(err_eequiv).\n      apply H1.(err_erefine).\nQed.\n\n(** 程序语句间的语义等价关系也是等价关系，程序语句间的精化关系也具有自反性与传递\n    性。*)\n\nInstance cequiv_refl: Reflexive cequiv.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + reflexivity.\n  + reflexivity.\n  + reflexivity.\nQed.\n\nInstance cequiv_sym: Symmetric cequiv.\nProof.\n  unfold Symmetric; intros.\n  split.\n  + rewrite H.(nrm_cequiv).\n    reflexivity.\n  + rewrite H.(err_cequiv).\n    reflexivity.\n  + rewrite H.(inf_cequiv).\n    reflexivity.\nQed.\n\nInstance cequiv_trans: Transitive cequiv.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_cequiv), H0.(nrm_cequiv).\n    reflexivity.\n  + rewrite H.(err_cequiv), H0.(err_cequiv).\n    reflexivity.\n  + rewrite H.(inf_cequiv), H0.(inf_cequiv).\n    reflexivity.\nQed.\n\nInstance cequiv_equiv: Equivalence cequiv.\nProof.\n  split.\n  + apply cequiv_refl.\n  + apply cequiv_sym.\n  + apply cequiv_trans.\nQed.\n\nInstance crefine_refl: Reflexive crefine.\nProof.\n  unfold Reflexive; intros.\n  split.\n  + apply Sets_included_union1.\n  + reflexivity.\n  + apply Sets_included_union1.\nQed.\n\nInstance crefine_trans: Transitive crefine.\nProof.\n  unfold Transitive; intros.\n  split.\n  + rewrite H.(nrm_crefine).\n    rewrite H0.(nrm_crefine).\n    rewrite H0.(err_crefine).\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite H.(err_crefine).\n    rewrite H0.(err_crefine).\n    reflexivity.\n  + rewrite H.(inf_crefine).\n    rewrite H0.(inf_crefine).\n    rewrite H0.(err_crefine).\n    sets_unfold; intros s; tauto.\nQed.\n\nInstance crefine_well_defined:\n  Proper (cequiv ==> cequiv ==> iff) crefine.\nProof.\n  unfold Proper, respectful; intros.\n  split; intros.\n  + split.\n    - rewrite <- H.(nrm_cequiv).\n      rewrite <- H0.(nrm_cequiv).\n      rewrite <- H0.(err_cequiv).\n      apply H1.(nrm_crefine).\n    - rewrite <- H.(err_cequiv).\n      rewrite <- H0.(err_cequiv).\n      apply H1.(err_crefine).\n    - rewrite <- H.(inf_cequiv).\n      rewrite <- H0.(inf_cequiv).\n      rewrite <- H0.(err_cequiv).\n      apply H1.(inf_crefine).\n  + split.\n    - rewrite H.(nrm_cequiv).\n      rewrite H0.(nrm_cequiv).\n      rewrite H0.(err_cequiv).\n      apply H1.(nrm_crefine).\n    - rewrite H.(err_cequiv).\n      rewrite H0.(err_cequiv).\n      apply H1.(err_crefine).\n    - rewrite H.(inf_cequiv).\n      rewrite H0.(inf_cequiv).\n      rewrite H0.(err_cequiv).\n      apply H1.(inf_crefine).\nQed.\n\n\n\n(** 两条重要性质之二是：所有语法连接词能保持语义等价关系（congruence），也能保持\n    精化关系（monotonicity）。下面先证明加法、减法、乘法的情况。*)\n\nLemma arith_sem1_nrm_congr: forall Zfun (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s i.\n  unfold arith_sem1_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma arith_sem1_err_congr: forall Zfun (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s.\n  unfold arith_sem1_err.\n  apply or_iff_morphism.\n  + apply or_iff_morphism.\n    - apply H.(err_eequiv).\n    - apply H0.(err_eequiv).\n  + apply ex_iff_morphism; intros i1.\n    apply ex_iff_morphism; intros i2.\n    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n    reflexivity.\nQed.\n\nLemma arith_sem1_nrm_mono: forall Zfun (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  arith_sem1_nrm Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  arith_sem1_nrm Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n    arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold arith_sem1_nrm, arith_sem1_err.\n  intros [i1 [i2 [? [? ?] ] ] ].\n  apply H.(nrm_erefine) in H1.\n  apply H0.(nrm_erefine) in H2.\n  sets_unfold in H1.\n  sets_unfold in H2.\n  destruct H1; [| tauto].\n  destruct H2; [| tauto].\n  left.\n  exists i1, i2.\n  tauto.\nQed.\n\nLemma arith_sem1_err_mono: forall Zfun (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem1_err Zfun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold arith_sem1_err.\n  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n  + apply H.(err_erefine) in H1.\n    tauto.\n  + apply H0.(err_erefine) in H1.\n    tauto.\n  + apply H.(nrm_erefine) in H1.\n    apply H0.(nrm_erefine) in H2.\n    sets_unfold in H1.\n    sets_unfold in H2.\n    destruct H1; [| tauto].\n    destruct H2; [| tauto].\n    right.\n    exists i1, i2.\n    tauto.\nQed.\n\n(** 很多其它情况的证明是类似的。*)\n\nLemma arith_sem2_nrm_congr: forall int64fun (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s i.\n  unfold arith_sem2_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma arith_sem2_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  unfold arith_sem2_err.\n  apply or_iff_morphism.\n  + apply or_iff_morphism.\n    - apply H.(err_eequiv).\n    - apply H0.(err_eequiv).\n  + apply ex_iff_morphism; intros i1.\n    apply ex_iff_morphism; intros i2.\n    apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n    apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n    reflexivity.\nQed.\n\nLemma arith_sem2_nrm_mono: forall int64fun (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  arith_sem2_nrm int64fun ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  arith_sem2_nrm int64fun ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n    arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold arith_sem2_nrm, arith_sem2_err.\n  intros [i1 [i2 [? [? ?] ] ] ].\n  apply H.(nrm_erefine) in H1.\n  apply H0.(nrm_erefine) in H2.\n  sets_unfold in H1.\n  sets_unfold in H2.\n  destruct H1; [| tauto].\n  destruct H2; [| tauto].\n  left.\n  exists i1, i2.\n  tauto.\nQed.\n\nLemma arith_sem2_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ∪\n  arith_sem2_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err) ∪\n  arith_sem2_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold arith_sem2_err.\n  intros [ [? | ?] | [i1 [i2 [? [? ?] ] ] ] ].\n  + apply H.(err_erefine) in H1.\n    tauto.\n  + apply H0.(err_erefine) in H1.\n    tauto.\n  + apply H.(nrm_erefine) in H1.\n    apply H0.(nrm_erefine) in H2.\n    sets_unfold in H1.\n    sets_unfold in H2.\n    destruct H1; [| tauto].\n    destruct H2; [| tauto].\n    right.\n    exists i1, i2.\n    tauto.\nQed.\n\nLemma cmp_sem_nrm_congr: forall op (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? ? s i.\n  unfold cmp_sem_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma cmp_sem_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ==\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  apply or_iff_morphism.\n  + apply H.(err_eequiv).\n  + apply H0.(err_eequiv).\nQed.\n\nLemma cmp_sem_nrm_mono: forall op (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  cmp_sem_nrm op ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  cmp_sem_nrm op ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold cmp_sem_nrm.\n  intros [i1 [i2 [? [? ?] ] ] ].\n  apply H.(nrm_erefine) in H1.\n  apply H0.(nrm_erefine) in H2.\n  sets_unfold in H1.\n  sets_unfold in H2.\n  destruct H1; [| tauto].\n  destruct H2; [| tauto].\n  left.\n  exists i1, i2.\n  tauto.\nQed.\n\nLemma cmp_sem_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ ⟦ e21 ⟧.(err) ⊆\n  ⟦ e12 ⟧.(err) ∪ ⟦ e22 ⟧.(err).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  intros [? | ?].\n  + apply H.(err_erefine) in H1.\n    tauto.\n  + apply H0.(err_erefine) in H1.\n    tauto.\nQed.\n\nLemma and_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s i.\n  unfold and_sem_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply or_iff_morphism; [reflexivity |].\n  apply and_iff_morphism; [reflexivity |].\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma and_sem_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  unfold and_sem_err.\n  apply or_iff_morphism; [apply H.(err_eequiv) |].\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n  reflexivity.\nQed.\n\nLemma and_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  and_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  and_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold and_sem_nrm, and_sem_err.\n  intros [i1 ?].\n  destruct H1.\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  destruct H2; [left; exists i1; tauto |].\n  destruct H2 as [? [i2 [? ?] ] ].\n  apply H0.(nrm_erefine) in H3.\n  sets_unfold in H3.\n  destruct H3; [| right; right; exists i1; tauto].\n  left; exists i1.\n  split; [tauto |].\n  right.\n  split; [tauto |].\n  exists i2; tauto.\nQed.\n\nLemma and_sem_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ and_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n  ⟦ e12 ⟧.(err) ∪ and_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold and_sem_err.\n  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n  destruct H1 as [i1 [? [? ?] ] ].\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  right; exists i1.\n  apply H0.(err_erefine) in H3.\n  tauto.\nQed.\n\nLemma or_sem_nrm_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ==\n  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s i.\n  unfold or_sem_nrm.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply or_iff_morphism; [reflexivity |].\n  apply and_iff_morphism; [reflexivity |].\n  apply ex_iff_morphism; intros i2.\n  apply and_iff_morphism; [apply H0.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma or_sem_err_congr: forall (e11 e12 e21 e22: expr),\n  e11 ~=~ e12 ->\n  e21 ~=~ e22 ->\n  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ==\n  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  sets_unfold.\n  intros ? ? ? ? ? ? s.\n  unfold or_sem_err.\n  apply or_iff_morphism; [apply H.(err_eequiv) |].\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  apply and_iff_morphism; [| apply H0.(err_eequiv)].\n  reflexivity.\nQed.\n\nLemma or_sem_nrm_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  or_sem_nrm ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(nrm) ⊆\n  or_sem_nrm ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(nrm) ∪\n  ((⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err)) × int64).\nProof.\n  intros.\n  sets_unfold.\n  intros s i.\n  unfold or_sem_nrm, or_sem_err.\n  intros [i1 ?].\n  destruct H1.\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  destruct H2; [left; exists i1; tauto |].\n  destruct H2 as [? [i2 [? ?] ] ].\n  apply H0.(nrm_erefine) in H3.\n  sets_unfold in H3.\n  destruct H3; [| right; right; exists i1; tauto].\n  left; exists i1.\n  split; [tauto |].\n  right.\n  split; [tauto |].\n  exists i2; tauto.\nQed.\n\nLemma or_sem_err_mono: forall (e11 e12 e21 e22: expr),\n  e11 <<= e12 ->\n  e21 <<= e22 ->\n  ⟦ e11 ⟧.(err) ∪ or_sem_err ⟦ e11 ⟧.(nrm) ⟦ e21 ⟧.(err) ⊆\n  ⟦ e12 ⟧.(err) ∪ or_sem_err ⟦ e12 ⟧.(nrm) ⟦ e22 ⟧.(err).\nProof.\n  intros.\n  sets_unfold.\n  intros s.\n  unfold or_sem_err.\n  intros [? | ?]; [left; apply H.(err_erefine); tauto |].\n  destruct H1 as [i1 [? [? ?] ] ].\n  apply H.(nrm_erefine) in H1.\n  sets_unfold in H1.\n  destruct H1; [| tauto].\n  right; exists i1.\n  apply H0.(err_erefine) in H3.\n  tauto.\nQed.\n\n(** 下面把二元运算的情况汇总起来。*)\n\nInstance EBinop_congr: forall op,\n  Proper (eequiv ==> eequiv ==> eequiv) (EBinop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  (** 布尔二元运算的情况 *)\n  + split.\n    - apply or_sem_nrm_congr; tauto.\n    - apply or_sem_err_congr; tauto.\n  + split.\n    - apply and_sem_nrm_congr; tauto.\n    - apply and_sem_err_congr; tauto.\n  (** 大小比较的情况 *)\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  + split.\n    - apply cmp_sem_nrm_congr; tauto.\n    - apply cmp_sem_err_congr; tauto.\n  (** 加减乘运算的情况 *)\n  + split.\n    - apply arith_sem1_nrm_congr; tauto.\n    - apply arith_sem1_err_congr; tauto.\n  + split.\n    - apply arith_sem1_nrm_congr; tauto.\n    - apply arith_sem1_err_congr; tauto.\n  + split.\n    - apply arith_sem1_nrm_congr; tauto.\n    - apply arith_sem1_err_congr; tauto.\n  (** 除法与取余的情况 *)\n  + split.\n    - apply arith_sem2_nrm_congr; tauto.\n    - apply arith_sem2_err_congr; tauto.\n  + split.\n    - apply arith_sem2_nrm_congr; tauto.\n    - apply arith_sem2_err_congr; tauto.\nQed.\n\nInstance EBinop_mono: forall op,\n  Proper (erefine ==> erefine ==> erefine) (EBinop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  (** 布尔二元运算的情况 *)\n  + split.\n    - simpl.\n    Locate \"×\".\n    Set Printing All.\n\n      apply (or_sem_nrm_mono x y x0 y0); tauto.\n    - apply or_sem_err_mono; tauto.\n  + split.\n    - apply and_sem_nrm_mono; tauto.\n    - apply and_sem_err_mono; tauto.\n  (** 大小比较的情况 *)\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  + split.\n    - apply cmp_sem_nrm_mono; tauto.\n    - apply cmp_sem_err_mono; tauto.\n  (** 加减乘运算的情况 *)\n  + split.\n    - apply arith_sem1_nrm_mono; tauto.\n    - apply arith_sem1_err_mono; tauto.\n  + split.\n    - apply arith_sem1_nrm_mono; tauto.\n    - apply arith_sem1_err_mono; tauto.\n  + split.\n    - apply arith_sem1_nrm_mono; tauto.\n    - apply arith_sem1_err_mono; tauto.\n  (** 除法与取余的情况 *)\n  + split.\n    - apply arith_sem2_nrm_mono; tauto.\n    - apply arith_sem2_err_mono; tauto.\n  + split.\n    - apply arith_sem2_nrm_mono; tauto.\n    - apply arith_sem2_err_mono; tauto.\nQed.\n\n(** 一元运算的情况是类似的。*)\n\nLemma not_sem_nrm_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  not_sem_nrm ⟦ e1 ⟧.(nrm) ==\n  not_sem_nrm ⟦ e2 ⟧.(nrm).\nProof.\n  unfold not_sem_nrm.\n  sets_unfold.\n  intros ? ? ? s i.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma not_sem_err_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  ⟦ e1 ⟧.(err) == ⟦ e2 ⟧.(err).\nProof.\n  intros.\n  apply H.(err_eequiv).\nQed.\n\nLemma not_sem_nrm_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  not_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n  not_sem_nrm ⟦ e2 ⟧.(nrm) ∪ (⟦ e2 ⟧.(err) × int64).\nProof.\n  unfold not_sem_nrm.\n  sets_unfold.\n  intros ? ? ? s i.\n  intros [i1 [? ?] ].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  left; exists i1.\n  tauto.\nQed.\n\nLemma not_sem_err_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  ⟦ e1 ⟧.(err) ⊆ ⟦ e2 ⟧.(err).\nProof.\n  intros.\n  apply H.(err_erefine).\nQed.\n\nLemma neg_sem_nrm_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  neg_sem_nrm ⟦ e1 ⟧.(nrm) ==\n  neg_sem_nrm ⟦ e2 ⟧.(nrm).\nProof.\n  unfold neg_sem_nrm.\n  sets_unfold.\n  intros ? ? ? s i.\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma neg_sem_err_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ==\n  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\nProof.\n  intros.\n  unfold neg_sem_err; sets_unfold.\n  intros s.\n  apply or_iff_morphism; [apply H.(err_eequiv) |].\n  apply ex_iff_morphism; intros i1.\n  apply and_iff_morphism; [apply H.(nrm_eequiv) |].\n  reflexivity.\nQed.\n\nLemma neg_sem_nrm_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  neg_sem_nrm ⟦ e1 ⟧.(nrm) ⊆\n  neg_sem_nrm ⟦ e2 ⟧.(nrm) ∪\n  ((⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm)) × int64).\nProof.\n  unfold neg_sem_nrm, neg_sem_err; sets_unfold.\n  intros ? ? ? s i.\n  intros [i1 [? ?] ].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  left; exists i1.\n  tauto.\nQed.\n\nLemma neg_sem_err_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  ⟦ e1 ⟧.(err) ∪ neg_sem_err ⟦ e1 ⟧.(nrm) ⊆\n  ⟦ e2 ⟧.(err) ∪ neg_sem_err ⟦ e2 ⟧.(nrm).\nProof.\n  unfold neg_sem_err; sets_unfold.\n  intros ? ? ? s ?.\n  destruct H0; [apply H.(err_erefine) in H0; tauto |].\n  destruct H0 as [i1 [? ?] ].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  right; exists i1.\n  tauto.\nQed.\n\nInstance EUnop_congr: forall op,\n  Proper (eequiv ==> eequiv) (EUnop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  + split.\n    - apply not_sem_nrm_congr; tauto.\n    - simpl. apply not_sem_err_congr; tauto.\n  + split.\n    - apply neg_sem_nrm_congr; tauto.\n    - apply neg_sem_err_congr; tauto.\nQed.\n\nInstance EUnop_mono: forall op,\n  Proper (erefine ==> erefine) (EUnop op).\nProof.\n  unfold Proper, respectful.\n  intros.\n  destruct op.\n  + split.\n    - simpl. apply not_sem_nrm_mono; tauto.\n    - simpl. apply not_sem_err_mono; tauto.\n  + split.\n    - apply neg_sem_nrm_mono; tauto.\n    - apply neg_sem_err_mono; tauto.\nQed.\n\n(** 下面证明程序语句中的语法连接词也能保持语义等价性和精化关系。顺序执行保持等价\n    性是比较显然的。*)\n\nInstance CSeq_congr:\n  Proper (cequiv ==> cequiv ==> cequiv) CSeq.\nProof.\n  unfold Proper, respectful.\n  intros c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite H.(nrm_cequiv).\n    rewrite H0.(nrm_cequiv).\n    reflexivity.\n  + rewrite H.(nrm_cequiv).\n    rewrite H.(err_cequiv).\n    rewrite H0.(err_cequiv).\n    reflexivity.\n  + rewrite H.(nrm_cequiv).\n    rewrite H.(inf_cequiv).\n    rewrite H0.(inf_cequiv).\n    reflexivity.\nQed.\n\n(** 为了证明顺序执行能保持精化关系，先证明两条引理。*)\n\nLemma Rels_times_full_concat2:\n  forall {A B C: Type} (X: A -> Prop) (Y: B -> C -> Prop),\n    (X × B) ∘ Y ⊆ X × C.\nProof.\n  intros.\n  sets_unfold.\n  intros a c.\n  intros [b [? ?] ].\n  tauto.\nQed.\n\nLemma Rels_times_full_concat1:\n  forall {A B: Type} (X: A -> Prop) (Y: B -> Prop),\n    (X × B) ∘ Y ⊆ X.\nProof.\n  intros.\n  sets_unfold.\n  intros a.\n  intros [b [? ?] ].\n  tauto.\nQed.\n\n(** 下面证明顺序执行能保持精化关系。*)\n\nInstance CSeq_mono:\n  Proper (crefine ==> crefine ==> crefine) CSeq.\nProof.\n  unfold Proper, respectful.\n  intros c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite H.(nrm_crefine).\n    rewrite H0.(nrm_crefine).\n    rewrite Rels_concat_union_distr_l.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_times_full_concat2.\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite H.(err_crefine).\n    rewrite H.(nrm_crefine).\n    rewrite H0.(err_crefine).\n    rewrite Rels_concat_union_distr_r.\n    rewrite Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\n  + rewrite H.(inf_crefine).\n    rewrite H0.(inf_crefine).\n    rewrite H.(nrm_crefine).\n    rewrite Rels_concat_union_distr_l.\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\nQed.\n\n(** 为了证明if语句能保持语义等价关系与精化关系，先证明_[test_true]_与\n    _[test_false]_的性质。*)\n\nLemma test_true_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  test_true ⟦ e1 ⟧ ⊆\n  test_true ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\nProof.\n  intros.\n  unfold test_true; sets_unfold; intros s1 s2.\n  intros [ [i [? ?] ] ?].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  left; split; [| tauto].\n  exists i; tauto.\nQed.\n\nLemma test_false_mono: forall (e1 e2: expr),\n  e1 <<= e2 ->\n  test_false ⟦ e1 ⟧ ⊆\n  test_false ⟦ e2 ⟧ ∪ (⟦ e2 ⟧.(err) × state).\nProof.\n  intros.\n  unfold test_false; sets_unfold; intros s1 s2.\n  intros [? ?].\n  apply H.(nrm_erefine) in H0.\n  sets_unfold in H0.\n  destruct H0; [| tauto].\n  tauto.\nQed.\n\nLemma test_true_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  test_true ⟦ e1 ⟧ == test_true ⟦ e2 ⟧.\nProof.\n  intros.\n  unfold test_true; sets_unfold; intros s1 s2.\n  apply and_iff_morphism; [| reflexivity].\n  apply ex_iff_morphism; intros i.\n  apply and_iff_morphism; [| reflexivity].\n  apply H.(nrm_eequiv).\nQed.\n\nLemma test_false_congr: forall (e1 e2: expr),\n  e1 ~=~ e2 ->\n  test_false ⟦ e1 ⟧ == test_false ⟦ e2 ⟧.\nProof.\n  intros.\n  unfold test_false; sets_unfold; intros s1 s2.\n  apply and_iff_morphism; [| reflexivity].\n  apply H.(nrm_eequiv).\nQed.\n\n(** 基于此就可以证明if语句能保持语义等价关系与精化关系。*)\n\nInstance CIf_congr:\n  Proper (eequiv ==> cequiv ==> cequiv ==> cequiv) CIf.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite (test_true_congr _ _ H).\n    rewrite (test_false_congr _ _ H).\n    rewrite H0.(nrm_cequiv).\n    rewrite H1.(nrm_cequiv).\n    reflexivity.\n  + rewrite (test_true_congr _ _ H).\n    rewrite (test_false_congr _ _ H).\n    rewrite H.(err_eequiv).\n    rewrite H0.(err_cequiv).\n    rewrite H1.(err_cequiv).\n    reflexivity.\n  + rewrite (test_true_congr _ _ H).\n    rewrite (test_false_congr _ _ H).\n    rewrite H0.(inf_cequiv).\n    rewrite H1.(inf_cequiv).\n    reflexivity.\nQed.\n\nInstance CIf_mono:\n  Proper (erefine ==> crefine ==> crefine ==> crefine) CIf.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c11 c12 ? c21 c22 ?.\n  split; simpl.\n  + rewrite (test_true_mono e1 e2 H).\n    rewrite (test_false_mono e1 e2 H).\n    rewrite H0.(nrm_crefine), H1.(nrm_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat2.\n    sets_unfold; intros s1 s2; tauto.\n  + rewrite (test_true_mono e1 e2 H).\n    rewrite (test_false_mono e1 e2 H).\n    rewrite H.(err_erefine).\n    rewrite H0.(err_crefine), H1.(err_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\n  + rewrite (test_true_mono e1 e2 H).\n    rewrite (test_false_mono e1 e2 H).\n    rewrite H0.(inf_crefine), H1.(inf_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\nQed.\n\n(** 要证明while语句保持语义等价关系，就需要运用集合并集的有关性质，还需要对迭代\n    的次数进行归纳。*)\n\nInstance CWhile_congr:\n  Proper (eequiv ==> cequiv ==> cequiv) CWhile.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c1 c2 ?.\n  split; simpl.\n  (** 正常运行终止的情况。*)\n  + apply Sets_indexed_union_congr; intros n.\n    induction n; simpl.\n    - reflexivity.\n    - rewrite IHn.\n      rewrite (test_true_congr _ _ H).\n      rewrite (test_false_congr _ _ H).\n      rewrite H0.(nrm_cequiv).\n      reflexivity.\n  (** 运行出错的情况。*)\n  + apply Sets_indexed_union_congr; intros n.\n    induction n; simpl.\n    - reflexivity.\n    - rewrite IHn.\n      rewrite (test_true_congr _ _ H).\n      rewrite H.(err_eequiv).\n      rewrite H0.(nrm_cequiv).\n      rewrite H0.(err_cequiv).\n      reflexivity.\n  (** 运行不终止的情况。*)\n  + apply Sets_general_union_congr.\n    intros X.\n    unfold_CL_defs.\n    rewrite H0.(nrm_cequiv).\n    rewrite H0.(inf_cequiv).\n    rewrite (test_true_congr _ _ H).\n    reflexivity.\nQed.\n\n(** 要证明while语句保持精化关系就更复杂一些了。*)\n\nDefinition boundedLB_nrm\n             (D0: EDenote)\n             (D1: CDenote)\n             (n: nat):\n  state -> state -> Prop :=\n  Nat.iter\n    n\n    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_false D0)\n    ∅.\n\nDefinition boundedLB_err\n             (D0: EDenote)\n             (D1: CDenote)\n             (n: nat):\n  state -> Prop :=\n  Nat.iter\n    n\n    (fun X => test_true D0 ∘ D1.(nrm) ∘ X ∪ test_true D0 ∘ D1.(err) ∪ D0.(err))\n    ∅.\n\nDefinition is_inf\n             (D0: EDenote)\n             (D1: CDenote)\n             (X: state -> Prop): Prop :=\n  X ⊆ test_true D0 ∘ D1.(nrm) ∘ X ∪\n      test_true D0 ∘ D1.(inf).\n\nLemma boundedLB_nrm_mono_aux:\n  forall (e1 e2: expr) (c1 c2: com) n,\n    e1 <<= e2 ->\n    c1 <<= c2 ->\n    boundedLB_nrm ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n    boundedLB_nrm ⟦ e2 ⟧ ⟦ c2 ⟧ n ∪\n    (boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n × state).\nProof.\n  intros.\n  induction n; simpl.\n  + apply Sets_empty_included.\n  + rewrite IHn.\n    rewrite (test_true_mono _ _ H).\n    rewrite (test_false_mono _ _ H).\n    rewrite H0.(nrm_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat2.\n    sets_unfold; intros s1 s2; tauto.\nQed.\n\nLemma boundedLB_err_mono_aux:\n  forall (e1 e2: expr) (c1 c2: com) n,\n    e1 <<= e2 ->\n    c1 <<= c2 ->\n    boundedLB_err ⟦ e1 ⟧ ⟦ c1 ⟧ n ⊆\n    boundedLB_err ⟦ e2 ⟧ ⟦ c2 ⟧ n.\nProof.\n  intros.\n  induction n; simpl.\n  + apply Sets_empty_included.\n  + rewrite IHn.\n    rewrite (test_true_mono _ _ H).\n    rewrite H.(err_erefine).\n    rewrite H0.(nrm_crefine).\n    rewrite H0.(err_crefine).\n    rewrite ! Rels_concat_union_distr_r.\n    rewrite ! Rels_concat_union_distr_l.\n    rewrite ! Rels_times_full_concat1.\n    sets_unfold; intros s; tauto.\nQed.\n\nLemma Sets_complement_indexed_union:\n  forall {A I: Type} (Xs: I -> A -> Prop),\n    Sets.complement (⋃ Xs) ==\n    ⋂ (fun n => Sets.complement (Xs n)).\nProof.\n  intros.\n  sets_unfold.\n  split.\n  + apply not_ex_all_not.\n  + apply all_not_not_ex.\nQed.\n\nDefinition noerrorLB (D1: EDenote) (D2: CDenote): state -> Prop :=\n  Sets.complement (⋃ (boundedLB_err D1 D2)).\n\nLemma iter_err_fact:\n  forall (D1: EDenote) (D2: CDenote),\n    test_true D1 ∘ D2.(nrm) ∘ ⋃ (boundedLB_err D1 D2) ⊆\n    ⋃ (boundedLB_err D1 D2).\nProof.\n  intros.\n  rewrite ! Rels_concat_indexed_union_distr_l.\n  apply Sets_indexed_union_included; intros n.\n  rewrite <- (Sets_included_indexed_union _ _ (S n)).\n  simpl.\n  sets_unfold; intros s; tauto.\nQed.\n\nLemma Rels_concat_excluding_r:\n  forall\n    {A B: Type}\n    (R: A -> B -> Prop)\n    (S T: B -> Prop),\n    (R ∘ S) ∩ Sets.complement (R ∘ T) ⊆\n    R ∘ (S ∩ Sets.complement T).\nProof.\n  intros.\n  Sets_unfold; intros a.\n  intros [ [b [? ?] ] ?].\n  exists b.\n  split; [tauto |].\n  split; [tauto |].\n  assert (T b -> exists b : B, R a b /\\ T b); [| tauto].\n  clear H1; intros.\n  exists b; tauto.\nQed.\n\nLemma noerrorLB_fact1:\n  forall (D1: EDenote) (D2: CDenote),\n    D1.(err) ∩ noerrorLB D1 D2 == ∅.\nProof.\n  intros.\n  unfold noerrorLB.\n  rewrite Sets_complement_indexed_union.\n  apply Sets_equiv_Sets_included.\n  split; [| apply Sets_empty_included].\n  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n  simpl.\n  sets_unfold; intros s.\n  tauto.\nQed.\n\nLemma noerrorLB_fact2:\n  forall (D1: EDenote) (D2: CDenote),\n    (test_true D1 ∘ D2.(err)) ∩ noerrorLB D1 D2 == ∅.\nProof.\n  intros.\n  unfold noerrorLB.\n  rewrite Sets_complement_indexed_union.\n  apply Sets_equiv_Sets_included.\n  split; [| apply Sets_empty_included].\n  rewrite (Sets_indexed_intersect_included _ _ (S O)).\n  simpl.\n  sets_unfold; intros s.\n  tauto.\nQed.\n\nLemma inf_mono_aux:\n  forall (e1 e2: expr) (c1 c2: com) X,\n    e1 <<= e2 ->\n    c1 <<= c2 ->\n    is_inf ⟦ e1 ⟧ ⟦ c1 ⟧ X ->\n    is_inf ⟦ e2 ⟧ ⟦ c2 ⟧ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\nProof.\n  unfold is_inf.\n  intros.\n  rewrite H1 at 1.\n  rewrite (test_true_mono _ _ H).\n  rewrite H0.(nrm_crefine).\n  rewrite H0.(inf_crefine).\n  rewrite ! Rels_concat_union_distr_r.\n  rewrite ! Rels_concat_union_distr_l.\n  rewrite ! Rels_times_full_concat1.\n  rewrite ! Sets_intersect_union_distr_r.\n  rewrite noerrorLB_fact1.\n  rewrite noerrorLB_fact2.\n  rewrite ! Sets_union_empty.\n  unfold noerrorLB at 1.\n  rewrite <- iter_err_fact at 1.\n  rewrite ! Rels_concat_excluding_r.\n  fold (noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧).\n  sets_unfold; intros s; tauto.\nQed.\n\nInstance CWhile_mono:\n  Proper (erefine ==> crefine ==> crefine) CWhile.\nProof.\n  unfold Proper, respectful.\n  intros e1 e2 ? c1 c2 ?.\n  split; simpl.\n  + apply Sets_indexed_union_included; intros n.\n    unfold BW_LFix. unfold_CPO_defs.\n    rewrite <- ! (Sets_included_indexed_union _ _ n).\n    apply boundedLB_nrm_mono_aux; tauto.\n  + apply Sets_indexed_union_included; intros n.\n    unfold BW_LFix. unfold_CPO_defs.\n    rewrite <- (Sets_included_indexed_union _ _ n).\n    apply boundedLB_err_mono_aux; tauto.\n  + apply Sets_general_union_included. unfold_CL_defs.\n    intros X ?.\n    pose proof inf_mono_aux _ _ _ _ _ H H0 H1.\n    unfold KT_GFix; unfold_CL_defs.\n    rewrite <- (Sets_included_general_union _ (X ∩ noerrorLB ⟦ e2 ⟧ ⟦ c2 ⟧))\n      by (exact H2).\n    unfold noerrorLB.\n    sets_unfold; intros s; tauto.\nQed.\n\n(** 下面是一个证明中使用了语义等价的重要性质：语义等价是等价关系、语法连接词保持等价性。*)\n\nExample cequiv_sample: forall (e: expr) (c1 c2 c3 c4: com),\n  [[ if (e) then { c1 } else { c2 }; c3; c4 ]] ~=~\n  [[ if (e) then { c1; c3 } else { c2; c3 }; c4 ]].\nProof.\n  intros.\n  rewrite CSeq_assoc.\n  rewrite CIf_CSeq.\n  reflexivity.\nQed.\n\n"
        }
    ]
}