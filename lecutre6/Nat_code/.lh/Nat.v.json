{
    "sourceFile": "Nat.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1697020148758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1697020148758,
            "name": "Commit-0",
            "content": "Require Import Coq.Arith.PeanoNat.\n\n(** 在Coq中，许多数学上的集合可以用归纳类型定义。例如，Coq中自然数的定义就是最简\n    单的归纳类型之一。  \n\n    下面Coq代码可以用于查看_[nat]_在Coq中的定义。*)\nPrint nat.\n(** 查询结果如下。  \n    Inductive nat := O : nat | S: nat -> nat.   \n\n    可以看到，自然数集合的归纳定义可以看做_[list]_进一步退化的结果。下面我们在\n    Coq中定义自然数的加法，并且也试着证明一条基本性质：加法交换律。  \n\n\n    由于Coq的标准库中已经定义了自然数以及自然数的加法。我们开辟一个_[NatDemo]_来\n    开发我们自己的定义与证明。以免与Coq标准库的定义相混淆。*)\n\nModule NatDemo.\n\n(** 先定义自然数_[nat]_。*)\n\nInductive nat :=\n| O: nat\n| S (n: nat): nat.\n\n(** 再定义自然数加法。*)\n\nFixpoint add (n m: nat): nat :=\n  match n with\n  | O => m\n  | S n' => S (add n' m)\n  end.\n\n(** 下面证明加法交换律。*)\n\nTheorem add_comm: forall n m,\n  add n m = add m n.\nProof.\n  intros.\n  induction n.\n  (** 证明到此处，我们发现我们需要首先证明_[n + 0 = n]_这条性质，我们先终止交换\n      律的证明，而先证明这条引理。*)\nAbort.\n\nLemma add_0_r: forall n, add n O = n.\nProof.\n  intros.\n  induction n; simpl.\n  + reflexivity.\n  + rewrite IHn.\n    reflexivity.\nQed.\n\nTheorem add_comm: forall n m,\n  add n m = add m n.\nProof.\n  intros.\n  induction n; simpl.\n  + rewrite add_0_r.\n    reflexivity.\n  + (** 证明到此处，我们发现我们需要还需要证明关于_[m + (S n)]_相关的性质。*)\nAbort.\n\nLemma add_succ_r: forall n m,\n  add n (S m) = S (add n m).\nProof.\n  intros.\n  induction n; simpl.\n  + reflexivity.\n  + rewrite IHn.\n    reflexivity.\nQed.\n\n(** 现在已经可以在Coq中完成加法交换律的证明了。*)\n\nTheorem add_comm: forall n m,\n  add n m = add m n.\nProof.\n  intros.\n  induction n; simpl.\n  + rewrite add_0_r.\n    reflexivity.\n  + rewrite add_succ_r.\n    rewrite IHn.\n    reflexivity.\nQed.\n\n(** 由于自然数范围内，数学意义上的减法是一个部分函数，因此，相关定义在Coq中并不常用。相\n    对而言，自然数的加法与乘法在Coq中更常用。*)\n\nFixpoint mul (n m: nat): nat :=\n  match n with\n  | O => O\n  | S p => add m (mul p m)\n  end.\n\n(** 下面列举加法与乘法的其它重要性质。*)\n\nTheorem add_assoc:\n  forall n m p, add n (add m p) = add (add n m) p.\nProof.\n  intros n m p; induction n; simpl.\n  + reflexivity.\n  + simpl.\n    rewrite IHn.\n    reflexivity.\nQed.\n\nTheorem add_cancel_l:\n  forall n m p, add p n = add p m <-> n = m.\nProof.\n  intros n m p; split.\n  + induction p; simpl; intros H.\n    - tauto.\n    - injection H as H.\n      pose proof IHp H.\n      tauto.\n  + intros H.\n    rewrite H.\n    reflexivity.\nQed.\n\nTheorem add_cancel_r:\n  forall n m p, add n p = add m p <-> n = m.\nProof.\n  intros n m p.\n  rewrite (add_comm n p), (add_comm m p).\n  apply add_cancel_l.\nQed.\n\nLemma mul_0_r: forall n, mul n O = O.\nProof.\n  intros.\n  induction n; simpl.\n  + reflexivity.\n  + apply IHn.\nQed.\n\nLemma mul_succ_r:\n  forall n m, mul n (S m) = add (mul n m) n.\nProof.\n  intros n m; induction n; simpl.\n  + reflexivity.\n  + rewrite IHn, add_succ_r.\n    rewrite <- add_assoc.\n    reflexivity.\nQed.\n\nTheorem mul_comm:\n  forall n m, mul n m = mul m n.\nProof.\n  intros n m; induction n; simpl.\n  + rewrite mul_0_r.\n    reflexivity.\n  + rewrite mul_succ_r.\n    rewrite IHn, add_comm.\n    reflexivity.\nQed.\n\nTheorem mul_add_distr_r:\n  forall n m p, mul (add n m) p = add (mul n p) (mul m p).\nProof.\n  intros n m p; induction n; simpl.\n  - reflexivity.\n  - rewrite <- add_assoc, IHn.\n    reflexivity.\nQed.\n\nTheorem mul_add_distr_l:\n  forall n m p, mul n (add m p) = add (mul n m) (mul n p).\nProof.\n  intros n m p.\n  rewrite (mul_comm n (add m p)), (mul_comm n m), (mul_comm n p).\n  apply mul_add_distr_r.\nQed.\n\nTheorem mul_assoc:\n  forall n m p, mul n (mul m p) = mul (mul n m) p.\nProof.\n  intros n m p; induction n; simpl.\n  + reflexivity.\n  + rewrite IHn, mul_add_distr_r.\n    reflexivity.\nQed.\n\nTheorem mul_1_l : forall n, mul (S O) n = n.\nProof. intros. simpl. apply add_0_r. Qed.\n\nTheorem mul_1_r : forall n, mul n (S O) = n.\nProof. intros. rewrite mul_comm, mul_1_l. reflexivity. Qed.\n\nEnd NatDemo.\n\n(** 上面介绍的加法与乘法运算性质在Coq标准库中已有证明，其定理名称如下。*)\n\nCheck Nat.add_comm.\nCheck Nat.add_assoc.\nCheck Nat.add_cancel_l.\nCheck Nat.add_cancel_r.\nCheck Nat.mul_comm.\nCheck Nat.mul_add_distr_r.\nCheck Nat.mul_add_distr_l.\nCheck Nat.mul_assoc.\nCheck Nat.mul_1_l.\nCheck Nat.mul_1_r.\n\n(** 前面已经提到，Coq在自然数集合上不便于表达减法等运算，因此，Coq用户有些时候可以选用\n    _[Z]_而非_[nat]_。然而，由于其便于表示计数概念以及表述数学归纳法，_[nat]_依然有许\n    多用途。例如，Coq标准库中的_[Nat.iter]_就表示函数多次迭代，具体而言，\n    _[Nat.iter n f]_表示将函数_[f]_迭代_[n]_次的结果。其Coq定义如下：  \n\n    Fixpoint iter {A: Type} (n: nat) (f: A -> A) (x: A): A :=\n      match n with\n      | O => x\n      | S n' => f (iter n' f x)\n      end.   \n\n    它符合许多重要性质，例如：*)\n\nTheorem iter_S: forall {A: Type} (n: nat) (f: A -> A) (x: A),\n  Nat.iter n f (f x) = Nat.iter (S n) f x.\n\n(** 注意，哪怕是如此简单的性质，我们还是需要在Coq中使用归纳法证明。*)\n\nProof.\n  intros.\n  induction n; simpl.\n  + reflexivity.\n  + rewrite IHn; simpl.\n    reflexivity.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请证明下面关于_[Nat.iter]_的性质。*)\n\nTheorem iter_add: forall {A: Type} (n m: nat) (f: A -> A) (x: A),\n  Nat.iter (n + m) f x = Nat.iter n f (Nat.iter m f x).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请证明下面关于_[Nat.iter]_的性质。*)\n\nTheorem iter_mul: forall {A: Type} (n m: nat) (f: A -> A) (x: A),\n  Nat.iter (n * m) f x = Nat.iter n (Nat.iter m f) x.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n\n"
        }
    ]
}