{
    "sourceFile": "logic.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1696840072457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1696848851083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,9 @@\n   (forall a: A, P a -> Q a) ->\n   (forall a: A, P a) ->\n   (forall a: A, Q a).\n Proof.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+  intros. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n \n (************)\n (** 习题：  *)\n (************)\n"
                },
                {
                    "date": 1696848997674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,10 +91,14 @@\n   (forall a: A, P a -> Q a) ->\n   (forall a: A, P a) ->\n   (forall a: A, Q a).\n Proof.\n-  intros. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n+  intros.\n+  pose proof H a. \n+  pose proof H0 a.\n+  tauto.\n+  (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+Qed.\n (************)\n (** 习题：  *)\n (************)\n \n"
                },
                {
                    "date": 1696853186596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,8 +509,13 @@\n   pose proof H x HP HQ.\n   apply H0.\n Qed.\n \n+\n+\n+\n+\n+\n (** 有时在证明中，我们不需要反复使用一个概称的前提，而只需要使用它的一个特例，此时如果\n     能在pose proof指令后删去原命题，能够使得证明目标更加简洁。这可以使用Coq中的\n     specialize指令实现。*)\n \n"
                },
                {
                    "date": 1696854136119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,670 @@\n+(** ******************************************************************* *)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** *【写在开始的注】课前阅读与课后阅读中的习题仅供参考，不是作业内容。*)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** ******************************************************************* *)\n+\n+Require Import Coq.Logic.Classical_Prop.\n+Require Import Coq.Setoids.Setoid.\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.micromega.Psatz.\n+Require Import PL.CoqIntro.\n+Require Import PL.InductiveType.\n+Local Open Scope Z.\n+\n+(** 数学中可以用“并且”、“或”、“非”、“如果-那么”、“存在”以及“任意”把简单性质组合起来构\n+    成复杂性质或复杂命题，例如“单调且连续”与“无限且不循环”这两个常用数学概念的定义中就\n+    用到了逻辑连接词“并且”，又例如“有零点”这一数学概念的定义就要用到“存在”这个逻辑中的\n+    量词（quantifier）。Coq中也允许用户使用这些常用的逻辑符号。  \n+\n+    下面是一个使用逻辑符号定义复合命题的例子。当我们如下定义“下凸函数”时，就可以用\n+    _[mono f /\\ convex f]_表示函数_[f]_是一个单调下凸函数。*)\n+\n+Definition convex (f: Z -> Z): Prop :=\n+  forall x: Z, f (x - 1) + f (x + 1) >= 2 * f x.\n+\n+(** 下面性质说的是，如果一个函数变换_[T]_能保持单调性，也能保持凸性，那么它也能保持“单\n+    调下凸”这个性质。*)\n+\n+Fact logic_ex1: forall T: (Z -> Z) -> (Z -> Z),\n+  (forall f, mono f -> mono (T f)) ->\n+  (forall f, convex f -> convex (T f)) ->\n+  (forall f, mono f /\\ convex f -> mono (T f) /\\ convex (T f)).\n+\n+(** 不难发现，这一性质的证明与单调性的定义无关，也和凸性的定义无关，这一性质的证明只需\n+    用到其中各个逻辑符号的性质。下面是Coq证明*)\n+Proof.\n+  intros.\n+  pose proof H f.\n+  pose proof H0 f.\n+  tauto.\n+Qed.\n+\n+(** 最后一条证明指令_[tauto]_是英文单词“tautology”的缩写，表示当前证明目标是一个命题\n+    逻辑永真式，可以自动证明。在上面证明中，如果把命题_[mono f]_与_[convex f]_记作命\n+    题_[P1]_与_[Q1]_，将命题_[mono (T f)]_看作一个整体记作_[P2]_，将命题\n+    _[convex (T f)]_也看作一个整体记为_[Q2]_，那么证明指令_[tauto]_在此处证明的结论\n+    就可以概括为：如果  \n+    _[P1]_成立并且_[Q1]_成立（前提_[H1]_）  \n+    _[P1]_能推出_[P2]_（前提_[H2]_）   \n+    _[Q1]_能推出_[Q2]_（前提_[H3]_）   \n+    那么_[P2]_成立并且_[Q2]_成立。不难看出，无论_[P1]_、_[Q1]_、_[P2]_与_[Q2]_这四\n+    个命题中的每一个是真是假，上述推导都成立。因此，这一推导过程可以用一个命题逻辑永真\n+    式刻画，_[tauto]_能够自动完成它的证明。  \n+\n+    Coq中也可以把这一原理单独地表述出来：*)\n+\n+Fact logic_ex2: forall P1 Q1 P2 Q2: Prop,\n+  P1 /\\ Q1 ->\n+  (P1 -> P2) ->\n+  (Q1 -> Q2) ->\n+  P2 /\\ Q2.\n+Proof.\n+  intros P1 Q1 P2 Q2 H1 H2 H3.\n+  tauto.\n+Qed.\n+\n+(** 仅仅利用_[tauto]_指令就已经能够证明不少关于逻辑的结论了。下面两个例子刻画了一个命\n+    题与其逆否命题的关系。*)\n+\n+Fact logic_ex3: forall {A: Type} (P Q: A -> Prop),\n+  (forall a: A, P a -> Q a) ->\n+  (forall a: A, ~ Q a -> ~ P a).\n+Proof. intros A P Q H a. pose proof H a. tauto. Qed.\n+\n+Fact logic_ex4: forall {A: Type} (P Q: A -> Prop),\n+  (forall a: A, ~ Q a -> ~ P a) ->\n+  (forall a: A, P a -> Q a).\n+Proof. intros A P Q H a. pose proof H a. tauto. Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex5: forall {A: Type} (P Q: A -> Prop),\n+  (forall a: A, P a -> Q a) ->\n+  (forall a: A, P a) ->\n+  (forall a: A, Q a).\n+Proof.\n+  intros.\n+  pose proof H a. \n+  pose proof H0 a.\n+  tauto.\n+  (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+Qed.\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex6: forall {A: Type} (P Q: A -> Prop) (a0: A),\n+  P a0 ->\n+  (forall a: A, P a -> Q a) ->\n+  Q a0.\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex7: forall {A: Type} (P Q: A -> Prop) (a0: A),\n+  (forall a: A, P a -> Q a -> False) ->\n+  Q a0 ->\n+  ~ P a0.\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex8: forall {A B: Type} (P Q: A -> B -> Prop),\n+  (forall (a: A) (b: B), P a b -> Q a b) ->\n+  (forall (a: A) (b: B), ~ P a b \\/ Q a b).\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex9: forall {A B: Type} (P Q: A -> B -> Prop),\n+  (forall (a: A) (b: B), ~ P a b \\/ Q a b) ->\n+  (forall (a: A) (b: B), P a b -> Q a b).\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** 尽管_[tauto]_指令利用命题逻辑永真式已经能够证明不少逻辑性质，但有些时候，我们需要\n+    对包含逻辑符号的命题进行更细粒度的操作才能完成Coq证明。本章的后续各节将展开介绍这些\n+    Coq中的证明方法。*)\n+\n+(** * 关于“并且”的证明 *)\n+\n+(** 要证明“某命题甲并且某命题乙”成立，可以在Coq中使用_[split]_证明指令进行证明。该\n+    指令会将当前的证明目标拆成两个子目标。*)\n+\n+Lemma and_intro: forall A B: Prop, A -> B -> A /\\ B.\n+Proof.\n+  intros A B HA HB.\n+  split.\n+  (** 下面的_[apply]_指令表示在证明中使用一条前提，或者使用一条已经经过证明的定\n+      理或引理。*)\n+  + apply HA.\n+  + apply HB.\n+Qed.\n+\n+(** 如果当前一条前提假设具有“某命题并且某命题”的形式，我们可以在Coq中使用\n+    _[destruct]_指令将其拆分成为两个前提。 *)\n+\n+Lemma proj1: forall P Q: Prop,\n+  P /\\ Q -> P.\n+Proof.\n+  intros.\n+  destruct H as [HP HQ].\n+  apply HP.\n+Qed.\n+\n+(** 另外，_[destruct]_指令也可以不指名拆分后的前提的名字，Coq会自动命名。*)\n+\n+Lemma proj2: forall P Q: Prop,\n+  P /\\ Q -> Q.\n+Proof.\n+  intros.\n+  destruct H.\n+  apply H0.\n+Qed.\n+\n+(** 当前提与结论中，都有_[/\\]_的时候，我们就既需要使用_[split]_指令，又需要使用\n+    _[destruct]_指令。*)\n+\n+Theorem and_comm: forall P Q: Prop,\n+  P /\\ Q -> Q /\\ P.\n+Proof.\n+  intros.\n+  destruct H as [HP HQ].\n+  split.\n+  + apply HQ.\n+  + apply HP.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem and_assoc1: forall P Q R: Prop,\n+  P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+Theorem and_assoc2: forall P Q R: Prop,\n+  (P /\\ Q) /\\ R -> P /\\ (Q /\\ R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** * 关于“或”的证明 *)\n+\n+(** “或”是另一个重要的逻辑连接词。如果“或”出现在前提中，我们可以用Coq中的\n+    _[destruct]_指令进行分类讨论。在下面的例子中，我们对于前提_[P \\/ Q]_进行分类讨\n+    论。要证明_[P \\/ Q]_能推出原结论，就需要证明_[P]_与_[Q]_中的任意一个都可以推出原\n+    结论。*)\n+\n+Fact or_example:\n+  forall P Q R: Prop, (P -> R) -> (Q -> R) -> (P \\/ Q -> R).\n+Proof.\n+  intros.\n+  destruct H1 as [HP | HQ].\n+  + pose proof H HP.\n+    apply H1.\n+  + pose proof H0 HQ.\n+    apply H1.\n+Qed.\n+\n+(** 相反的，如果要证明一条形如_[A \\/ B]_的结论整理，我们就只需要证明_[A]_与_[B]_\n+    两者之一成立就可以了。在Coq中的指令是：_[left]_与_[right]_。例如，下面是选择\n+    左侧命题的例子。*)\n+\n+Lemma or_introl: forall A B: Prop, A -> A \\/ B.\n+Proof.\n+  intros.\n+  left.\n+  apply H.\n+Qed.\n+\n+(** 下面是选择右侧命题的例子。*)\n+\n+Lemma or_intror: forall A B: Prop, B -> A \\/ B.\n+Proof.\n+  intros.\n+  right.\n+  apply H.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem or_comm: forall P Q: Prop,\n+  P \\/ Q  -> Q \\/ P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem or_assoc1: forall P Q R: Prop,\n+  P \\/ (Q \\/ R)  -> (P \\/ Q) \\/ R.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+Theorem or_assoc2: forall P Q R: Prop,\n+  (P \\/ Q) \\/ R -> P \\/ (Q \\/ R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+\n+\n+(** * 关于“当且仅当”的证明 *)\n+\n+(** 在Coq中，_[<->]_符号对应的定义是_[iff]_，其将_[P <-> Q]_定义为\n+          _[(P -> Q) /\\ (Q -> P)]_\n+    因此，要证明关于“当且仅当”的性质，首先可以使用其定义进行证明。*)\n+\n+Theorem iff_refl: forall P: Prop, P <-> P.\n+Proof.\n+  intros.\n+  unfold iff.\n+  split.\n+  + intros.\n+    apply H.\n+  + intros.\n+    apply H.\n+Qed.\n+\n+(** Coq也允许在不展开“当且仅当”的定义时就是用_[split]_或_[destruct]_指令进行证明。*)\n+\n+Theorem and_dup: forall P: Prop, P /\\ P <-> P.\n+Proof.\n+  intros.\n+  split.\n+  + intros.\n+    destruct H.\n+    apply H.\n+  + intros.\n+    split.\n+    - apply H.\n+    - apply H.\n+Qed.\n+\n+Theorem iff_imply: forall P Q: Prop, (P <-> Q) -> (P -> Q).\n+Proof.\n+  intros P Q H.\n+  destruct H.\n+  apply H.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem or_dup: forall P: Prop, P \\/ P <-> P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** * 命题逻辑综合应用 *)\n+\n+(** 下面是证明“并且”、“或”与“当且仅当”时常用的证明指令汇总与拓展。   \n+\n+    下面罗列了一些命题逻辑中的常见性质。请有兴趣的读者综合前几节所学内容，在不使用\n+    _[tauto]_证明指令的限制下完成下面证明。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“假言推理”规则。*)\n+\n+Theorem modus_ponens: forall P Q: Prop,\n+  P /\\ (P -> Q) -> Q.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”对“或”的分配律。*)\n+\n+Theorem and_or_distr_l: forall P Q R: Prop,\n+  P /\\ (Q \\/ R) <-> P /\\ Q \\/ P /\\ R.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”对“并且”的分配律。*)\n+\n+Theorem or_and_distr_l: forall P Q R: Prop,\n+  P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”对“或”的吸收律。*)\n+\n+Theorem and_or_absorb: forall P Q: Prop,\n+  P /\\ (P \\/ Q) <-> P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”对“并且”的吸收律。*)\n+\n+Theorem or_and_absorb: forall P Q: Prop,\n+  P \\/ (P /\\ Q) <-> P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”能保持逻辑等价性。*)\n+\n+Theorem and_congr: forall P1 Q1 P2 Q2: Prop,\n+  (P1 <-> P2) ->\n+  (Q1 <-> Q2) ->\n+  (P1 /\\ Q1 <-> P2 /\\ Q2).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”能保持逻辑等价性。*)\n+\n+Theorem or_congr: forall P1 Q1 P2 Q2: Prop,\n+  (P1 <-> P2) ->\n+  (Q1 <-> Q2) ->\n+  (P1 \\/ Q1 <-> P2 \\/ Q2).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”能保持逻辑等价性。*)\n+\n+Theorem imply_congr: forall P1 Q1 P2 Q2: Prop,\n+  (P1 <-> P2) ->\n+  (Q1 <-> Q2) ->\n+  ((P1 -> Q1) <-> (P2 -> Q2)).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n+    明辅助性质。*)\n+\n+Theorem and_imply: forall P Q R: Prop,\n+  (P /\\ Q -> R) <-> (P -> Q -> R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n+    明辅助性质。*)\n+\n+Theorem or_imply: forall P Q R: Prop,\n+  (P \\/ Q -> R) <-> (P -> R) /\\ (Q -> R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** 本章之后的内容中将介绍关于“任意”、“存在”与“非”的证明方式，在相关逻辑命题的证明过程\n+    中，涉及命题逻辑的部分将会灵活使用上面介绍的各种证明方式，包括_[tauto]_指令。习题\n+    中也不再限制使用_[tauto]_指令。 *)\n+\n+(** * 关于“存在”的证明 *)\n+\n+\n+(** 当待证明结论形为：“存在一个_[x]_使得...”，那么可以用_[exists]_指明究竟哪个\n+    _[x]_使得该性质成立。*)\n+\n+Lemma four_is_even : exists n, 4 = n + n.\n+Proof.\n+  exists 2.\n+  lia.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+Lemma six_is_not_prime: exists n, 2 <= n < 6 /\\ exists q, n * q = 6.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** 当某前提形为：存在一个_[x]_使得...，那么可以使用Coq中的_[destruct]_指令进行\n+    证明。这一证明指令相当于数学证明中的：任意给定一个这样的_[x]_。 *)\n+\n+Theorem dist_exists_and : forall (X: Type) (P Q: X -> Prop),\n+  (exists x, P x /\\ Q x) -> (exists x, P x) /\\ (exists x, Q x).\n+Proof.\n+  intros.\n+  destruct H as [x [HP HQ]].\n+  split.\n+  + exists x.\n+    apply HP.\n+  + exists x.\n+    apply HQ.\n+Qed.\n+\n+(** 从上面证明可以看出，Coq中可以使用引入模式将一个存在性的命题拆分，并且与其他引入模式\n+    嵌套使用。*)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+\n+(** 请在Coq中证明下面性质：*)\n+\n+Theorem exists_exists : forall (X Y: Type) (P: X -> Y -> Prop),\n+  (exists x y, P x y) <-> (exists y x, P x y).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+\n+(** * 关于“任意”的证明 *)\n+\n+(** 在逻辑中，与“存在”相对偶的量词是“任意”，即Coq中的_[forall]_。其实我们已经在Coq中\n+    证明了许多关于_[forall]_的命题，最常见的证明方法就是使用_[pose proof]_指令。下面\n+    是一个简单的例子。*)\n+\n+Example forall_ex1: forall (X: Type) (P Q R: X -> Prop),\n+  (forall x: X, P x -> Q x -> R x) ->\n+  (forall x: X, P x /\\ Q x -> R x).\n+Proof.\n+  intros X P Q R H x [HP HQ].\n+  pose proof H x HP HQ.\n+  apply H0.\n+Qed.\n+\n+\n+\n+\n+\n+\n+(** 有时在证明中，我们不需要反复使用一个概称的前提，而只需要使用它的一个特例，此时如果\n+    能在pose proof指令后删去原命题，能够使得证明目标更加简洁。这可以使用Coq中的\n+    specialize指令实现。*)\n+\n+Example forall_ex2: forall (X: Type) (P Q R: X -> Prop),\n+  (forall x: X, P x /\\ Q x -> R x) ->\n+  (forall x: X, P x -> Q x -> R x).\n+Proof.\n+  intros.\n+  specialize (H x).\n+  apply H.\n+Qed.\n+\n+(** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n+    后的_[R x]_，换言之，原有的概称命题被删去了。在Coq证明中，我们可以灵活使用Coq提供\n+    的自动化证明指令，例如，在下面证明中，我们使用_[tauto]_指令大大简化了证明。 *)\n+\n+Theorem forall_and: forall (A: Type) (P Q: A -> Prop),\n+  (forall a: A, P a /\\ Q a) <-> (forall a: A, P a) /\\ (forall a: A, Q a).\n+Proof.\n+  intros.\n+  (** 注意，此处不能使用_[tauto]_直接完成证明。*)\n+  split.\n+  + intros.\n+    split.\n+    - intros a.\n+      specialize (H a).\n+      (** 此时可以用_[tauto]_完成剩余证明了，另外两个分支也是类似。*)\n+      tauto.\n+    - intros a.\n+      specialize (H a).\n+      tauto.\n+  + intros.\n+    destruct H.\n+    specialize (H a).\n+    specialize (H0 a).\n+    tauto.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面性质：*)\n+\n+Theorem forall_forall : forall (X Y: Type) (P: X -> Y -> Prop),\n+  (forall x y, P x y) -> (forall y x, P x y).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面性质：*)\n+\n+Theorem forall_iff : forall (X: Type) (P Q: X -> Prop),\n+  (forall x: X, P x <-> Q x) ->\n+  ((forall x: X, P x) <-> (forall x: X, Q x)).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+\n+(** * 关于“非”的证明 *)\n+\n+\n+(** “非”是一个命题逻辑连接词，它符合两条重要性质：排中律与矛盾律。排中律说的是，对于任\n+    意一个命题P，P与非P中必有至少有一个为真。在Coq标准库中排中律称为_[classic]_，下面\n+    例子展示了在Coq应用排中律的方法。*)\n+\n+Example not_ex1: forall n m: Z, n < m \\/ ~ n < m.\n+Proof.\n+  intros.\n+  pose proof classic (n < m).\n+  apply H.\n+Qed.\n+\n+(** 矛盾律说的是，对于任意命题P，P与非P不能都为真。在Coq中，如果能从前提中同时推导出P\n+    与非P就意味着导出了矛盾。这一般可以用_[tauto]_完成证明。*)\n+\n+Example not_ex2: forall P Q: Prop,\n+  P -> ~ P -> Q.\n+Proof.\n+  intros.\n+  tauto.\n+Qed.\n+\n+(** 下面是一些关于“非”的重要性质，它们中的一部分可以直接使用_[tauto]_证明。 *)\n+\n+Theorem not_and_iff: forall P Q: Prop,\n+  ~ (P /\\ Q) <-> ~ P \\/ ~ Q.\n+Proof. intros. tauto. Qed.\n+\n+Theorem not_or_iff: forall P Q: Prop,\n+  ~ (P \\/ Q) <-> ~ P /\\ ~ Q.\n+Proof. intros. tauto. Qed.\n+\n+Theorem not_imply_iff: forall P Q: Prop,\n+  ~ (P -> Q) <-> P /\\ ~ Q.\n+Proof. intros. tauto. Qed.\n+\n+Theorem double_negation_iff: forall P: Prop,\n+  ~ ~ P <-> P.\n+Proof. intros. tauto. Qed.\n+\n+(** 在证明“非”与量词（_[exists]_， _[forall]_）的关系时，有时可能需要使用排中律。下面\n+    证明的是，如果不存在一个_[x]_使得_[P x]_成立，那么对于每一个_[x]_而言，都有\n+    _[~ P x]_成立。证明中，我们根据排中律，对于每一个特定的_[x]_进行分类讨论，究竟是\n+    _[P x]_成立还是_[~ P x]_成立。如果是后者，那么我们已经完成了证明。如果是前者，则\n+    可以推出与前提（不存在一个_[x]_使得_[P x]_成立）的矛盾。 *)\n+\n+Theorem not_exists: forall (X: Type) (P: X -> Prop),\n+  ~ (exists x: X, P x) -> (forall x: X, ~ P x).\n+Proof.\n+  intros.\n+  pose proof classic (P x) as [? | ?].\n+  + assert (exists x: X, P x). {\n+      exists x.\n+      apply H0.\n+    }\n+    tauto.\n+  + apply H0.\n+Qed.\n+\n+(** 下面再证明，如果并非每一个_[x]_都满足_[P x]_，那么就存在一个_[x]_使得_[~ P x]_成\n+    立。我们还是选择利用排中律进行证明。*)\n+\n+Theorem not_forall: forall (X: Type) (P: X -> Prop),\n+  ~ (forall x: X, P x) -> (exists x: X, ~ P x).\n+Proof.\n+  intros.\n+  pose proof classic (exists x: X, ~ P x) as [? | ?].\n+  + tauto.\n+  + pose proof not_exists _ _ H0.\n+    assert (forall x: X, P x <-> ~ ~ P x). {\n+      intros.\n+      tauto.\n+    }\n+    pose proof forall_iff _ P (fun x => ~ ~ P x) H2.\n+    tauto.\n+Qed.\n+\n+(** 利用前面的结论，我们还可以证明_[not_all]_的带约束版本。*)\n+\n+Corollary not_forall_imply: forall (X: Type) (P Q: X -> Prop),\n+  ~ (forall x: X, P x -> Q x) -> (exists x: X, P x /\\ ~ Q x).\n+Proof.\n+  intros.\n+  pose proof not_forall _ _ H.\n+  destruct H0 as [x H0].\n+  exists x.\n+  pose proof not_imply_iff (P x) (Q x).\n+  tauto.\n+Qed.\n+\n"
                },
                {
                    "date": 1696854166648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,678 +523,8 @@\n   (forall x: X, P x /\\ Q x -> R x) ->\n   (forall x: X, P x -> Q x -> R x).\n Proof.\n   intros.\n-  specialize (H x).\n-  apply H.\n-Qed.\n-\n-(** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n-    后的_[R x]_，换言之，原有的概称命题被删去了。在Coq证明中，我们可以灵活使用Coq提供\n-    的自动化证明指令，例如，在下面证明中，我们使用_[tauto]_指令大大简化了证明。 *)\n-\n-Theorem forall_and: forall (A: Type) (P Q: A -> Prop),\n-  (forall a: A, P a /\\ Q a) <-> (forall a: A, P a) /\\ (forall a: A, Q a).\n-Proof.\n-  intros.\n-  (** 注意，此处不能使用_[tauto]_直接完成证明。*)\n-  split.\n-  + intros.\n-    split.\n-    - intros a.\n-      specialize (H a).\n-      (** 此时可以用_[tauto]_完成剩余证明了，另外两个分支也是类似。*)\n-      tauto.\n-    - intros a.\n-      specialize (H a).\n-      tauto.\n-  + intros.\n-    destruct H.\n-    specialize (H a).\n-    specialize (H0 a).\n-    tauto.\n-Qed.\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面性质：*)\n-\n-Theorem forall_forall : forall (X Y: Type) (P: X -> Y -> Prop),\n-  (forall x y, P x y) -> (forall y x, P x y).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面性质：*)\n-\n-Theorem forall_iff : forall (X: Type) (P Q: X -> Prop),\n-  (forall x: X, P x <-> Q x) ->\n-  ((forall x: X, P x) <-> (forall x: X, Q x)).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-\n-(** * 关于“非”的证明 *)\n-\n-\n-(** “非”是一个命题逻辑连接词，它符合两条重要性质：排中律与矛盾律。排中律说的是，对于任\n-    意一个命题P，P与非P中必有至少有一个为真。在Coq标准库中排中律称为_[classic]_，下面\n-    例子展示了在Coq应用排中律的方法。*)\n-\n-Example not_ex1: forall n m: Z, n < m \\/ ~ n < m.\n-Proof.\n-  intros.\n-  pose proof classic (n < m).\n-  apply H.\n-Qed.\n-\n-(** 矛盾律说的是，对于任意命题P，P与非P不能都为真。在Coq中，如果能从前提中同时推导出P\n-    与非P就意味着导出了矛盾。这一般可以用_[tauto]_完成证明。*)\n-\n-Example not_ex2: forall P Q: Prop,\n-  P -> ~ P -> Q.\n-Proof.\n-  intros.\n-  tauto.\n-Qed.\n-\n-(** 下面是一些关于“非”的重要性质，它们中的一部分可以直接使用_[tauto]_证明。 *)\n-\n-Theorem not_and_iff: forall P Q: Prop,\n-  ~ (P /\\ Q) <-> ~ P \\/ ~ Q.\n-Proof. intros. tauto. Qed.\n-\n-Theorem not_or_iff: forall P Q: Prop,\n-  ~ (P \\/ Q) <-> ~ P /\\ ~ Q.\n-Proof. intros. tauto. Qed.\n-\n-Theorem not_imply_iff: forall P Q: Prop,\n-  ~ (P -> Q) <-> P /\\ ~ Q.\n-Proof. intros. tauto. Qed.\n-\n-Theorem double_negation_iff: forall P: Prop,\n-  ~ ~ P <-> P.\n-Proof. intros. tauto. Qed.\n-\n-(** 在证明“非”与量词（_[exists]_， _[forall]_）的关系时，有时可能需要使用排中律。下面\n-    证明的是，如果不存在一个_[x]_使得_[P x]_成立，那么对于每一个_[x]_而言，都有\n-    _[~ P x]_成立。证明中，我们根据排中律，对于每一个特定的_[x]_进行分类讨论，究竟是\n-    _[P x]_成立还是_[~ P x]_成立。如果是后者，那么我们已经完成了证明。如果是前者，则\n-    可以推出与前提（不存在一个_[x]_使得_[P x]_成立）的矛盾。 *)\n-\n-Theorem not_exists: forall (X: Type) (P: X -> Prop),\n-  ~ (exists x: X, P x) -> (forall x: X, ~ P x).\n-Proof.\n-  intros.\n-  pose proof classic (P x) as [? | ?].\n-  + assert (exists x: X, P x). {\n-      exists x.\n-      apply H0.\n-    }\n-    tauto.\n-  + apply H0.\n-Qed.\n-\n-(** 下面再证明，如果并非每一个_[x]_都满足_[P x]_，那么就存在一个_[x]_使得_[~ P x]_成\n-    立。我们还是选择利用排中律进行证明。*)\n-\n-Theorem not_forall: forall (X: Type) (P: X -> Prop),\n-  ~ (forall x: X, P x) -> (exists x: X, ~ P x).\n-Proof.\n-  intros.\n-  pose proof classic (exists x: X, ~ P x) as [? | ?].\n-  + tauto.\n-  + pose proof not_exists _ _ H0.\n-    assert (forall x: X, P x <-> ~ ~ P x). {\n-      intros.\n-      tauto.\n-    }\n-    pose proof forall_iff _ P (fun x => ~ ~ P x) H2.\n-    tauto.\n-Qed.\n-\n-(** 利用前面的结论，我们还可以证明_[not_all]_的带约束版本。*)\n-\n-Corollary not_forall_imply: forall (X: Type) (P Q: X -> Prop),\n-  ~ (forall x: X, P x -> Q x) -> (exists x: X, P x /\\ ~ Q x).\n-Proof.\n-  intros.\n-  pose proof not_forall _ _ H.\n-  destruct H0 as [x H0].\n-  exists x.\n-  pose proof not_imply_iff (P x) (Q x).\n-  tauto.\n-Qed.\n-\n-(** ******************************************************************* *)\n-(** *                                                                   *)\n-(** *                                                                   *)\n-(** *                                                                   *)\n-(** *【写在开始的注】课前阅读与课后阅读中的习题仅供参考，不是作业内容。*)\n-(** *                                                                   *)\n-(** *                                                                   *)\n-(** *                                                                   *)\n-(** ******************************************************************* *)\n-\n-Require Import Coq.Logic.Classical_Prop.\n-Require Import Coq.Setoids.Setoid.\n-Require Import Coq.ZArith.ZArith.\n-Require Import Coq.micromega.Psatz.\n-Require Import PL.CoqIntro.\n-Require Import PL.InductiveType.\n-Local Open Scope Z.\n-\n-(** 数学中可以用“并且”、“或”、“非”、“如果-那么”、“存在”以及“任意”把简单性质组合起来构\n-    成复杂性质或复杂命题，例如“单调且连续”与“无限且不循环”这两个常用数学概念的定义中就\n-    用到了逻辑连接词“并且”，又例如“有零点”这一数学概念的定义就要用到“存在”这个逻辑中的\n-    量词（quantifier）。Coq中也允许用户使用这些常用的逻辑符号。  \n-\n-    下面是一个使用逻辑符号定义复合命题的例子。当我们如下定义“下凸函数”时，就可以用\n-    _[mono f /\\ convex f]_表示函数_[f]_是一个单调下凸函数。*)\n-\n-Definition convex (f: Z -> Z): Prop :=\n-  forall x: Z, f (x - 1) + f (x + 1) >= 2 * f x.\n-\n-(** 下面性质说的是，如果一个函数变换_[T]_能保持单调性，也能保持凸性，那么它也能保持“单\n-    调下凸”这个性质。*)\n-\n-Fact logic_ex1: forall T: (Z -> Z) -> (Z -> Z),\n-  (forall f, mono f -> mono (T f)) ->\n-  (forall f, convex f -> convex (T f)) ->\n-  (forall f, mono f /\\ convex f -> mono (T f) /\\ convex (T f)).\n-\n-(** 不难发现，这一性质的证明与单调性的定义无关，也和凸性的定义无关，这一性质的证明只需\n-    用到其中各个逻辑符号的性质。下面是Coq证明*)\n-Proof.\n-  intros.\n-  pose proof H f.\n-  pose proof H0 f.\n-  tauto.\n-Qed.\n-\n-(** 最后一条证明指令_[tauto]_是英文单词“tautology”的缩写，表示当前证明目标是一个命题\n-    逻辑永真式，可以自动证明。在上面证明中，如果把命题_[mono f]_与_[convex f]_记作命\n-    题_[P1]_与_[Q1]_，将命题_[mono (T f)]_看作一个整体记作_[P2]_，将命题\n-    _[convex (T f)]_也看作一个整体记为_[Q2]_，那么证明指令_[tauto]_在此处证明的结论\n-    就可以概括为：如果  \n-    _[P1]_成立并且_[Q1]_成立（前提_[H1]_）  \n-    _[P1]_能推出_[P2]_（前提_[H2]_）   \n-    _[Q1]_能推出_[Q2]_（前提_[H3]_）   \n-    那么_[P2]_成立并且_[Q2]_成立。不难看出，无论_[P1]_、_[Q1]_、_[P2]_与_[Q2]_这四\n-    个命题中的每一个是真是假，上述推导都成立。因此，这一推导过程可以用一个命题逻辑永真\n-    式刻画，_[tauto]_能够自动完成它的证明。  \n-\n-    Coq中也可以把这一原理单独地表述出来：*)\n-\n-Fact logic_ex2: forall P1 Q1 P2 Q2: Prop,\n-  P1 /\\ Q1 ->\n-  (P1 -> P2) ->\n-  (Q1 -> Q2) ->\n-  P2 /\\ Q2.\n-Proof.\n-  intros P1 Q1 P2 Q2 H1 H2 H3.\n-  tauto.\n-Qed.\n-\n-(** 仅仅利用_[tauto]_指令就已经能够证明不少关于逻辑的结论了。下面两个例子刻画了一个命\n-    题与其逆否命题的关系。*)\n-\n-Fact logic_ex3: forall {A: Type} (P Q: A -> Prop),\n-  (forall a: A, P a -> Q a) ->\n-  (forall a: A, ~ Q a -> ~ P a).\n-Proof. intros A P Q H a. pose proof H a. tauto. Qed.\n-\n-Fact logic_ex4: forall {A: Type} (P Q: A -> Prop),\n-  (forall a: A, ~ Q a -> ~ P a) ->\n-  (forall a: A, P a -> Q a).\n-Proof. intros A P Q H a. pose proof H a. tauto. Qed.\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面结论。*)\n-\n-Fact logic_ex5: forall {A: Type} (P Q: A -> Prop),\n-  (forall a: A, P a -> Q a) ->\n-  (forall a: A, P a) ->\n-  (forall a: A, Q a).\n-Proof.\n-  intros.\n-  pose proof H a. \n-  pose proof H0 a.\n-  tauto.\n-  (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-Qed.\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面结论。*)\n-\n-Fact logic_ex6: forall {A: Type} (P Q: A -> Prop) (a0: A),\n-  P a0 ->\n-  (forall a: A, P a -> Q a) ->\n-  Q a0.\n-Proof.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面结论。*)\n-\n-Fact logic_ex7: forall {A: Type} (P Q: A -> Prop) (a0: A),\n-  (forall a: A, P a -> Q a -> False) ->\n-  Q a0 ->\n-  ~ P a0.\n-Proof.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面结论。*)\n-\n-Fact logic_ex8: forall {A B: Type} (P Q: A -> B -> Prop),\n-  (forall (a: A) (b: B), P a b -> Q a b) ->\n-  (forall (a: A) (b: B), ~ P a b \\/ Q a b).\n-Proof.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明下面结论。*)\n-\n-Fact logic_ex9: forall {A B: Type} (P Q: A -> B -> Prop),\n-  (forall (a: A) (b: B), ~ P a b \\/ Q a b) ->\n-  (forall (a: A) (b: B), P a b -> Q a b).\n-Proof.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(** 尽管_[tauto]_指令利用命题逻辑永真式已经能够证明不少逻辑性质，但有些时候，我们需要\n-    对包含逻辑符号的命题进行更细粒度的操作才能完成Coq证明。本章的后续各节将展开介绍这些\n-    Coq中的证明方法。*)\n-\n-(** * 关于“并且”的证明 *)\n-\n-(** 要证明“某命题甲并且某命题乙”成立，可以在Coq中使用_[split]_证明指令进行证明。该\n-    指令会将当前的证明目标拆成两个子目标。*)\n-\n-Lemma and_intro: forall A B: Prop, A -> B -> A /\\ B.\n-Proof.\n-  intros A B HA HB.\n-  split.\n-  (** 下面的_[apply]_指令表示在证明中使用一条前提，或者使用一条已经经过证明的定\n-      理或引理。*)\n-  + apply HA.\n-  + apply HB.\n-Qed.\n-\n-(** 如果当前一条前提假设具有“某命题并且某命题”的形式，我们可以在Coq中使用\n-    _[destruct]_指令将其拆分成为两个前提。 *)\n-\n-Lemma proj1: forall P Q: Prop,\n-  P /\\ Q -> P.\n-Proof.\n-  intros.\n-  destruct H as [HP HQ].\n-  apply HP.\n-Qed.\n-\n-(** 另外，_[destruct]_指令也可以不指名拆分后的前提的名字，Coq会自动命名。*)\n-\n-Lemma proj2: forall P Q: Prop,\n-  P /\\ Q -> Q.\n-Proof.\n-  intros.\n-  destruct H.\n-  apply H0.\n-Qed.\n-\n-(** 当前提与结论中，都有_[/\\]_的时候，我们就既需要使用_[split]_指令，又需要使用\n-    _[destruct]_指令。*)\n-\n-Theorem and_comm: forall P Q: Prop,\n-  P /\\ Q -> Q /\\ P.\n-Proof.\n-  intros.\n-  destruct H as [HP HQ].\n-  split.\n-  + apply HQ.\n-  + apply HP.\n-Qed.\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n-\n-Theorem and_assoc1: forall P Q R: Prop,\n-  P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-Theorem and_assoc2: forall P Q R: Prop,\n-  (P /\\ Q) /\\ R -> P /\\ (Q /\\ R).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(** * 关于“或”的证明 *)\n-\n-(** “或”是另一个重要的逻辑连接词。如果“或”出现在前提中，我们可以用Coq中的\n-    _[destruct]_指令进行分类讨论。在下面的例子中，我们对于前提_[P \\/ Q]_进行分类讨\n-    论。要证明_[P \\/ Q]_能推出原结论，就需要证明_[P]_与_[Q]_中的任意一个都可以推出原\n-    结论。*)\n-\n-Fact or_example:\n-  forall P Q R: Prop, (P -> R) -> (Q -> R) -> (P \\/ Q -> R).\n-Proof.\n-  intros.\n-  destruct H1 as [HP | HQ].\n-  + pose proof H HP.\n-    apply H1.\n-  + pose proof H0 HQ.\n-    apply H1.\n-Qed.\n-\n-(** 相反的，如果要证明一条形如_[A \\/ B]_的结论整理，我们就只需要证明_[A]_与_[B]_\n-    两者之一成立就可以了。在Coq中的指令是：_[left]_与_[right]_。例如，下面是选择\n-    左侧命题的例子。*)\n-\n-Lemma or_introl: forall A B: Prop, A -> A \\/ B.\n-Proof.\n-  intros.\n-  left.\n-  apply H.\n-Qed.\n-\n-(** 下面是选择右侧命题的例子。*)\n-\n-Lemma or_intror: forall A B: Prop, B -> A \\/ B.\n-Proof.\n-  intros.\n-  right.\n-  apply H.\n-Qed.\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n-\n-Theorem or_comm: forall P Q: Prop,\n-  P \\/ Q  -> Q \\/ P.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n-\n-Theorem or_assoc1: forall P Q R: Prop,\n-  P \\/ (Q \\/ R)  -> (P \\/ Q) \\/ R.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-Theorem or_assoc2: forall P Q R: Prop,\n-  (P \\/ Q) \\/ R -> P \\/ (Q \\/ R).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-\n-\n-(** * 关于“当且仅当”的证明 *)\n-\n-(** 在Coq中，_[<->]_符号对应的定义是_[iff]_，其将_[P <-> Q]_定义为\n-          _[(P -> Q) /\\ (Q -> P)]_\n-    因此，要证明关于“当且仅当”的性质，首先可以使用其定义进行证明。*)\n-\n-Theorem iff_refl: forall P: Prop, P <-> P.\n-Proof.\n-  intros.\n-  unfold iff.\n-  split.\n-  + intros.\n-    apply H.\n-  + intros.\n-    apply H.\n-Qed.\n-\n-(** Coq也允许在不展开“当且仅当”的定义时就是用_[split]_或_[destruct]_指令进行证明。*)\n-\n-Theorem and_dup: forall P: Prop, P /\\ P <-> P.\n-Proof.\n-  intros.\n-  split.\n-  + intros.\n-    destruct H.\n-    apply H.\n-  + intros.\n-    split.\n-    - apply H.\n-    - apply H.\n-Qed.\n-\n-Theorem iff_imply: forall P Q: Prop, (P <-> Q) -> (P -> Q).\n-Proof.\n-  intros P Q H.\n-  destruct H.\n-  apply H.\n-Qed.\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n-\n-Theorem or_dup: forall P: Prop, P \\/ P <-> P.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(** * 命题逻辑综合应用 *)\n-\n-(** 下面是证明“并且”、“或”与“当且仅当”时常用的证明指令汇总与拓展。   \n-\n-    下面罗列了一些命题逻辑中的常见性质。请有兴趣的读者综合前几节所学内容，在不使用\n-    _[tauto]_证明指令的限制下完成下面证明。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“假言推理”规则。*)\n-\n-Theorem modus_ponens: forall P Q: Prop,\n-  P /\\ (P -> Q) -> Q.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“并且”对“或”的分配律。*)\n-\n-Theorem and_or_distr_l: forall P Q R: Prop,\n-  P /\\ (Q \\/ R) <-> P /\\ Q \\/ P /\\ R.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“或”对“并且”的分配律。*)\n-\n-Theorem or_and_distr_l: forall P Q R: Prop,\n-  P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“并且”对“或”的吸收律。*)\n-\n-Theorem and_or_absorb: forall P Q: Prop,\n-  P /\\ (P \\/ Q) <-> P.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“或”对“并且”的吸收律。*)\n-\n-Theorem or_and_absorb: forall P Q: Prop,\n-  P \\/ (P /\\ Q) <-> P.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“并且”能保持逻辑等价性。*)\n-\n-Theorem and_congr: forall P1 Q1 P2 Q2: Prop,\n-  (P1 <-> P2) ->\n-  (Q1 <-> Q2) ->\n-  (P1 /\\ Q1 <-> P2 /\\ Q2).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“或”能保持逻辑等价性。*)\n-\n-Theorem or_congr: forall P1 Q1 P2 Q2: Prop,\n-  (P1 <-> P2) ->\n-  (Q1 <-> Q2) ->\n-  (P1 \\/ Q1 <-> P2 \\/ Q2).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“或”能保持逻辑等价性。*)\n-\n-Theorem imply_congr: forall P1 Q1 P2 Q2: Prop,\n-  (P1 <-> P2) ->\n-  (Q1 <-> Q2) ->\n-  ((P1 -> Q1) <-> (P2 -> Q2)).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“并且”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n-    明辅助性质。*)\n-\n-Theorem and_imply: forall P Q R: Prop,\n-  (P /\\ Q -> R) <-> (P -> Q -> R).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-(** 请在Coq中证明“或”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n-    明辅助性质。*)\n-\n-Theorem or_imply: forall P Q R: Prop,\n-  (P \\/ Q -> R) <-> (P -> R) /\\ (Q -> R).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(** 本章之后的内容中将介绍关于“任意”、“存在”与“非”的证明方式，在相关逻辑命题的证明过程\n-    中，涉及命题逻辑的部分将会灵活使用上面介绍的各种证明方式，包括_[tauto]_指令。习题\n-    中也不再限制使用_[tauto]_指令。 *)\n-\n-(** * 关于“存在”的证明 *)\n-\n-\n-(** 当待证明结论形为：“存在一个_[x]_使得...”，那么可以用_[exists]_指明究竟哪个\n-    _[x]_使得该性质成立。*)\n-\n-Lemma four_is_even : exists n, 4 = n + n.\n-Proof.\n-  exists 2.\n-  lia.\n-Qed.\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-Lemma six_is_not_prime: exists n, 2 <= n < 6 /\\ exists q, n * q = 6.\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-(** 当某前提形为：存在一个_[x]_使得...，那么可以使用Coq中的_[destruct]_指令进行\n-    证明。这一证明指令相当于数学证明中的：任意给定一个这样的_[x]_。 *)\n-\n-Theorem dist_exists_and : forall (X: Type) (P Q: X -> Prop),\n-  (exists x, P x /\\ Q x) -> (exists x, P x) /\\ (exists x, Q x).\n-Proof.\n-  intros.\n-  destruct H as [x [HP HQ]].\n-  split.\n-  + exists x.\n-    apply HP.\n-  + exists x.\n-    apply HQ.\n-Qed.\n-\n-(** 从上面证明可以看出，Coq中可以使用引入模式将一个存在性的命题拆分，并且与其他引入模式\n-    嵌套使用。*)\n-\n-(************)\n-(** 习题：  *)\n-(************)\n-\n-\n-(** 请在Coq中证明下面性质：*)\n-\n-Theorem exists_exists : forall (X Y: Type) (P: X -> Y -> Prop),\n-  (exists x y, P x y) <-> (exists y x, P x y).\n-Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n-\n-\n-(** * 关于“任意”的证明 *)\n-\n-(** 在逻辑中，与“存在”相对偶的量词是“任意”，即Coq中的_[forall]_。其实我们已经在Coq中\n-    证明了许多关于_[forall]_的命题，最常见的证明方法就是使用_[pose proof]_指令。下面\n-    是一个简单的例子。*)\n-\n-Example forall_ex1: forall (X: Type) (P Q R: X -> Prop),\n-  (forall x: X, P x -> Q x -> R x) ->\n-  (forall x: X, P x /\\ Q x -> R x).\n-Proof.\n-  intros X P Q R H x [HP HQ].\n-  pose proof H x HP HQ.\n-  apply H0.\n-Qed.\n-\n-\n-\n-\n-\n-\n-(** 有时在证明中，我们不需要反复使用一个概称的前提，而只需要使用它的一个特例，此时如果\n-    能在pose proof指令后删去原命题，能够使得证明目标更加简洁。这可以使用Coq中的\n-    specialize指令实现。*)\n-\n-Example forall_ex2: forall (X: Type) (P Q R: X -> Prop),\n-  (forall x: X, P x /\\ Q x -> R x) ->\n-  (forall x: X, P x -> Q x -> R x).\n-Proof.\n-  intros.\n   specialize (H x ltac:(tauto)).\n   apply H.\n Qed.\n \n"
                },
                {
                    "date": 1696854360515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,9 +523,9 @@\n   (forall x: X, P x /\\ Q x -> R x) ->\n   (forall x: X, P x -> Q x -> R x).\n Proof.\n   intros.\n-  specialize (H x ltac:(tauto)).\n+  specialize (H x (tauto)).\n   apply H.\n Qed.\n \n (** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n"
                },
                {
                    "date": 1696854366514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,9 +523,9 @@\n   (forall x: X, P x /\\ Q x -> R x) ->\n   (forall x: X, P x -> Q x -> R x).\n Proof.\n   intros.\n-  specialize (H x (tauto)).\n+  specialize (H x ltac:(tauto)).\n   apply H.\n Qed.\n \n (** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n"
                },
                {
                    "date": 1696854514183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,672 @@\n+(** ******************************************************************* *)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** *【写在开始的注】课前阅读与课后阅读中的习题仅供参考，不是作业内容。*)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** *                                                                   *)\n+(** ******************************************************************* *)\n+\n+Require Import Coq.Logic.Classical_Prop.\n+Require Import Coq.Setoids.Setoid.\n+Require Import Coq.ZArith.ZArith.\n+Require Import Coq.micromega.Psatz.\n+Require Import PL.CoqIntro.\n+Require Import PL.InductiveType.\n+Local Open Scope Z.\n+\n+(** 数学中可以用“并且”、“或”、“非”、“如果-那么”、“存在”以及“任意”把简单性质组合起来构\n+    成复杂性质或复杂命题，例如“单调且连续”与“无限且不循环”这两个常用数学概念的定义中就\n+    用到了逻辑连接词“并且”，又例如“有零点”这一数学概念的定义就要用到“存在”这个逻辑中的\n+    量词（quantifier）。Coq中也允许用户使用这些常用的逻辑符号。  \n+\n+    下面是一个使用逻辑符号定义复合命题的例子。当我们如下定义“下凸函数”时，就可以用\n+    _[mono f /\\ convex f]_表示函数_[f]_是一个单调下凸函数。*)\n+\n+Definition convex (f: Z -> Z): Prop :=\n+  forall x: Z, f (x - 1) + f (x + 1) >= 2 * f x.\n+\n+(** 下面性质说的是，如果一个函数变换_[T]_能保持单调性，也能保持凸性，那么它也能保持“单\n+    调下凸”这个性质。*)\n+\n+Fact logic_ex1: forall T: (Z -> Z) -> (Z -> Z),\n+  (forall f, mono f -> mono (T f)) ->\n+  (forall f, convex f -> convex (T f)) ->\n+  (forall f, mono f /\\ convex f -> mono (T f) /\\ convex (T f)).\n+\n+(** 不难发现，这一性质的证明与单调性的定义无关，也和凸性的定义无关，这一性质的证明只需\n+    用到其中各个逻辑符号的性质。下面是Coq证明*)\n+Proof.\n+  intros.\n+  pose proof H f.\n+  pose proof H0 f.\n+  tauto.\n+Qed.\n+\n+(** 最后一条证明指令_[tauto]_是英文单词“tautology”的缩写，表示当前证明目标是一个命题\n+    逻辑永真式，可以自动证明。在上面证明中，如果把命题_[mono f]_与_[convex f]_记作命\n+    题_[P1]_与_[Q1]_，将命题_[mono (T f)]_看作一个整体记作_[P2]_，将命题\n+    _[convex (T f)]_也看作一个整体记为_[Q2]_，那么证明指令_[tauto]_在此处证明的结论\n+    就可以概括为：如果  \n+    _[P1]_成立并且_[Q1]_成立（前提_[H1]_）  \n+    _[P1]_能推出_[P2]_（前提_[H2]_）   \n+    _[Q1]_能推出_[Q2]_（前提_[H3]_）   \n+    那么_[P2]_成立并且_[Q2]_成立。不难看出，无论_[P1]_、_[Q1]_、_[P2]_与_[Q2]_这四\n+    个命题中的每一个是真是假，上述推导都成立。因此，这一推导过程可以用一个命题逻辑永真\n+    式刻画，_[tauto]_能够自动完成它的证明。  \n+\n+    Coq中也可以把这一原理单独地表述出来：*)\n+\n+Fact logic_ex2: forall P1 Q1 P2 Q2: Prop,\n+  P1 /\\ Q1 ->\n+  (P1 -> P2) ->\n+  (Q1 -> Q2) ->\n+  P2 /\\ Q2.\n+Proof.\n+  intros P1 Q1 P2 Q2 H1 H2 H3.\n+  tauto.\n+Qed.\n+\n+(** 仅仅利用_[tauto]_指令就已经能够证明不少关于逻辑的结论了。下面两个例子刻画了一个命\n+    题与其逆否命题的关系。*)\n+\n+Fact logic_ex3: forall {A: Type} (P Q: A -> Prop),\n+  (forall a: A, P a -> Q a) ->\n+  (forall a: A, ~ Q a -> ~ P a).\n+Proof. intros A P Q H a. pose proof H a. tauto. Qed.\n+\n+Fact logic_ex4: forall {A: Type} (P Q: A -> Prop),\n+  (forall a: A, ~ Q a -> ~ P a) ->\n+  (forall a: A, P a -> Q a).\n+Proof. intros A P Q H a. pose proof H a. tauto. Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex5: forall {A: Type} (P Q: A -> Prop),\n+  (forall a: A, P a -> Q a) ->\n+  (forall a: A, P a) ->\n+  (forall a: A, Q a).\n+Proof.\n+  intros.\n+  pose proof H a. \n+  pose proof H0 a.\n+  tauto.\n+  (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+Qed.\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex6: forall {A: Type} (P Q: A -> Prop) (a0: A),\n+  P a0 ->\n+  (forall a: A, P a -> Q a) ->\n+  Q a0.\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex7: forall {A: Type} (P Q: A -> Prop) (a0: A),\n+  (forall a: A, P a -> Q a -> False) ->\n+  Q a0 ->\n+  ~ P a0.\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex8: forall {A B: Type} (P Q: A -> B -> Prop),\n+  (forall (a: A) (b: B), P a b -> Q a b) ->\n+  (forall (a: A) (b: B), ~ P a b \\/ Q a b).\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面结论。*)\n+\n+Fact logic_ex9: forall {A B: Type} (P Q: A -> B -> Prop),\n+  (forall (a: A) (b: B), ~ P a b \\/ Q a b) ->\n+  (forall (a: A) (b: B), P a b -> Q a b).\n+Proof.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** 尽管_[tauto]_指令利用命题逻辑永真式已经能够证明不少逻辑性质，但有些时候，我们需要\n+    对包含逻辑符号的命题进行更细粒度的操作才能完成Coq证明。本章的后续各节将展开介绍这些\n+    Coq中的证明方法。*)\n+\n+(** * 关于“并且”的证明 *)\n+\n+(** 要证明“某命题甲并且某命题乙”成立，可以在Coq中使用_[split]_证明指令进行证明。该\n+    指令会将当前的证明目标拆成两个子目标。*)\n+\n+Lemma and_intro: forall A B: Prop, A -> B -> A /\\ B.\n+Proof.\n+  intros A B HA HB.\n+  split.\n+  (** 下面的_[apply]_指令表示在证明中使用一条前提，或者使用一条已经经过证明的定\n+      理或引理。*)\n+  + apply HA.\n+  + apply HB.\n+Qed.\n+\n+(** 如果当前一条前提假设具有“某命题并且某命题”的形式，我们可以在Coq中使用\n+    _[destruct]_指令将其拆分成为两个前提。 *)\n+\n+Lemma proj1: forall P Q: Prop,\n+  P /\\ Q -> P.\n+Proof.\n+  intros.\n+  destruct H as [HP HQ].\n+  apply HP.\n+Qed.\n+\n+(** 另外，_[destruct]_指令也可以不指名拆分后的前提的名字，Coq会自动命名。*)\n+\n+Lemma proj2: forall P Q: Prop,\n+  P /\\ Q -> Q.\n+Proof.\n+  intros.\n+  destruct H.\n+  apply H0.\n+Qed.\n+\n+(** 当前提与结论中，都有_[/\\]_的时候，我们就既需要使用_[split]_指令，又需要使用\n+    _[destruct]_指令。*)\n+\n+Theorem and_comm: forall P Q: Prop,\n+  P /\\ Q -> Q /\\ P.\n+Proof.\n+  intros.\n+  destruct H as [HP HQ].\n+  split.\n+  + apply HQ.\n+  + apply HP.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem and_assoc1: forall P Q R: Prop,\n+  P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+Theorem and_assoc2: forall P Q R: Prop,\n+  (P /\\ Q) /\\ R -> P /\\ (Q /\\ R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** * 关于“或”的证明 *)\n+\n+(** “或”是另一个重要的逻辑连接词。如果“或”出现在前提中，我们可以用Coq中的\n+    _[destruct]_指令进行分类讨论。在下面的例子中，我们对于前提_[P \\/ Q]_进行分类讨\n+    论。要证明_[P \\/ Q]_能推出原结论，就需要证明_[P]_与_[Q]_中的任意一个都可以推出原\n+    结论。*)\n+\n+Fact or_example:\n+  forall P Q R: Prop, (P -> R) -> (Q -> R) -> (P \\/ Q -> R).\n+Proof.\n+  intros.\n+  destruct H1 as [HP | HQ].\n+  + pose proof H HP.\n+    apply H1.\n+  + pose proof H0 HQ.\n+    apply H1.\n+Qed.\n+\n+(** 相反的，如果要证明一条形如_[A \\/ B]_的结论整理，我们就只需要证明_[A]_与_[B]_\n+    两者之一成立就可以了。在Coq中的指令是：_[left]_与_[right]_。例如，下面是选择\n+    左侧命题的例子。*)\n+\n+Lemma or_introl: forall A B: Prop, A -> A \\/ B.\n+Proof.\n+  intros.\n+  left.\n+  apply H.\n+Qed.\n+\n+(** 下面是选择右侧命题的例子。*)\n+\n+Lemma or_intror: forall A B: Prop, B -> A \\/ B.\n+Proof.\n+  intros.\n+  right.\n+  apply H.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem or_comm: forall P Q: Prop,\n+  P \\/ Q  -> Q \\/ P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem or_assoc1: forall P Q R: Prop,\n+  P \\/ (Q \\/ R)  -> (P \\/ Q) \\/ R.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+Theorem or_assoc2: forall P Q R: Prop,\n+  (P \\/ Q) \\/ R -> P \\/ (Q \\/ R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+\n+\n+(** * 关于“当且仅当”的证明 *)\n+\n+(** 在Coq中，_[<->]_符号对应的定义是_[iff]_，其将_[P <-> Q]_定义为\n+          _[(P -> Q) /\\ (Q -> P)]_\n+    因此，要证明关于“当且仅当”的性质，首先可以使用其定义进行证明。*)\n+\n+Theorem iff_refl: forall P: Prop, P <-> P.\n+Proof.\n+  intros.\n+  unfold iff.\n+  split.\n+  + intros.\n+    apply H.\n+  + intros.\n+    apply H.\n+Qed.\n+\n+(** Coq也允许在不展开“当且仅当”的定义时就是用_[split]_或_[destruct]_指令进行证明。*)\n+\n+Theorem and_dup: forall P: Prop, P /\\ P <-> P.\n+Proof.\n+  intros.\n+  split.\n+  + intros.\n+    destruct H.\n+    apply H.\n+  + intros.\n+    split.\n+    - apply H.\n+    - apply H.\n+Qed.\n+\n+Theorem iff_imply: forall P Q: Prop, (P <-> Q) -> (P -> Q).\n+Proof.\n+  intros P Q H.\n+  destruct H.\n+  apply H.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n+\n+Theorem or_dup: forall P: Prop, P \\/ P <-> P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** * 命题逻辑综合应用 *)\n+\n+(** 下面是证明“并且”、“或”与“当且仅当”时常用的证明指令汇总与拓展。   \n+\n+    下面罗列了一些命题逻辑中的常见性质。请有兴趣的读者综合前几节所学内容，在不使用\n+    _[tauto]_证明指令的限制下完成下面证明。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“假言推理”规则。*)\n+\n+Theorem modus_ponens: forall P Q: Prop,\n+  P /\\ (P -> Q) -> Q.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”对“或”的分配律。*)\n+\n+Theorem and_or_distr_l: forall P Q R: Prop,\n+  P /\\ (Q \\/ R) <-> P /\\ Q \\/ P /\\ R.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”对“并且”的分配律。*)\n+\n+Theorem or_and_distr_l: forall P Q R: Prop,\n+  P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”对“或”的吸收律。*)\n+\n+Theorem and_or_absorb: forall P Q: Prop,\n+  P /\\ (P \\/ Q) <-> P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”对“并且”的吸收律。*)\n+\n+Theorem or_and_absorb: forall P Q: Prop,\n+  P \\/ (P /\\ Q) <-> P.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”能保持逻辑等价性。*)\n+\n+Theorem and_congr: forall P1 Q1 P2 Q2: Prop,\n+  (P1 <-> P2) ->\n+  (Q1 <-> Q2) ->\n+  (P1 /\\ Q1 <-> P2 /\\ Q2).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”能保持逻辑等价性。*)\n+\n+Theorem or_congr: forall P1 Q1 P2 Q2: Prop,\n+  (P1 <-> P2) ->\n+  (Q1 <-> Q2) ->\n+  (P1 \\/ Q1 <-> P2 \\/ Q2).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”能保持逻辑等价性。*)\n+\n+Theorem imply_congr: forall P1 Q1 P2 Q2: Prop,\n+  (P1 <-> P2) ->\n+  (Q1 <-> Q2) ->\n+  ((P1 -> Q1) <-> (P2 -> Q2)).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“并且”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n+    明辅助性质。*)\n+\n+Theorem and_imply: forall P Q R: Prop,\n+  (P /\\ Q -> R) <-> (P -> Q -> R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明“或”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n+    明辅助性质。*)\n+\n+Theorem or_imply: forall P Q R: Prop,\n+  (P \\/ Q -> R) <-> (P -> R) /\\ (Q -> R).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** 本章之后的内容中将介绍关于“任意”、“存在”与“非”的证明方式，在相关逻辑命题的证明过程\n+    中，涉及命题逻辑的部分将会灵活使用上面介绍的各种证明方式，包括_[tauto]_指令。习题\n+    中也不再限制使用_[tauto]_指令。 *)\n+\n+(** * 关于“存在”的证明 *)\n+\n+\n+(** 当待证明结论形为：“存在一个_[x]_使得...”，那么可以用_[exists]_指明究竟哪个\n+    _[x]_使得该性质成立。*)\n+\n+Lemma four_is_even : exists n, 4 = n + n.\n+Proof.\n+  exists 2.\n+  lia.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+Lemma six_is_not_prime: exists n, 2 <= n < 6 /\\ exists q, n * q = 6.\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(** 当某前提形为：存在一个_[x]_使得...，那么可以使用Coq中的_[destruct]_指令进行\n+    证明。这一证明指令相当于数学证明中的：任意给定一个这样的_[x]_。 *)\n+\n+Theorem dist_exists_and : forall (X: Type) (P Q: X -> Prop),\n+  (exists x, P x /\\ Q x) -> (exists x, P x) /\\ (exists x, Q x).\n+Proof.\n+  intros.\n+  destruct H as [x [HP HQ]].\n+  split.\n+  + exists x.\n+    apply HP.\n+  + exists x.\n+    apply HQ.\n+Qed.\n+\n+(** 从上面证明可以看出，Coq中可以使用引入模式将一个存在性的命题拆分，并且与其他引入模式\n+    嵌套使用。*)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+\n+(** 请在Coq中证明下面性质：*)\n+\n+Theorem exists_exists : forall (X Y: Type) (P: X -> Y -> Prop),\n+  (exists x y, P x y) <-> (exists y x, P x y).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+\n+(** * 关于“任意”的证明 *)\n+\n+(** 在逻辑中，与“存在”相对偶的量词是“任意”，即Coq中的_[forall]_。其实我们已经在Coq中\n+    证明了许多关于_[forall]_的命题，最常见的证明方法就是使用_[pose proof]_指令。下面\n+    是一个简单的例子。*)\n+\n+Example forall_ex1: forall (X: Type) (P Q R: X -> Prop),\n+  (forall x: X, P x -> Q x -> R x) ->\n+  (forall x: X, P x /\\ Q x -> R x).\n+Proof.\n+  intros X P Q R H x [HP HQ].\n+  pose proof H x HP HQ.\n+  apply H0.\n+Qed.\n+\n+\n+\n+\n+\n+\n+(** 有时在证明中，我们不需要反复使用一个概称的前提，而只需要使用它的一个特例，此时如果\n+    能在pose proof指令后删去原命题，能够使得证明目标更加简洁。这可以使用Coq中的\n+    specialize指令实现。*)\n+\n+    \n+\n+Example forall_ex2: forall (X: Type) (P Q R: X -> Prop),\n+  (forall x: X, P x /\\ Q x -> R x) ->\n+  (forall x: X, P x -> Q x -> R x).\n+Proof.\n+  intros.\n+  specialize (H x ltac:(tauto)).\n+  apply H.\n+Qed.\n+\n+(** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n+    后的_[R x]_，换言之，原有的概称命题被删去了。在Coq证明中，我们可以灵活使用Coq提供\n+    的自动化证明指令，例如，在下面证明中，我们使用_[tauto]_指令大大简化了证明。 *)\n+\n+Theorem forall_and: forall (A: Type) (P Q: A -> Prop),\n+  (forall a: A, P a /\\ Q a) <-> (forall a: A, P a) /\\ (forall a: A, Q a).\n+Proof.\n+  intros.\n+  (** 注意，此处不能使用_[tauto]_直接完成证明。*)\n+  split.\n+  + intros.\n+    split.\n+    - intros a.\n+      specialize (H a).\n+      (** 此时可以用_[tauto]_完成剩余证明了，另外两个分支也是类似。*)\n+      tauto.\n+    - intros a.\n+      specialize (H a).\n+      tauto.\n+  + intros.\n+    destruct H.\n+    specialize (H a).\n+    specialize (H0 a).\n+    tauto.\n+Qed.\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面性质：*)\n+\n+Theorem forall_forall : forall (X Y: Type) (P: X -> Y -> Prop),\n+  (forall x y, P x y) -> (forall y x, P x y).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+(************)\n+(** 习题：  *)\n+(************)\n+\n+(** 请在Coq中证明下面性质：*)\n+\n+Theorem forall_iff : forall (X: Type) (P Q: X -> Prop),\n+  (forall x: X, P x <-> Q x) ->\n+  ((forall x: X, P x) <-> (forall x: X, Q x)).\n+Admitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n+\n+\n+(** * 关于“非”的证明 *)\n+\n+\n+(** “非”是一个命题逻辑连接词，它符合两条重要性质：排中律与矛盾律。排中律说的是，对于任\n+    意一个命题P，P与非P中必有至少有一个为真。在Coq标准库中排中律称为_[classic]_，下面\n+    例子展示了在Coq应用排中律的方法。*)\n+\n+Example not_ex1: forall n m: Z, n < m \\/ ~ n < m.\n+Proof.\n+  intros.\n+  pose proof classic (n < m).\n+  apply H.\n+Qed.\n+\n+(** 矛盾律说的是，对于任意命题P，P与非P不能都为真。在Coq中，如果能从前提中同时推导出P\n+    与非P就意味着导出了矛盾。这一般可以用_[tauto]_完成证明。*)\n+\n+Example not_ex2: forall P Q: Prop,\n+  P -> ~ P -> Q.\n+Proof.\n+  intros.\n+  tauto.\n+Qed.\n+\n+(** 下面是一些关于“非”的重要性质，它们中的一部分可以直接使用_[tauto]_证明。 *)\n+\n+Theorem not_and_iff: forall P Q: Prop,\n+  ~ (P /\\ Q) <-> ~ P \\/ ~ Q.\n+Proof. intros. tauto. Qed.\n+\n+Theorem not_or_iff: forall P Q: Prop,\n+  ~ (P \\/ Q) <-> ~ P /\\ ~ Q.\n+Proof. intros. tauto. Qed.\n+\n+Theorem not_imply_iff: forall P Q: Prop,\n+  ~ (P -> Q) <-> P /\\ ~ Q.\n+Proof. intros. tauto. Qed.\n+\n+Theorem double_negation_iff: forall P: Prop,\n+  ~ ~ P <-> P.\n+Proof. intros. tauto. Qed.\n+\n+(** 在证明“非”与量词（_[exists]_， _[forall]_）的关系时，有时可能需要使用排中律。下面\n+    证明的是，如果不存在一个_[x]_使得_[P x]_成立，那么对于每一个_[x]_而言，都有\n+    _[~ P x]_成立。证明中，我们根据排中律，对于每一个特定的_[x]_进行分类讨论，究竟是\n+    _[P x]_成立还是_[~ P x]_成立。如果是后者，那么我们已经完成了证明。如果是前者，则\n+    可以推出与前提（不存在一个_[x]_使得_[P x]_成立）的矛盾。 *)\n+\n+Theorem not_exists: forall (X: Type) (P: X -> Prop),\n+  ~ (exists x: X, P x) -> (forall x: X, ~ P x).\n+Proof.\n+  intros.\n+  pose proof classic (P x) as [? | ?].\n+  + assert (exists x: X, P x). {\n+      exists x.\n+      apply H0.\n+    }\n+    tauto.\n+  + apply H0.\n+Qed.\n+\n+(** 下面再证明，如果并非每一个_[x]_都满足_[P x]_，那么就存在一个_[x]_使得_[~ P x]_成\n+    立。我们还是选择利用排中律进行证明。*)\n+\n+Theorem not_forall: forall (X: Type) (P: X -> Prop),\n+  ~ (forall x: X, P x) -> (exists x: X, ~ P x).\n+Proof.\n+  intros.\n+  pose proof classic (exists x: X, ~ P x) as [? | ?].\n+  + tauto.\n+  + pose proof not_exists _ _ H0.\n+    assert (forall x: X, P x <-> ~ ~ P x). {\n+      intros.\n+      tauto.\n+    }\n+    pose proof forall_iff _ P (fun x => ~ ~ P x) H2.\n+    tauto.\n+Qed.\n+\n+(** 利用前面的结论，我们还可以证明_[not_all]_的带约束版本。*)\n+\n+Corollary not_forall_imply: forall (X: Type) (P Q: X -> Prop),\n+  ~ (forall x: X, P x -> Q x) -> (exists x: X, P x /\\ ~ Q x).\n+Proof.\n+  intros.\n+  pose proof not_forall _ _ H.\n+  destruct H0 as [x H0].\n+  exists x.\n+  pose proof not_imply_iff (P x) (Q x).\n+  tauto.\n+Qed.\n+\n"
                },
                {
                    "date": 1696854520340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -518,10 +518,10 @@\n (** 有时在证明中，我们不需要反复使用一个概称的前提，而只需要使用它的一个特例，此时如果\n     能在pose proof指令后删去原命题，能够使得证明目标更加简洁。这可以使用Coq中的\n     specialize指令实现。*)\n \n-    \n \n+\n Example forall_ex2: forall (X: Type) (P Q R: X -> Prop),\n   (forall x: X, P x /\\ Q x -> R x) ->\n   (forall x: X, P x -> Q x -> R x).\n Proof.\n@@ -529,8 +529,11 @@\n   specialize (H x ltac:(tauto)).\n   apply H.\n Qed.\n \n+\n+\n+\n (** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n     后的_[R x]_，换言之，原有的概称命题被删去了。在Coq证明中，我们可以灵活使用Coq提供\n     的自动化证明指令，例如，在下面证明中，我们使用_[tauto]_指令大大简化了证明。 *)\n \n"
                }
            ],
            "date": 1696840072457,
            "name": "Commit-0",
            "content": "(** ******************************************************************* *)\n(** *                                                                   *)\n(** *                                                                   *)\n(** *                                                                   *)\n(** *【写在开始的注】课前阅读与课后阅读中的习题仅供参考，不是作业内容。*)\n(** *                                                                   *)\n(** *                                                                   *)\n(** *                                                                   *)\n(** ******************************************************************* *)\n\nRequire Import Coq.Logic.Classical_Prop.\nRequire Import Coq.Setoids.Setoid.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Psatz.\nRequire Import PL.CoqIntro.\nRequire Import PL.InductiveType.\nLocal Open Scope Z.\n\n(** 数学中可以用“并且”、“或”、“非”、“如果-那么”、“存在”以及“任意”把简单性质组合起来构\n    成复杂性质或复杂命题，例如“单调且连续”与“无限且不循环”这两个常用数学概念的定义中就\n    用到了逻辑连接词“并且”，又例如“有零点”这一数学概念的定义就要用到“存在”这个逻辑中的\n    量词（quantifier）。Coq中也允许用户使用这些常用的逻辑符号。  \n\n    下面是一个使用逻辑符号定义复合命题的例子。当我们如下定义“下凸函数”时，就可以用\n    _[mono f /\\ convex f]_表示函数_[f]_是一个单调下凸函数。*)\n\nDefinition convex (f: Z -> Z): Prop :=\n  forall x: Z, f (x - 1) + f (x + 1) >= 2 * f x.\n\n(** 下面性质说的是，如果一个函数变换_[T]_能保持单调性，也能保持凸性，那么它也能保持“单\n    调下凸”这个性质。*)\n\nFact logic_ex1: forall T: (Z -> Z) -> (Z -> Z),\n  (forall f, mono f -> mono (T f)) ->\n  (forall f, convex f -> convex (T f)) ->\n  (forall f, mono f /\\ convex f -> mono (T f) /\\ convex (T f)).\n\n(** 不难发现，这一性质的证明与单调性的定义无关，也和凸性的定义无关，这一性质的证明只需\n    用到其中各个逻辑符号的性质。下面是Coq证明*)\nProof.\n  intros.\n  pose proof H f.\n  pose proof H0 f.\n  tauto.\nQed.\n\n(** 最后一条证明指令_[tauto]_是英文单词“tautology”的缩写，表示当前证明目标是一个命题\n    逻辑永真式，可以自动证明。在上面证明中，如果把命题_[mono f]_与_[convex f]_记作命\n    题_[P1]_与_[Q1]_，将命题_[mono (T f)]_看作一个整体记作_[P2]_，将命题\n    _[convex (T f)]_也看作一个整体记为_[Q2]_，那么证明指令_[tauto]_在此处证明的结论\n    就可以概括为：如果  \n    _[P1]_成立并且_[Q1]_成立（前提_[H1]_）  \n    _[P1]_能推出_[P2]_（前提_[H2]_）   \n    _[Q1]_能推出_[Q2]_（前提_[H3]_）   \n    那么_[P2]_成立并且_[Q2]_成立。不难看出，无论_[P1]_、_[Q1]_、_[P2]_与_[Q2]_这四\n    个命题中的每一个是真是假，上述推导都成立。因此，这一推导过程可以用一个命题逻辑永真\n    式刻画，_[tauto]_能够自动完成它的证明。  \n\n    Coq中也可以把这一原理单独地表述出来：*)\n\nFact logic_ex2: forall P1 Q1 P2 Q2: Prop,\n  P1 /\\ Q1 ->\n  (P1 -> P2) ->\n  (Q1 -> Q2) ->\n  P2 /\\ Q2.\nProof.\n  intros P1 Q1 P2 Q2 H1 H2 H3.\n  tauto.\nQed.\n\n(** 仅仅利用_[tauto]_指令就已经能够证明不少关于逻辑的结论了。下面两个例子刻画了一个命\n    题与其逆否命题的关系。*)\n\nFact logic_ex3: forall {A: Type} (P Q: A -> Prop),\n  (forall a: A, P a -> Q a) ->\n  (forall a: A, ~ Q a -> ~ P a).\nProof. intros A P Q H a. pose proof H a. tauto. Qed.\n\nFact logic_ex4: forall {A: Type} (P Q: A -> Prop),\n  (forall a: A, ~ Q a -> ~ P a) ->\n  (forall a: A, P a -> Q a).\nProof. intros A P Q H a. pose proof H a. tauto. Qed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面结论。*)\n\nFact logic_ex5: forall {A: Type} (P Q: A -> Prop),\n  (forall a: A, P a -> Q a) ->\n  (forall a: A, P a) ->\n  (forall a: A, Q a).\nProof.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面结论。*)\n\nFact logic_ex6: forall {A: Type} (P Q: A -> Prop) (a0: A),\n  P a0 ->\n  (forall a: A, P a -> Q a) ->\n  Q a0.\nProof.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面结论。*)\n\nFact logic_ex7: forall {A: Type} (P Q: A -> Prop) (a0: A),\n  (forall a: A, P a -> Q a -> False) ->\n  Q a0 ->\n  ~ P a0.\nProof.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面结论。*)\n\nFact logic_ex8: forall {A B: Type} (P Q: A -> B -> Prop),\n  (forall (a: A) (b: B), P a b -> Q a b) ->\n  (forall (a: A) (b: B), ~ P a b \\/ Q a b).\nProof.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面结论。*)\n\nFact logic_ex9: forall {A B: Type} (P Q: A -> B -> Prop),\n  (forall (a: A) (b: B), ~ P a b \\/ Q a b) ->\n  (forall (a: A) (b: B), P a b -> Q a b).\nProof.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(** 尽管_[tauto]_指令利用命题逻辑永真式已经能够证明不少逻辑性质，但有些时候，我们需要\n    对包含逻辑符号的命题进行更细粒度的操作才能完成Coq证明。本章的后续各节将展开介绍这些\n    Coq中的证明方法。*)\n\n(** * 关于“并且”的证明 *)\n\n(** 要证明“某命题甲并且某命题乙”成立，可以在Coq中使用_[split]_证明指令进行证明。该\n    指令会将当前的证明目标拆成两个子目标。*)\n\nLemma and_intro: forall A B: Prop, A -> B -> A /\\ B.\nProof.\n  intros A B HA HB.\n  split.\n  (** 下面的_[apply]_指令表示在证明中使用一条前提，或者使用一条已经经过证明的定\n      理或引理。*)\n  + apply HA.\n  + apply HB.\nQed.\n\n(** 如果当前一条前提假设具有“某命题并且某命题”的形式，我们可以在Coq中使用\n    _[destruct]_指令将其拆分成为两个前提。 *)\n\nLemma proj1: forall P Q: Prop,\n  P /\\ Q -> P.\nProof.\n  intros.\n  destruct H as [HP HQ].\n  apply HP.\nQed.\n\n(** 另外，_[destruct]_指令也可以不指名拆分后的前提的名字，Coq会自动命名。*)\n\nLemma proj2: forall P Q: Prop,\n  P /\\ Q -> Q.\nProof.\n  intros.\n  destruct H.\n  apply H0.\nQed.\n\n(** 当前提与结论中，都有_[/\\]_的时候，我们就既需要使用_[split]_指令，又需要使用\n    _[destruct]_指令。*)\n\nTheorem and_comm: forall P Q: Prop,\n  P /\\ Q -> Q /\\ P.\nProof.\n  intros.\n  destruct H as [HP HQ].\n  split.\n  + apply HQ.\n  + apply HP.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n\nTheorem and_assoc1: forall P Q R: Prop,\n  P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\nTheorem and_assoc2: forall P Q R: Prop,\n  (P /\\ Q) /\\ R -> P /\\ (Q /\\ R).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(** * 关于“或”的证明 *)\n\n(** “或”是另一个重要的逻辑连接词。如果“或”出现在前提中，我们可以用Coq中的\n    _[destruct]_指令进行分类讨论。在下面的例子中，我们对于前提_[P \\/ Q]_进行分类讨\n    论。要证明_[P \\/ Q]_能推出原结论，就需要证明_[P]_与_[Q]_中的任意一个都可以推出原\n    结论。*)\n\nFact or_example:\n  forall P Q R: Prop, (P -> R) -> (Q -> R) -> (P \\/ Q -> R).\nProof.\n  intros.\n  destruct H1 as [HP | HQ].\n  + pose proof H HP.\n    apply H1.\n  + pose proof H0 HQ.\n    apply H1.\nQed.\n\n(** 相反的，如果要证明一条形如_[A \\/ B]_的结论整理，我们就只需要证明_[A]_与_[B]_\n    两者之一成立就可以了。在Coq中的指令是：_[left]_与_[right]_。例如，下面是选择\n    左侧命题的例子。*)\n\nLemma or_introl: forall A B: Prop, A -> A \\/ B.\nProof.\n  intros.\n  left.\n  apply H.\nQed.\n\n(** 下面是选择右侧命题的例子。*)\n\nLemma or_intror: forall A B: Prop, B -> A \\/ B.\nProof.\n  intros.\n  right.\n  apply H.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n\nTheorem or_comm: forall P Q: Prop,\n  P \\/ Q  -> Q \\/ P.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n\nTheorem or_assoc1: forall P Q R: Prop,\n  P \\/ (Q \\/ R)  -> (P \\/ Q) \\/ R.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\nTheorem or_assoc2: forall P Q R: Prop,\n  (P \\/ Q) \\/ R -> P \\/ (Q \\/ R).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n\n\n(** * 关于“当且仅当”的证明 *)\n\n(** 在Coq中，_[<->]_符号对应的定义是_[iff]_，其将_[P <-> Q]_定义为\n          _[(P -> Q) /\\ (Q -> P)]_\n    因此，要证明关于“当且仅当”的性质，首先可以使用其定义进行证明。*)\n\nTheorem iff_refl: forall P: Prop, P <-> P.\nProof.\n  intros.\n  unfold iff.\n  split.\n  + intros.\n    apply H.\n  + intros.\n    apply H.\nQed.\n\n(** Coq也允许在不展开“当且仅当”的定义时就是用_[split]_或_[destruct]_指令进行证明。*)\n\nTheorem and_dup: forall P: Prop, P /\\ P <-> P.\nProof.\n  intros.\n  split.\n  + intros.\n    destruct H.\n    apply H.\n  + intros.\n    split.\n    - apply H.\n    - apply H.\nQed.\n\nTheorem iff_imply: forall P Q: Prop, (P <-> Q) -> (P -> Q).\nProof.\n  intros P Q H.\n  destruct H.\n  apply H.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在不使用_[tauto]_指令的情况下证明下面结论。*)\n\nTheorem or_dup: forall P: Prop, P \\/ P <-> P.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(** * 命题逻辑综合应用 *)\n\n(** 下面是证明“并且”、“或”与“当且仅当”时常用的证明指令汇总与拓展。   \n\n    下面罗列了一些命题逻辑中的常见性质。请有兴趣的读者综合前几节所学内容，在不使用\n    _[tauto]_证明指令的限制下完成下面证明。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“假言推理”规则。*)\n\nTheorem modus_ponens: forall P Q: Prop,\n  P /\\ (P -> Q) -> Q.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“并且”对“或”的分配律。*)\n\nTheorem and_or_distr_l: forall P Q R: Prop,\n  P /\\ (Q \\/ R) <-> P /\\ Q \\/ P /\\ R.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“或”对“并且”的分配律。*)\n\nTheorem or_and_distr_l: forall P Q R: Prop,\n  P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“并且”对“或”的吸收律。*)\n\nTheorem and_or_absorb: forall P Q: Prop,\n  P /\\ (P \\/ Q) <-> P.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“或”对“并且”的吸收律。*)\n\nTheorem or_and_absorb: forall P Q: Prop,\n  P \\/ (P /\\ Q) <-> P.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“并且”能保持逻辑等价性。*)\n\nTheorem and_congr: forall P1 Q1 P2 Q2: Prop,\n  (P1 <-> P2) ->\n  (Q1 <-> Q2) ->\n  (P1 /\\ Q1 <-> P2 /\\ Q2).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“或”能保持逻辑等价性。*)\n\nTheorem or_congr: forall P1 Q1 P2 Q2: Prop,\n  (P1 <-> P2) ->\n  (Q1 <-> Q2) ->\n  (P1 \\/ Q1 <-> P2 \\/ Q2).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“或”能保持逻辑等价性。*)\n\nTheorem imply_congr: forall P1 Q1 P2 Q2: Prop,\n  (P1 <-> P2) ->\n  (Q1 <-> Q2) ->\n  ((P1 -> Q1) <-> (P2 -> Q2)).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“并且”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n    明辅助性质。*)\n\nTheorem and_imply: forall P Q R: Prop,\n  (P /\\ Q -> R) <-> (P -> Q -> R).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明“或”与“如果-那么”之间的关系。提示：必要时可以使用_[assert]_指令证\n    明辅助性质。*)\n\nTheorem or_imply: forall P Q R: Prop,\n  (P \\/ Q -> R) <-> (P -> R) /\\ (Q -> R).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(** 本章之后的内容中将介绍关于“任意”、“存在”与“非”的证明方式，在相关逻辑命题的证明过程\n    中，涉及命题逻辑的部分将会灵活使用上面介绍的各种证明方式，包括_[tauto]_指令。习题\n    中也不再限制使用_[tauto]_指令。 *)\n\n(** * 关于“存在”的证明 *)\n\n\n(** 当待证明结论形为：“存在一个_[x]_使得...”，那么可以用_[exists]_指明究竟哪个\n    _[x]_使得该性质成立。*)\n\nLemma four_is_even : exists n, 4 = n + n.\nProof.\n  exists 2.\n  lia.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\nLemma six_is_not_prime: exists n, 2 <= n < 6 /\\ exists q, n * q = 6.\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(** 当某前提形为：存在一个_[x]_使得...，那么可以使用Coq中的_[destruct]_指令进行\n    证明。这一证明指令相当于数学证明中的：任意给定一个这样的_[x]_。 *)\n\nTheorem dist_exists_and : forall (X: Type) (P Q: X -> Prop),\n  (exists x, P x /\\ Q x) -> (exists x, P x) /\\ (exists x, Q x).\nProof.\n  intros.\n  destruct H as [x [HP HQ]].\n  split.\n  + exists x.\n    apply HP.\n  + exists x.\n    apply HQ.\nQed.\n\n(** 从上面证明可以看出，Coq中可以使用引入模式将一个存在性的命题拆分，并且与其他引入模式\n    嵌套使用。*)\n\n(************)\n(** 习题：  *)\n(************)\n\n\n(** 请在Coq中证明下面性质：*)\n\nTheorem exists_exists : forall (X Y: Type) (P: X -> Y -> Prop),\n  (exists x y, P x y) <-> (exists y x, P x y).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n\n(** * 关于“任意”的证明 *)\n\n(** 在逻辑中，与“存在”相对偶的量词是“任意”，即Coq中的_[forall]_。其实我们已经在Coq中\n    证明了许多关于_[forall]_的命题，最常见的证明方法就是使用_[pose proof]_指令。下面\n    是一个简单的例子。*)\n\nExample forall_ex1: forall (X: Type) (P Q R: X -> Prop),\n  (forall x: X, P x -> Q x -> R x) ->\n  (forall x: X, P x /\\ Q x -> R x).\nProof.\n  intros X P Q R H x [HP HQ].\n  pose proof H x HP HQ.\n  apply H0.\nQed.\n\n(** 有时在证明中，我们不需要反复使用一个概称的前提，而只需要使用它的一个特例，此时如果\n    能在pose proof指令后删去原命题，能够使得证明目标更加简洁。这可以使用Coq中的\n    specialize指令实现。*)\n\nExample forall_ex2: forall (X: Type) (P Q R: X -> Prop),\n  (forall x: X, P x /\\ Q x -> R x) ->\n  (forall x: X, P x -> Q x -> R x).\nProof.\n  intros.\n  specialize (H x ltac:(tauto)).\n  apply H.\nQed.\n\n(** 在上面的证明中，specialize指令并没有生成新的前提，而是把原有的前提_[H]_改为了特化\n    后的_[R x]_，换言之，原有的概称命题被删去了。在Coq证明中，我们可以灵活使用Coq提供\n    的自动化证明指令，例如，在下面证明中，我们使用_[tauto]_指令大大简化了证明。 *)\n\nTheorem forall_and: forall (A: Type) (P Q: A -> Prop),\n  (forall a: A, P a /\\ Q a) <-> (forall a: A, P a) /\\ (forall a: A, Q a).\nProof.\n  intros.\n  (** 注意，此处不能使用_[tauto]_直接完成证明。*)\n  split.\n  + intros.\n    split.\n    - intros a.\n      specialize (H a).\n      (** 此时可以用_[tauto]_完成剩余证明了，另外两个分支也是类似。*)\n      tauto.\n    - intros a.\n      specialize (H a).\n      tauto.\n  + intros.\n    destruct H.\n    specialize (H a).\n    specialize (H0 a).\n    tauto.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面性质：*)\n\nTheorem forall_forall : forall (X Y: Type) (P: X -> Y -> Prop),\n  (forall x y, P x y) -> (forall y x, P x y).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 请在Coq中证明下面性质：*)\n\nTheorem forall_iff : forall (X: Type) (P Q: X -> Prop),\n  (forall x: X, P x <-> Q x) ->\n  ((forall x: X, P x) <-> (forall x: X, Q x)).\nAdmitted. (* 请删除这一行_[Admitted]_并填入你的证明，以_[Qed]_结束。 *)\n\n\n(** * 关于“非”的证明 *)\n\n\n(** “非”是一个命题逻辑连接词，它符合两条重要性质：排中律与矛盾律。排中律说的是，对于任\n    意一个命题P，P与非P中必有至少有一个为真。在Coq标准库中排中律称为_[classic]_，下面\n    例子展示了在Coq应用排中律的方法。*)\n\nExample not_ex1: forall n m: Z, n < m \\/ ~ n < m.\nProof.\n  intros.\n  pose proof classic (n < m).\n  apply H.\nQed.\n\n(** 矛盾律说的是，对于任意命题P，P与非P不能都为真。在Coq中，如果能从前提中同时推导出P\n    与非P就意味着导出了矛盾。这一般可以用_[tauto]_完成证明。*)\n\nExample not_ex2: forall P Q: Prop,\n  P -> ~ P -> Q.\nProof.\n  intros.\n  tauto.\nQed.\n\n(** 下面是一些关于“非”的重要性质，它们中的一部分可以直接使用_[tauto]_证明。 *)\n\nTheorem not_and_iff: forall P Q: Prop,\n  ~ (P /\\ Q) <-> ~ P \\/ ~ Q.\nProof. intros. tauto. Qed.\n\nTheorem not_or_iff: forall P Q: Prop,\n  ~ (P \\/ Q) <-> ~ P /\\ ~ Q.\nProof. intros. tauto. Qed.\n\nTheorem not_imply_iff: forall P Q: Prop,\n  ~ (P -> Q) <-> P /\\ ~ Q.\nProof. intros. tauto. Qed.\n\nTheorem double_negation_iff: forall P: Prop,\n  ~ ~ P <-> P.\nProof. intros. tauto. Qed.\n\n(** 在证明“非”与量词（_[exists]_， _[forall]_）的关系时，有时可能需要使用排中律。下面\n    证明的是，如果不存在一个_[x]_使得_[P x]_成立，那么对于每一个_[x]_而言，都有\n    _[~ P x]_成立。证明中，我们根据排中律，对于每一个特定的_[x]_进行分类讨论，究竟是\n    _[P x]_成立还是_[~ P x]_成立。如果是后者，那么我们已经完成了证明。如果是前者，则\n    可以推出与前提（不存在一个_[x]_使得_[P x]_成立）的矛盾。 *)\n\nTheorem not_exists: forall (X: Type) (P: X -> Prop),\n  ~ (exists x: X, P x) -> (forall x: X, ~ P x).\nProof.\n  intros.\n  pose proof classic (P x) as [? | ?].\n  + assert (exists x: X, P x). {\n      exists x.\n      apply H0.\n    }\n    tauto.\n  + apply H0.\nQed.\n\n(** 下面再证明，如果并非每一个_[x]_都满足_[P x]_，那么就存在一个_[x]_使得_[~ P x]_成\n    立。我们还是选择利用排中律进行证明。*)\n\nTheorem not_forall: forall (X: Type) (P: X -> Prop),\n  ~ (forall x: X, P x) -> (exists x: X, ~ P x).\nProof.\n  intros.\n  pose proof classic (exists x: X, ~ P x) as [? | ?].\n  + tauto.\n  + pose proof not_exists _ _ H0.\n    assert (forall x: X, P x <-> ~ ~ P x). {\n      intros.\n      tauto.\n    }\n    pose proof forall_iff _ P (fun x => ~ ~ P x) H2.\n    tauto.\nQed.\n\n(** 利用前面的结论，我们还可以证明_[not_all]_的带约束版本。*)\n\nCorollary not_forall_imply: forall (X: Type) (P Q: X -> Prop),\n  ~ (forall x: X, P x -> Q x) -> (exists x: X, P x /\\ ~ Q x).\nProof.\n  intros.\n  pose proof not_forall _ _ H.\n  destruct H0 as [x H0].\n  exists x.\n  pose proof not_imply_iff (P x) (Q x).\n  tauto.\nQed.\n\n"
        }
    ]
}