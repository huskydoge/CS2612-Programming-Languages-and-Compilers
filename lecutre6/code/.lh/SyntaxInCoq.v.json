{
    "sourceFile": "SyntaxInCoq.v",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1700543158022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1700543158022,
            "name": "Commit-0",
            "content": "Require Import Coq.Strings.String.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Psatz.\nLocal Open Scope string.\nLocal Open Scope Z.\n\n(** * 一个极简的指令式程序语言 *)\n\nModule Lang_SimpleWhile.\n\n(** 以下考虑一种极简的程序语言。它的程序表达式分为整数类型表达式与布尔类型表达\n    式，其中整数类型表达式只包含加减乘运算与变量、常数。布尔表达式中只包含整数类\n    型表达式之间的大小比较或者这些比较结果之间的布尔运算。而它的程序语句也只有对\n    变量赋值、顺序执行、if语句与while语句。   \n\n    下面依次在Coq中定义该语言变量名、表达式与语句。*)\n\nDefinition var_name: Type := string.\n\nInductive expr_int : Type :=\n  | EConst (n: Z): expr_int\n  | EVar (x: var_name): expr_int\n  | EAdd (e1 e2: expr_int): expr_int\n  | ESub (e1 e2: expr_int): expr_int\n  | EMul (e1 e2: expr_int): expr_int.\n\n(** 在Coq中，可以利用_[Notation]_使得这些表达式更加易读。*)\n\nDefinition EVar': string -> expr_int := EVar.\nDeclare Custom Entry expr_entry.\nCoercion EConst: Z >-> expr_int.\nCoercion EVar: var_name >-> expr_int.\nCoercion EVar': string >-> expr_int.\nNotation \"[[ e ]]\" := e\n  (at level 0, e custom expr_entry at level 99).\nNotation \"( x )\" := x\n  (in custom expr_entry, x custom expr_entry at level 99).\nNotation \"x\" := x\n  (in custom expr_entry at level 0, x constr at level 0).\nNotation \"f x\" := (f x)\n  (in custom expr_entry at level 1, only parsing,\n   f custom expr_entry,\n   x custom expr_entry at level 0).\nNotation \"x * y\" := (EMul x y)\n  (in custom expr_entry at level 11, left associativity).\nNotation \"x + y\" := (EAdd x y)\n  (in custom expr_entry at level 12, left associativity).\nNotation \"x - y\" := (ESub x y)\n  (in custom expr_entry at level 12, left associativity).\n\n(** 使用_[Notation]_的效果如下：*)\n\nCheck [[1 + \"x\"]].\nCheck [[\"x\" * (\"a\" + \"b\" + 1)]].\n\nInductive expr_bool: Type :=\n  | ETrue: expr_bool\n  | EFalse: expr_bool\n  | ELt (e1 e2: expr_int): expr_bool\n  | EAnd (e1 e2: expr_bool): expr_bool\n  | ENot (e: expr_bool): expr_bool.\n\nInductive com : Type :=\n  | CSkip: com\n  | CAsgn (x: var_name) (e: expr_int): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr_bool) (c1 c2: com): com\n  | CWhile (e: expr_bool) (c: com): com.\n\n\n\nEnd Lang_SimpleWhile.\n\n(** * While语言 *)\n\nModule Lang_While.\n\n\n(** 在许多以C语言为代表的常用程序语言中，往往不区分整数类型表达式与布尔类型表达\n    式，同时表达式中也包含更多运算符。例如，我们可以如下规定一种程序语言的语法。  \n\n\n    下面依次在Coq中定义该语言的变量名、表达式与语句。*)\n\nDefinition var_name: Type := string.\n\n(** 再定义二元运算符和一元运算符。*)\n\nInductive binop : Type :=\n  | OOr | OAnd\n  | OLt | OLe | OGt | OGe | OEq | ONe\n  | OPlus | OMinus | OMul | ODiv | OMod.\n\nInductive unop : Type :=\n  | ONot | ONeg.\n\n(** 下面是表达式的抽象语法树。*)\n\nInductive expr : Type :=\n  | EConst (n: Z): expr\n  | EVar (x: var_name): expr\n  | EBinop (op: binop) (e1 e2: expr): expr\n  | EUnop (op: unop) (e: expr): expr.\n\n(** 最后程序语句的定义是类似的。*)\n\nInductive com : Type :=\n  | CSkip: com\n  | CAsgn (x: var_name) (e: expr): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr) (c1 c2: com): com\n  | CWhile (e: expr) (c: com): com.\n\nEnd Lang_While.\n\n(** * 更多的程序语言：WhileDeref *)\n\nModule Lang_WhileDeref.\nImport Lang_While.\n\n(** 下面在While程序语言中增加取地址上的值_[EDeref]_操作。*)\n\nInductive expr : Type :=\n  | EConst (n: Z): expr\n  | EVar (x: var_name): expr\n  | EBinop (op: binop) (e1 e2: expr): expr\n  | EUnop (op: unop) (e: expr): expr\n  | EDeref (e: expr): expr.\n\n(** 相应的，赋值语句也可以分为两种情况。*)\n\nInductive com : Type :=\n  | CSkip: com\n  | CAsgnVar (x: var_name) (e: expr): com\n  | CAsgnDeref (e1 e2: expr): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr) (c1 c2: com): com\n  | CWhile (e: expr) (c: com): com.\n\nEnd Lang_WhileDeref.\n\n(** * 更多的程序语言：WhileD *)\n\nModule Lang_WhileD.\nImport Lang_While.\n\n(** 在大多数程序语言中，会同时支持或不支持取地址_[EAddrOf]_与取地址上的值\n    _[EDeref]_两类操作，我们也可以在WhileDeref语言中再加入取地址操作。*)\n\nInductive expr : Type :=\n  | EConst (n: Z): expr\n  | EVar (x: var_name): expr\n  | EBinop (op: binop) (e1 e2: expr): expr\n  | EUnop (op: unop) (e: expr): expr\n  | EDeref (e: expr): expr\n  | EAddrOf (e: expr): expr.\n\n(** 程序语句的语法树不变。*)\n\nInductive com : Type :=\n  | CSkip: com\n  | CAsgnVar (x: var_name) (e: expr): com\n  | CAsgnDeref (e1 e2: expr): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr) (c1 c2: com): com\n  | CWhile (e: expr) (c: com): com.\n\nEnd Lang_WhileD.\n\n(** * 更多的程序语言：WhileDC *)\n\nModule Lang_WhileDC.\nImport Lang_While.\n\n(** 下面在程序语句中增加控制流语句continue与break，并增加多种循环语句。*)\n\nInductive expr : Type :=\n  | EConst (n: Z): expr\n  | EVar (x: var_name): expr\n  | EBinop (op: binop) (e1 e2: expr): expr\n  | EUnop (op: unop) (e: expr): expr\n  | EDeref (e: expr): expr\n  | EAddrOf (e: expr): expr.\n\nInductive com : Type :=\n  | CSkip: com\n  | CAsgnVar (x: var_name) (e: expr): com\n  | CAsgnDeref (e1 e2: expr): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr) (c1 c2: com): com\n  | CWhile (e: expr) (c: com): com\n  | CFor (c1: com) (e: expr) (c2: com) (c3: com): com\n  | CDoWhile (c: com) (e: expr): com\n  | CContinue: com\n  | CBreak: com.\n\nEnd Lang_WhileDC.\n\n(** * 更多的程序语言：WhileDCL *)\n\nModule Lang_WhileDCL.\nImport Lang_While.\n\n(** 下面在程序语句中增加局部变量声明。*)\n\nInductive com : Type :=\n  | CSkip: com\n  | CLocalVar (x: var_name) (c1: com): com\n  | CAsgnVar (x: var_name) (e: expr): com\n  | CAsgnDeref (e1 e2: expr): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr) (c1 c2: com): com\n  | CWhile (e: expr) (c: com): com\n  | CFor (c1: com) (e: expr) (c2: com) (c3: com): com\n  | CDoWhile (c: com) (e: expr): com\n  | CContinue: com\n  | CBreak: com.\n\nEnd Lang_WhileDCL.\n\n(** * 更多的程序语言：WhileF *)\n\nModule Lang_WhileF.\nImport Lang_While.\n\n(** 下面在程序表达式中增加函数调用，在程序语句中增加过程调用。*)\nDefinition func_name: Type := string.\nDefinition proc_name: Type := string.\n\n(** 下面是新的表达式定义，这是一个嵌套递归定义。*)\n\nInductive expr : Type :=\n  | EConst (n: Z): expr\n  | EVar (x: var_name): expr\n  | EBinop (op: binop) (e1 e2: expr): expr\n  | EUnop (op: unop) (e: expr): expr\n  | EDeref (e: expr): expr\n  | EAddrOf (e: expr): expr\n  | EFuncCall (f: func_name) (es: list expr).\n\n(** 下面是新的程序语句定义，这也是一个嵌套递归定义。这里约定_[return_var]_是一个\n    特定的表示返回值的变量，而返回指令本身没有参数。*)\n\nDefinition return_var: var_name := \"__return\".\n\nInductive com : Type :=\n  | CSkip: com\n  | CLocalVar (x: var_name) (c1: com): com\n  | CAsgnVar (x: var_name) (e: expr): com\n  | CAsgnDeref (e1 e2: expr): com\n  | CProcCall (p: proc_name) (es: list expr): com\n  | CSeq (c1 c2: com): com\n  | CIf (e: expr) (c1 c2: com): com\n  | CWhile (e: expr) (c: com): com\n  | CFor (c1: com) (e: expr) (c2: com) (c3: com): com\n  | CDoWhile (c: com) (e: expr): com\n  | CContinue: com\n  | CBreak: com\n  | CReturn: com.\n\n(** 下面定义程序中的函数与过程。*)\n\nRecord func: Type := {\n  name_of_func: func_name;\n  body_of_func: com;\n  args_of_func: list var_name;\n}.\n\nRecord proc: Type := {\n  name_of_proc: proc_name;\n  body_of_proc: com;\n  args_of_proc: list var_name;\n}.\n\n(** 最后，一段完整的程序由全局变量列表、函数列表、过程列表与入口函数组成。*)\n\nRecord prog: Type := {\n  gvars: list var_name;\n  funcs: list func;\n  procs: list proc;\n  entry: func_name\n}.\n\n\nEnd Lang_WhileF.\n\n(** * 简单语法变换与证明 *)\n\nModule LangTrans.\nImport Lang_SimpleWhile.\n\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 下面的递归函数_[remove_skip]_定义了在程序语句中删除多余空语句的操作。*)\n\nFixpoint remove_skip (c: com): com :=\n  match c with\n  | CSeq c1 c2 =>\n      match remove_skip c1, remove_skip c2 with\n      | CSkip, _ => remove_skip c2\n      | _, CSkip => remove_skip c1\n      | _, _ => CSeq (remove_skip c1) (remove_skip c2)\n      end\n  | CIf e c1 c2 =>\n      CIf e (remove_skip c1) (remove_skip c2)\n  | CWhile e c1 =>\n      CWhile e (remove_skip c1)\n  | _ =>\n      c\n  end.\n\n(** 下面请证明：_[remove_skip]_之后，确实不再有多余的空语句了。所谓没有空语句，\n    是指不出现_[c; SKIP]_或_[SKIP; c]_这样的语句。首先定义：局部不存在多余的空语\n    句。*)\n\nDefinition not_sequencing_skip (c: com): Prop :=\n  match c with\n  | CSeq CSkip _ => False\n  | CSeq _ CSkip => False\n  | _ => True\n  end.\n\n(** 其次定义语法树的所有子树中都不存在多余的空语句。*)\n\nFixpoint no_sequenced_skip (c: com): Prop :=\n  match c with\n  | CSeq c1 c2 =>\n      not_sequencing_skip c /\\\n      no_sequenced_skip c1 /\\ no_sequenced_skip c2\n  | CIf e c1 c2 =>\n      no_sequenced_skip c1 /\\ no_sequenced_skip c2\n  | CWhile e c1 =>\n      no_sequenced_skip c1\n  | _ =>\n      True\n  end.\n\n(** 下面是需要证明的结论。*)\n\nTheorem remove_skip_no_sequenced_skip: forall c,\n  no_sequenced_skip (remove_skip c).\n(* 请在此处填入你的证明，以_[Qed]_结束。 *)\nProof.\n  intros.\n  induction c; simpl.\n  + tauto.\n  + tauto.\n  + destruct (remove_skip c1), (remove_skip c2);\n      simpl; simpl in IHc1; simpl in IHc2; tauto.\n  + tauto.\n  + tauto.\nQed.\n\n\nEnd LangTrans.\n\n\n"
        }
    ]
}